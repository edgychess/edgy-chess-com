{"version":3,"sources":["SubdivisionModifier.js","tween.js","tween.fix.js","JoclyOrbitControls.js","DeviceOrientationControls.js","Projector.js","threex.domevent.js","threex.domevent.object3d.js","StereoEffect.js","AnaglyphEffect.js","VRGamepad.js","VRControls.js","VREffect.js","OBJLoader.js","MTLLoader.js","kalman.js","jocly.ar.js","jocly.state-machine.js","jocly.xd-view.js"],"names":[],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACrrBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACtRA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AClDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACvoBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACxHA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACj6BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AC5iBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACrCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AClDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACxJA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACxfA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AC7KA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AC7dA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACtuBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AC5hBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACxFA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AChMA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AC5dA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"jocly-xdview.js","sourcesContent":["/*\r\n *\t@author zz85 / http://twitter.com/blurspline / http://www.lab4games.net/zz85/blog \r\n *\r\n *\tSubdivision Geometry Modifier \r\n *\t\tusing Catmull-Clark Subdivision Surfaces\r\n *\t\tfor creating smooth geometry meshes\r\n *\r\n *\tNote: a modifier modifies vertices and faces of geometry,\r\n *\t\tso use geometry.clone() if original geometry needs to be retained\r\n * \r\n *\tReadings: \r\n *\t\thttp://en.wikipedia.org/wiki/Catmull%E2%80%93Clark_subdivision_surface\r\n *\t\thttp://www.rorydriscoll.com/2008/08/01/catmull-clark-subdivision-the-basics/\r\n *\t\thttp://xrt.wikidot.com/blog:31\r\n *\t\t\"Subdivision Surfaces in Character Animation\"\r\n *\r\n *\t\t(on boundary edges)\r\n *\t\thttp://rosettacode.org/wiki/Catmull%E2%80%93Clark_subdivision_surface\r\n *\t\thttps://graphics.stanford.edu/wikis/cs148-09-summer/Assignment3Description\r\n *\r\n *\tSupports:\r\n *\t\tClosed and Open geometries.\r\n *\r\n *\tTODO:\r\n *\t\tcrease vertex and \"semi-sharp\" features\r\n *\t\tselective subdivision\r\n */\r\n\r\nTHREE.SubdivisionModifier = function ( subdivisions ) {\r\n\r\n\tthis.subdivisions = (subdivisions === undefined ) ? 1 : subdivisions;\r\n\r\n\t// Settings\r\n\tthis.useOldVertexColors = false;\r\n\tthis.supportUVs = true;\r\n\tthis.debug = false;\r\n\r\n};\r\n\r\n// Applies the \"modify\" pattern\r\nTHREE.SubdivisionModifier.prototype.modify = function ( geometry ) {\r\n\r\n\tvar repeats = this.subdivisions;\r\n\r\n\twhile ( repeats-- > 0 ) {\r\n\t\tthis.smooth( geometry );\r\n\t}\r\n\r\n};\r\n\r\n/// REFACTORING THIS OUT\r\n\r\nTHREE.GeometryUtils.orderedKey = function ( a, b ) {\r\n\r\n\treturn Math.min( a, b ) + \"_\" + Math.max( a, b );\r\n\r\n};\r\n\r\n\r\n// Returns a hashmap - of { edge_key: face_index }\r\nTHREE.GeometryUtils.computeEdgeFaces = function ( geometry ) {\r\n\r\n\tvar i, il, v1, v2, j, k,\r\n\t\tface, faceIndices, faceIndex,\r\n\t\tedge,\r\n\t\thash,\r\n\t\tedgeFaceMap = {};\r\n\r\n\tvar orderedKey = THREE.GeometryUtils.orderedKey;\r\n\r\n\tfunction mapEdgeHash( hash, i ) {\r\n\r\n\t\tif ( edgeFaceMap[ hash ] === undefined ) {\r\n\r\n\t\t\tedgeFaceMap[ hash ] = [];\r\n\r\n\t\t}\r\n\r\n\t\tedgeFaceMap[ hash ].push( i );\r\n\t}\r\n\r\n\r\n\t// construct vertex -> face map\r\n\r\n\tfor( i = 0, il = geometry.faces.length; i < il; i ++ ) {\r\n\r\n\t\tface = geometry.faces[ i ];\r\n\r\n\t\tif ( face instanceof THREE.Face3 ) {\r\n\r\n\t\t\thash = orderedKey( face.a, face.b );\r\n\t\t\tmapEdgeHash( hash, i );\r\n\r\n\t\t\thash = orderedKey( face.b, face.c );\r\n\t\t\tmapEdgeHash( hash, i );\r\n\r\n\t\t\thash = orderedKey( face.c, face.a );\r\n\t\t\tmapEdgeHash( hash, i );\r\n\r\n\t\t} else if ( face instanceof THREE.Face4 ) {\r\n\r\n\t\t\thash = orderedKey( face.a, face.b );\r\n\t\t\tmapEdgeHash( hash, i );\r\n\r\n\t\t\thash = orderedKey( face.b, face.c );\r\n\t\t\tmapEdgeHash( hash, i );\r\n\r\n\t\t\thash = orderedKey( face.c, face.d );\r\n\t\t\tmapEdgeHash( hash, i );\r\n\r\n\t\t\thash = orderedKey( face.d, face.a );\r\n\t\t\tmapEdgeHash( hash, i );\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\t// extract faces\r\n\r\n\t// var edges = [];\r\n\t// \r\n\t// var numOfEdges = 0;\r\n\t// for (i in edgeFaceMap) {\r\n\t// \tnumOfEdges++;\r\n\t//\r\n\t// \tedge = edgeFaceMap[i];\r\n\t// \tedges.push(edge);\r\n\t//\r\n\t// }\r\n\r\n\t//debug('edgeFaceMap', edgeFaceMap, 'geometry.edges',geometry.edges, 'numOfEdges', numOfEdges);\r\n\r\n\treturn edgeFaceMap;\r\n\r\n}\r\n\r\n/////////////////////////////\r\n\r\n// Performs an iteration of Catmull-Clark Subdivision\r\nTHREE.SubdivisionModifier.prototype.smooth = function ( oldGeometry ) {\r\n\r\n\t//debug( 'running smooth' );\r\n\r\n\t// New set of vertices, faces and uvs\r\n\tvar newVertices = [], newFaces = [], newUVs = [];\r\n\r\n\tfunction v( x, y, z ) {\r\n\t\tnewVertices.push( new THREE.Vector3( x, y, z ) );\r\n\t}\r\n\r\n\tvar scope = this;\r\n\tvar orderedKey = THREE.GeometryUtils.orderedKey;\r\n\tvar computeEdgeFaces = THREE.GeometryUtils.computeEdgeFaces;\r\n\r\n\tfunction assert() {\r\n\r\n\t\tif (scope.debug && console && console.assert) console.assert.apply(console, arguments);\r\n\r\n\t}\r\n\r\n\tfunction debug() {\r\n\r\n\t\tif (scope.debug) console.log.apply(console, arguments);\r\n\r\n\t}\r\n\r\n\tfunction warn() {\r\n\r\n\t\tif (console)\r\n\t\tconsole.log.apply(console, arguments);\r\n\r\n\t}\r\n\r\n\tfunction f4( a, b, c, d, oldFace, orders, facei ) {\r\n\r\n\t\t// TODO move vertex selection over here!\r\n\r\n\t\tvar newFace = new THREE.Face4( a, b, c, d, null, oldFace.color, oldFace.materialIndex );\r\n\r\n\t\tif (scope.useOldVertexColors) {\r\n\r\n\t\t\tnewFace.vertexColors = []; \r\n\r\n\t\t\tvar color, tmpColor, order;\r\n\r\n\t\t\tfor (var i=0;i<4;i++) {\r\n\r\n\t\t\t\torder = orders[i];\r\n\r\n\t\t\t\tcolor = new THREE.Color(),\r\n\t\t\t\tcolor.setRGB(0,0,0);\r\n\r\n\t\t\t\tfor (var j=0, jl=0; j<order.length;j++) {\r\n\t\t\t\t\ttmpColor = oldFace.vertexColors[order[j]-1];\r\n\t\t\t\t\tcolor.r += tmpColor.r;\r\n\t\t\t\t\tcolor.g += tmpColor.g;\r\n\t\t\t\t\tcolor.b += tmpColor.b;\r\n\t\t\t\t}\r\n\r\n\t\t\t\tcolor.r /= order.length;\r\n\t\t\t\tcolor.g /= order.length;\r\n\t\t\t\tcolor.b /= order.length;\r\n\r\n\t\t\t\tnewFace.vertexColors[i] = color;\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\tnewFaces.push( newFace );\r\n\r\n\t\tif (scope.supportUVs) {\r\n\r\n\t\t\tvar aUv = [\r\n\t\t\t\tgetUV(a, ''),\r\n\t\t\t\tgetUV(b, facei),\r\n\t\t\t\tgetUV(c, facei),\r\n\t\t\t\tgetUV(d, facei)\r\n\t\t\t];\r\n\r\n\t\t\tif (!aUv[0]) debug('a :( ', a+':'+facei);\r\n\t\t\telse if (!aUv[1]) debug('b :( ', b+':'+facei);\r\n\t\t\telse if (!aUv[2]) debug('c :( ', c+':'+facei);\r\n\t\t\telse if (!aUv[3]) debug('d :( ', d+':'+facei);\r\n\t\t\telse \r\n\t\t\t\tnewUVs.push( aUv );\r\n\r\n\t\t}\r\n\t}\r\n\r\n\tvar originalPoints = oldGeometry.vertices;\r\n\tvar originalFaces = oldGeometry.faces;\r\n\tvar originalVerticesLength = originalPoints.length;\r\n\r\n\tvar newPoints = originalPoints.concat(); // New set of vertices to work on\r\n\r\n\tvar facePoints = [], // these are new points on exisiting faces\r\n\t\tedgePoints = {}; // these are new points on exisiting edges\r\n\r\n\tvar sharpEdges = {}, sharpVertices = []; // Mark edges and vertices to prevent smoothening on them\r\n\t// TODO: handle this correctly.\r\n\r\n\tvar uvForVertices = {}; // Stored in {vertex}:{old face} format\r\n\r\n\r\n\tfunction debugCoreStuff() {\r\n\r\n\t\tconsole.log('facePoints', facePoints, 'edgePoints', edgePoints);\r\n\t\tconsole.log('edgeFaceMap', edgeFaceMap, 'vertexEdgeMap', vertexEdgeMap);\r\n\r\n\t}\r\n\r\n\tfunction getUV(vertexNo, oldFaceNo) {\r\n\t\tvar j,jl;\r\n\r\n\t\tvar key = vertexNo+':'+oldFaceNo;\r\n\t\tvar theUV = uvForVertices[key];\r\n\r\n\t\tif (!theUV) {\r\n\t\t\tif (vertexNo>=originalVerticesLength && vertexNo < (originalVerticesLength + originalFaces.length)) {\r\n\t\t\t\tdebug('face pt');\r\n\t\t\t} else {\r\n\t\t\t\tdebug('edge pt');\r\n\t\t\t}\r\n\r\n\t\t\twarn('warning, UV not found for', key);\r\n\r\n\t\t\treturn null;\r\n\t\t}\r\n\r\n\t\treturn theUV;\r\n \r\n\t\t// Original faces -> Vertex Nos. \r\n\t\t// new Facepoint -> Vertex Nos.\r\n\t\t// edge Points\r\n\r\n\t}\r\n\r\n\tfunction addUV(vertexNo, oldFaceNo, value) {\r\n\r\n\t\tvar key = vertexNo+':'+oldFaceNo;\r\n\t\tif (!(key in uvForVertices)) {\r\n\t\t\tuvForVertices[key] = value;\r\n\t\t} else {\r\n\t\t\twarn('dup vertexNo', vertexNo, 'oldFaceNo', oldFaceNo, 'value', value, 'key', key, uvForVertices[key]);\r\n\t\t}\r\n\t}\r\n\r\n\t// Step 1\r\n\t//\tFor each face, add a face point\r\n\t//\tSet each face point to be the centroid of all original points for the respective face.\r\n\t// debug(oldGeometry);\r\n\tvar i, il, j, jl, face;\r\n\r\n\t// For Uvs\r\n\tvar uvs = oldGeometry.faceVertexUvs[0];\r\n\tvar abcd = 'abcd', vertice;\r\n\r\n\tdebug('originalFaces, uvs, originalVerticesLength', originalFaces.length, uvs.length, originalVerticesLength);\r\n\r\n\tif (scope.supportUVs)\r\n\r\n\tfor (i=0, il = uvs.length; i<il; i++ ) {\r\n\r\n\t\tfor (j=0,jl=uvs[i].length;j<jl;j++) {\r\n\r\n\t\t\tvertice = originalFaces[i][abcd.charAt(j)];\r\n\t\t\taddUV(vertice, i, uvs[i][j]);\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\tif (uvs.length == 0) scope.supportUVs = false;\r\n\r\n\t// Additional UVs check, if we index original \r\n\tvar uvCount = 0;\r\n\tfor (var u in uvForVertices) {\r\n\t\tuvCount++;\r\n\t}\r\n\tif (!uvCount) {\r\n\t\tscope.supportUVs = false;\r\n\t\tdebug('no uvs');\r\n\t}\r\n\r\n\tvar avgUv ;\r\n\r\n\tfor (i=0, il = originalFaces.length; i<il ;i++) {\r\n\r\n\t\tface = originalFaces[ i ];\r\n\t\tfacePoints.push( face.centroid );\r\n\t\tnewPoints.push( face.centroid );\r\n\r\n\t\tif (!scope.supportUVs) continue;\r\n\r\n\t\t// Prepare subdivided uv\r\n\r\n\t\tavgUv = new THREE.Vector2();\r\n\r\n\t\tif ( face instanceof THREE.Face3 ) {\r\n\r\n\t\t\tavgUv.x = getUV( face.a, i ).x + getUV( face.b, i ).x + getUV( face.c, i ).x;\r\n\t\t\tavgUv.y = getUV( face.a, i ).y + getUV( face.b, i ).y + getUV( face.c, i ).y;\r\n\t\t\tavgUv.x /= 3;\r\n\t\t\tavgUv.y /= 3;\r\n\r\n\t\t} else if ( face instanceof THREE.Face4 ) {\r\n\r\n\t\t\tavgUv.x = getUV( face.a, i ).x + getUV( face.b, i ).x + getUV( face.c, i ).x + getUV( face.d, i ).x;\r\n\t\t\tavgUv.y = getUV( face.a, i ).y + getUV( face.b, i ).y + getUV( face.c, i ).y + getUV( face.d, i ).y;\r\n\t\t\tavgUv.x /= 4;\r\n\t\t\tavgUv.y /= 4;\r\n\r\n\t\t}\r\n\r\n\t\taddUV(originalVerticesLength + i, '', avgUv);\r\n\r\n\t}\r\n\r\n\t// Step 2\r\n\t//\tFor each edge, add an edge point.\r\n\t//\tSet each edge point to be the average of the two neighbouring face points and its two original endpoints.\r\n\r\n\tvar edgeFaceMap = computeEdgeFaces ( oldGeometry ); // Edge Hash -> Faces Index  eg { edge_key: [face_index, face_index2 ]}\r\n\tvar edge, faceIndexA, faceIndexB, avg;\r\n\r\n\t// debug('edgeFaceMap', edgeFaceMap);\r\n\r\n\tvar edgeCount = 0;\r\n\r\n\tvar edgeVertex, edgeVertexA, edgeVertexB;\r\n\r\n\t////\r\n\r\n\tvar vertexEdgeMap = {}; // Gives edges connecting from each vertex\r\n\tvar vertexFaceMap = {}; // Gives faces connecting from each vertex\r\n\r\n\tfunction addVertexEdgeMap(vertex, edge) {\r\n\r\n\t\tif (vertexEdgeMap[vertex]===undefined) {\r\n\r\n\t\t\tvertexEdgeMap[vertex] = [];\r\n\r\n\t\t}\r\n\r\n\t\tvertexEdgeMap[vertex].push(edge);\r\n\t}\r\n\r\n\tfunction addVertexFaceMap(vertex, face, edge) {\r\n\r\n\t\tif (vertexFaceMap[vertex]===undefined) {\r\n\r\n\t\t\tvertexFaceMap[vertex] = {};\r\n\r\n\t\t}\r\n\r\n\t\tvertexFaceMap[vertex][face] = edge;\r\n\t\t// vertexFaceMap[vertex][face] = null;\r\n\t}\r\n\r\n\t// Prepares vertexEdgeMap and vertexFaceMap\r\n\tfor (i in edgeFaceMap) { // This is for every edge\r\n\t\tedge = edgeFaceMap[i];\r\n\r\n\t\tedgeVertex = i.split('_');\r\n\t\tedgeVertexA = edgeVertex[0];\r\n\t\tedgeVertexB = edgeVertex[1];\r\n\r\n\t\t// Maps an edgeVertex to connecting edges\r\n\t\taddVertexEdgeMap(edgeVertexA, [edgeVertexA, edgeVertexB] );\r\n\t\taddVertexEdgeMap(edgeVertexB, [edgeVertexA, edgeVertexB] );\r\n\r\n\t\tfor (j=0,jl=edge.length;j<jl;j++) {\r\n\r\n\t\t\tface = edge[j];\r\n\t\t\taddVertexFaceMap(edgeVertexA, face, i);\r\n\t\t\taddVertexFaceMap(edgeVertexB, face, i);\r\n\r\n\t\t}\r\n\r\n\t\t// {edge vertex: { face1: edge_key, face2: edge_key.. } }\r\n\r\n\t\t// this thing is fishy right now.\r\n\t\tif (edge.length < 2) {\r\n\r\n\t\t\t// edge is \"sharp\";\r\n\t\t\tsharpEdges[i] = true;\r\n\t\t\tsharpVertices[edgeVertexA] = true;\r\n\t\t\tsharpVertices[edgeVertexB] = true;\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\tfor (i in edgeFaceMap) {\r\n\r\n\t\tedge = edgeFaceMap[i];\r\n\r\n\t\tfaceIndexA = edge[0]; // face index a\r\n\t\tfaceIndexB = edge[1]; // face index b\r\n\r\n\t\tedgeVertex = i.split('_');\r\n\t\tedgeVertexA = edgeVertex[0];\r\n\t\tedgeVertexB = edgeVertex[1];\r\n\r\n\t\tavg = new THREE.Vector3();\r\n\r\n\t\t//debug(i, faceIndexB,facePoints[faceIndexB]);\r\n\r\n\t\tassert(edge.length > 0, 'an edge without faces?!');\r\n\r\n\t\tif (edge.length==1) {\r\n\r\n\t\t\tavg.add( originalPoints[ edgeVertexA ] );\r\n\t\t\tavg.add( originalPoints[ edgeVertexB ] );\r\n\t\t\tavg.multiplyScalar( 0.5 );\r\n\r\n\t\t\tsharpVertices[newPoints.length] = true;\r\n\r\n\t\t} else {\r\n\r\n\t\t\tavg.add( facePoints[ faceIndexA ] );\r\n\t\t\tavg.add( facePoints[ faceIndexB ] );\r\n\r\n\t\t\tavg.add( originalPoints[ edgeVertexA ] );\r\n\t\t\tavg.add( originalPoints[ edgeVertexB ] );\r\n\r\n\t\t\tavg.multiplyScalar( 0.25 );\r\n\r\n\t\t}\r\n\r\n\t\tedgePoints[i] = originalVerticesLength + originalFaces.length + edgeCount;\r\n\r\n\t\tnewPoints.push( avg );\r\n\r\n\t\tedgeCount ++;\r\n\r\n\t\tif (!scope.supportUVs) {\r\n\t\t\tcontinue;\r\n\t\t}\r\n\r\n\t\t// Prepare subdivided uv\r\n\r\n\t\tavgUv = new THREE.Vector2();\r\n\r\n\t\tavgUv.x = getUV(edgeVertexA, faceIndexA).x + getUV(edgeVertexB, faceIndexA).x;\r\n\t\tavgUv.y = getUV(edgeVertexA, faceIndexA).y + getUV(edgeVertexB, faceIndexA).y;\r\n\t\tavgUv.x /= 2;\r\n\t\tavgUv.y /= 2;\r\n\r\n\t\taddUV(edgePoints[i], faceIndexA, avgUv);\r\n\r\n\t\tif (edge.length>=2) {\r\n\t\t\tassert(edge.length == 2, 'did we plan for more than 2 edges?');\r\n\t\t\tavgUv = new THREE.Vector2();\r\n\r\n\t\t\tavgUv.x = getUV(edgeVertexA, faceIndexB).x + getUV(edgeVertexB, faceIndexB).x;\r\n\t\t\tavgUv.y = getUV(edgeVertexA, faceIndexB).y + getUV(edgeVertexB, faceIndexB).y;\r\n\t\t\tavgUv.x /= 2;\r\n\t\t\tavgUv.y /= 2;\r\n\r\n\t\t\taddUV(edgePoints[i], faceIndexB, avgUv);\r\n\t\t}\r\n\r\n\t}\r\n\r\n\tdebug('-- Step 2 done');\r\n\r\n\t// Step 3\r\n\t//\tFor each face point, add an edge for every edge of the face, \r\n\t//\tconnecting the face point to each edge point for the face.\r\n\r\n\tvar facePt, currentVerticeIndex;\r\n\r\n\tvar hashAB, hashBC, hashCD, hashDA, hashCA;\r\n\r\n\tvar abc123 = ['123', '12', '2', '23'];\r\n\tvar bca123 = ['123', '23', '3', '31'];\r\n\tvar cab123 = ['123', '31', '1', '12'];\r\n\tvar abc1234 = ['1234', '12', '2', '23'];\r\n\tvar bcd1234 = ['1234', '23', '3', '34'];\r\n\tvar cda1234 = ['1234', '34', '4', '41'];\r\n\tvar dab1234 = ['1234', '41', '1', '12'];\r\n\r\n\tfor (i=0, il = facePoints.length; i<il ;i++) { // for every face\r\n\t\tfacePt = facePoints[i];\r\n\t\tface = originalFaces[i];\r\n\t\tcurrentVerticeIndex = originalVerticesLength+ i;\r\n\r\n\t\tif ( face instanceof THREE.Face3 ) {\r\n\r\n\t\t\t// create 3 face4s\r\n\r\n\t\t\thashAB = orderedKey( face.a, face.b );\r\n\t\t\thashBC = orderedKey( face.b, face.c );\r\n\t\t\thashCA = orderedKey( face.c, face.a );\r\n\r\n\t\t\tf4( currentVerticeIndex, edgePoints[hashAB], face.b, edgePoints[hashBC], face, abc123, i );\r\n\t\t\tf4( currentVerticeIndex, edgePoints[hashBC], face.c, edgePoints[hashCA], face, bca123, i );\r\n\t\t\tf4( currentVerticeIndex, edgePoints[hashCA], face.a, edgePoints[hashAB], face, cab123, i );\r\n\r\n\t\t} else if ( face instanceof THREE.Face4 ) {\r\n\r\n\t\t\t// create 4 face4s\r\n\r\n\t\t\thashAB = orderedKey( face.a, face.b );\r\n\t\t\thashBC = orderedKey( face.b, face.c );\r\n\t\t\thashCD = orderedKey( face.c, face.d );\r\n\t\t\thashDA = orderedKey( face.d, face.a );\r\n\r\n\t\t\tf4( currentVerticeIndex, edgePoints[hashAB], face.b, edgePoints[hashBC], face, abc1234, i );\r\n\t\t\tf4( currentVerticeIndex, edgePoints[hashBC], face.c, edgePoints[hashCD], face, bcd1234, i );\r\n\t\t\tf4( currentVerticeIndex, edgePoints[hashCD], face.d, edgePoints[hashDA], face, cda1234, i );\r\n\t\t\tf4( currentVerticeIndex, edgePoints[hashDA], face.a, edgePoints[hashAB], face, dab1234, i );\r\n\r\n\r\n\t\t} else {\r\n\r\n\t\t\tdebug('face should be a face!', face);\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\tnewVertices = newPoints;\r\n\r\n\t// Step 4\r\n\r\n\t//\tFor each original point P, \r\n\t//\t\ttake the average F of all n face points for faces touching P, \r\n\t//\t\tand take the average R of all n edge midpoints for edges touching P, \r\n\t//\t\twhere each edge midpoint is the average of its two endpoint vertices. \r\n\t//\tMove each original point to the point\r\n\r\n\r\n\tvar F = new THREE.Vector3();\r\n\tvar R = new THREE.Vector3();\r\n\r\n\tvar n;\r\n\tfor (i=0, il = originalPoints.length; i<il; i++) {\r\n\t\t// (F + 2R + (n-3)P) / n\r\n\r\n\t\tif (vertexEdgeMap[i]===undefined) continue;\r\n\r\n\t\tF.set(0,0,0);\r\n\t\tR.set(0,0,0);\r\n\t\tvar newPos =  new THREE.Vector3(0,0,0);\r\n\r\n\t\tvar f = 0; // this counts number of faces, original vertex is connected to (also known as valance?)\r\n\t\tfor (j in vertexFaceMap[i]) {\r\n\t\t\tF.add(facePoints[j]);\r\n\t\t\tf++;\r\n\t\t}\r\n\r\n\t\tvar sharpEdgeCount = 0;\r\n\r\n\t\tn = vertexEdgeMap[i].length; // given a vertex, return its connecting edges\r\n\r\n\t\t// Are we on the border?\r\n\t\tvar boundary_case = f != n;\r\n\r\n\t\t// if (boundary_case) {\r\n\t\t// \tconsole.error('moo', 'o', i, 'faces touched', f, 'edges',  n, n == 2);\r\n\t\t// }\r\n\r\n\t\tfor (j=0;j<n;j++) {\r\n\t\t\tif (\r\n\t\t\t\tsharpEdges[\r\n\t\t\t\t\torderedKey(vertexEdgeMap[i][j][0],vertexEdgeMap[i][j][1])\r\n\t\t\t\t]) {\r\n\t\t\t\t\tsharpEdgeCount++;\r\n\t\t\t\t}\r\n\t\t}\r\n\r\n\t\t// if ( sharpEdgeCount==2 ) {\r\n\t\t// \tcontinue;\r\n\t\t// \t// Do not move vertex if there's 2 connecting sharp edges.\r\n\t\t// }\r\n\r\n\t\t/*\r\n\t\tif (sharpEdgeCount>2) {\r\n\t\t\t// TODO\r\n\t\t}\r\n\t\t*/\r\n\r\n\t\tF.divideScalar(f);\r\n\r\n\r\n\t\tvar boundary_edges = 0;\r\n\r\n\t\tif (boundary_case) {\r\n\r\n\t\t\tvar bb_edge;\r\n\t\t\tfor (j=0; j<n;j++) {\r\n\t\t\t\tedge = vertexEdgeMap[i][j];\r\n\t\t\t\tbb_edge = edgeFaceMap[orderedKey(edge[0], edge[1])].length == 1\r\n\t\t\t\tif (bb_edge) {\r\n\t\t\t\t\tvar midPt = originalPoints[edge[0]].clone().add(originalPoints[edge[1]]).divideScalar(2);\r\n\t\t\t\t\tR.add(midPt);\r\n\t\t\t\t\tboundary_edges++;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\tR.divideScalar(4);\r\n\t\t\t// console.log(j + ' --- ' + n + ' --- ' + boundary_edges);\r\n\t\t\tassert(boundary_edges == 2, 'should have only 2 boundary edges');\r\n\r\n\t\t} else {\r\n\t\t\tfor (j=0; j<n;j++) {\r\n\t\t\t\tedge = vertexEdgeMap[i][j];\r\n\t\t\t\tvar midPt = originalPoints[edge[0]].clone().add(originalPoints[edge[1]]).divideScalar(2);\r\n\t\t\t\tR.add(midPt);\r\n\t\t\t}\r\n\r\n\t\t\tR.divideScalar(n);\r\n\t\t}\r\n\r\n\t\t// Sum the formula\r\n\t\tnewPos.add(originalPoints[i]);\r\n\r\n\r\n\t\tif (boundary_case) {\r\n\r\n\t\t\tnewPos.divideScalar(2);\r\n\t\t\tnewPos.add(R);\r\n\r\n\t\t} else {\r\n\r\n\t\t\tnewPos.multiplyScalar(n - 3);\r\n\r\n\t\t\tnewPos.add(F);\r\n\t\t\tnewPos.add(R.multiplyScalar(2));\r\n\t\t\tnewPos.divideScalar(n);\r\n\r\n\t\t}\r\n\r\n\t\tnewVertices[i] = newPos;\r\n\r\n\t}\r\n\r\n\tvar newGeometry = oldGeometry; // Let's pretend the old geometry is now new :P\r\n\r\n\tnewGeometry.vertices = newVertices;\r\n\tnewGeometry.faces = newFaces;\r\n\tnewGeometry.faceVertexUvs[ 0 ] = newUVs;\r\n\r\n\tdelete newGeometry.__tmpVertices; // makes __tmpVertices undefined :P\r\n\r\n\tnewGeometry.computeCentroids();\r\n\tnewGeometry.computeFaceNormals();\r\n\tnewGeometry.computeVertexNormals();\r\n\r\n};\r\n","// tween.js r5 - http://github.com/sole/tween.js\r\nvar TWEEN = TWEEN || function() {\r\n\tvar a, e, c = 60, b = false, h = [];\r\n\treturn {\r\n\t\tsetFPS : function(f) {\r\n\t\t\tc = f || 60\r\n\t\t},\r\n\t\tstart : function(f) {\r\n\t\t\targuments.length != 0 && this.setFPS(f);\r\n\t\t\te = setInterval(this.update, 1E3 / c)\r\n\t\t},\r\n\t\tstop : function() {\r\n\t\t\tclearInterval(e)\r\n\t\t},\r\n\t\tsetAutostart : function(f) {\r\n\t\t\t(b = f) && !e && this.start()\r\n\t\t},\r\n\t\tadd : function(f) {\r\n\t\t\th.push(f);\r\n\t\t\tb && !e && this.start()\r\n\t\t},\r\n\t\tgetAll : function() {\r\n\t\t\treturn h\r\n\t\t},\r\n\t\tremoveAll : function() {\r\n\t\t\th = []\r\n\t\t},\r\n\t\tremove : function(f) {\r\n\t\t\ta = h.indexOf(f);\r\n\t\t\ta !== -1 && h.splice(a, 1)\r\n\t\t},\r\n\t\tupdate : function(f) {\r\n\t\t\ta = 0;\r\n\t\t\tnum_tweens = h.length;\r\n\t\t\tfor (f = f || Date.now(); a < num_tweens;)\r\n\t\t\t\tif (h[a].update(f))\r\n\t\t\t\t\ta++;\r\n\t\t\t\telse {\r\n\t\t\t\t\th.splice(a, 1);\r\n\t\t\t\t\tnum_tweens--\r\n\t\t\t\t}\r\n\t\t\tnum_tweens == 0 && b == true && this.stop()\r\n\t\t}\r\n\t}\r\n}();\r\nTWEEN.Tween = function(a) {\r\n\tvar e = {}, c = {}, b = {}, h = 1E3, f = 0, j = null, n = TWEEN.Easing.Linear.EaseNone, k = null, l = null, m = null;\r\n\tthis.to = function(d, g) {\r\n\t\tif (g !== null)\r\n\t\t\th = g;\r\n\t\tfor ( var i in d)\r\n\t\t\tif (a[i] !== null)\r\n\t\t\t\tb[i] = d[i];\r\n\t\treturn this\r\n\t};\r\n\tthis.start = function(d) {\r\n\t\tTWEEN.add(this);\r\n\t\tj = d ? d + f : Date.now() + f;\r\n\t\tfor ( var g in b)\r\n\t\t\tif (a[g] !== null) {\r\n\t\t\t\te[g] = a[g];\r\n\t\t\t\tc[g] = b[g] - a[g]\r\n\t\t\t}\r\n\t\treturn this\r\n\t};\r\n\tthis.stop = function() {\r\n\t\tTWEEN.remove(this);\r\n\t\treturn this\r\n\t};\r\n\tthis.delay = function(d) {\r\n\t\tf = d;\r\n\t\treturn this\r\n\t};\r\n\tthis.easing = function(d) {\r\n\t\tn = d;\r\n\t\treturn this\r\n\t};\r\n\tthis.chain = function(d) {\r\n\t\tk = d\r\n\t};\r\n\tthis.onUpdate = function(d) {\r\n\t\tl = d;\r\n\t\treturn this\r\n\t};\r\n\tthis.onComplete = function(d) {\r\n\t\tm = function() {\r\n\t\t\tvar $this=this;\r\n\t\t\tsetTimeout(function() {\r\n\t\t\t\td.call($this);\t\t\t\t\r\n\t\t\t},0);\r\n\t\t}\r\n\t\treturn this\r\n\t};\r\n\tthis.update = function(d) {\r\n\t\tvar g, i;\r\n\t\tif (d < j)\r\n\t\t\treturn true;\r\n\t\td = (d - j) / h;\r\n\t\td = d > 1 ? 1 : d;\r\n\t\ti = n(d);\r\n\t\tfor (g in c)\r\n\t\t\ta[g] = e[g] + c[g] * i;\r\n\t\tl !== null && l.call(a, i);\r\n\t\tif (d == 1) {\r\n\t\t\tm !== null && m.call(a);\r\n\t\t\tk !== null && k.start();\r\n\t\t\treturn false\r\n\t\t}\r\n\t\treturn true\r\n\t}\r\n};\r\nTWEEN.Easing = {\r\n\tLinear : {},\r\n\tQuadratic : {},\r\n\tCubic : {},\r\n\tQuartic : {},\r\n\tQuintic : {},\r\n\tSinusoidal : {},\r\n\tExponential : {},\r\n\tCircular : {},\r\n\tElastic : {},\r\n\tBack : {},\r\n\tBounce : {}\r\n};\r\nTWEEN.Easing.Linear.EaseNone = function(a) {\r\n\treturn a\r\n};\r\nTWEEN.Easing.Quadratic.EaseIn = function(a) {\r\n\treturn a * a\r\n};\r\nTWEEN.Easing.Quadratic.EaseOut = function(a) {\r\n\treturn -a * (a - 2)\r\n};\r\nTWEEN.Easing.Quadratic.EaseInOut = function(a) {\r\n\tif ((a *= 2) < 1)\r\n\t\treturn 0.5 * a * a;\r\n\treturn -0.5 * (--a * (a - 2) - 1)\r\n};\r\nTWEEN.Easing.Cubic.EaseIn = function(a) {\r\n\treturn a * a * a\r\n};\r\nTWEEN.Easing.Cubic.EaseOut = function(a) {\r\n\treturn --a * a * a + 1\r\n};\r\nTWEEN.Easing.Cubic.EaseInOut = function(a) {\r\n\tif ((a *= 2) < 1)\r\n\t\treturn 0.5 * a * a * a;\r\n\treturn 0.5 * ((a -= 2) * a * a + 2)\r\n};\r\nTWEEN.Easing.Quartic.EaseIn = function(a) {\r\n\treturn a * a * a * a\r\n};\r\nTWEEN.Easing.Quartic.EaseOut = function(a) {\r\n\treturn -(--a * a * a * a - 1)\r\n};\r\nTWEEN.Easing.Quartic.EaseInOut = function(a) {\r\n\tif ((a *= 2) < 1)\r\n\t\treturn 0.5 * a * a * a * a;\r\n\treturn -0.5 * ((a -= 2) * a * a * a - 2)\r\n};\r\nTWEEN.Easing.Quintic.EaseIn = function(a) {\r\n\treturn a * a * a * a * a\r\n};\r\nTWEEN.Easing.Quintic.EaseOut = function(a) {\r\n\treturn (a -= 1) * a * a * a * a + 1\r\n};\r\nTWEEN.Easing.Quintic.EaseInOut = function(a) {\r\n\tif ((a *= 2) < 1)\r\n\t\treturn 0.5 * a * a * a * a * a;\r\n\treturn 0.5 * ((a -= 2) * a * a * a * a + 2)\r\n};\r\nTWEEN.Easing.Sinusoidal.EaseIn = function(a) {\r\n\treturn -Math.cos(a * Math.PI / 2) + 1\r\n};\r\nTWEEN.Easing.Sinusoidal.EaseOut = function(a) {\r\n\treturn Math.sin(a * Math.PI / 2)\r\n};\r\nTWEEN.Easing.Sinusoidal.EaseInOut = function(a) {\r\n\treturn -0.5 * (Math.cos(Math.PI * a) - 1)\r\n};\r\nTWEEN.Easing.Exponential.EaseIn = function(a) {\r\n\treturn a == 0 ? 0 : Math.pow(2, 10 * (a - 1))\r\n};\r\nTWEEN.Easing.Exponential.EaseOut = function(a) {\r\n\treturn a == 1 ? 1 : -Math.pow(2, -10 * a) + 1\r\n};\r\nTWEEN.Easing.Exponential.EaseInOut = function(a) {\r\n\tif (a == 0)\r\n\t\treturn 0;\r\n\tif (a == 1)\r\n\t\treturn 1;\r\n\tif ((a *= 2) < 1)\r\n\t\treturn 0.5 * Math.pow(2, 10 * (a - 1));\r\n\treturn 0.5 * (-Math.pow(2, -10 * (a - 1)) + 2)\r\n};\r\nTWEEN.Easing.Circular.EaseIn = function(a) {\r\n\treturn -(Math.sqrt(1 - a * a) - 1)\r\n};\r\nTWEEN.Easing.Circular.EaseOut = function(a) {\r\n\treturn Math.sqrt(1 - --a * a)\r\n};\r\nTWEEN.Easing.Circular.EaseInOut = function(a) {\r\n\tif ((a /= 0.5) < 1)\r\n\t\treturn -0.5 * (Math.sqrt(1 - a * a) - 1);\r\n\treturn 0.5 * (Math.sqrt(1 - (a -= 2) * a) + 1)\r\n};\r\nTWEEN.Easing.Elastic.EaseIn = function(a) {\r\n\tvar e, c = 0.1, b = 0.4;\r\n\tif (a == 0)\r\n\t\treturn 0;\r\n\tif (a == 1)\r\n\t\treturn 1;\r\n\tb || (b = 0.3);\r\n\tif (!c || c < 1) {\r\n\t\tc = 1;\r\n\t\te = b / 4\r\n\t} else\r\n\t\te = b / (2 * Math.PI) * Math.asin(1 / c);\r\n\treturn -(c * Math.pow(2, 10 * (a -= 1)) * Math.sin((a - e) * 2 * Math.PI\r\n\t\t\t/ b))\r\n};\r\nTWEEN.Easing.Elastic.EaseOut = function(a) {\r\n\tvar e, c = 0.1, b = 0.4;\r\n\tif (a == 0)\r\n\t\treturn 0;\r\n\tif (a == 1)\r\n\t\treturn 1;\r\n\tb || (b = 0.3);\r\n\tif (!c || c < 1) {\r\n\t\tc = 1;\r\n\t\te = b / 4\r\n\t} else\r\n\t\te = b / (2 * Math.PI) * Math.asin(1 / c);\r\n\treturn c * Math.pow(2, -10 * a) * Math.sin((a - e) * 2 * Math.PI / b) + 1\r\n};\r\nTWEEN.Easing.Elastic.EaseInOut = function(a) {\r\n\tvar e, c = 0.1, b = 0.4;\r\n\tif (a == 0)\r\n\t\treturn 0;\r\n\tif (a == 1)\r\n\t\treturn 1;\r\n\tb || (b = 0.3);\r\n\tif (!c || c < 1) {\r\n\t\tc = 1;\r\n\t\te = b / 4\r\n\t} else\r\n\t\te = b / (2 * Math.PI) * Math.asin(1 / c);\r\n\tif ((a *= 2) < 1)\r\n\t\treturn -0.5 * c * Math.pow(2, 10 * (a -= 1))\r\n\t\t\t\t* Math.sin((a - e) * 2 * Math.PI / b);\r\n\treturn c * Math.pow(2, -10 * (a -= 1))\r\n\t\t\t* Math.sin((a - e) * 2 * Math.PI / b) * 0.5 + 1\r\n};\r\nTWEEN.Easing.Back.EaseIn = function(a) {\r\n\treturn a * a * (2.70158 * a - 1.70158)\r\n};\r\nTWEEN.Easing.Back.EaseOut = function(a) {\r\n\treturn (a -= 1) * a * (2.70158 * a + 1.70158) + 1\r\n};\r\nTWEEN.Easing.Back.EaseInOut = function(a) {\r\n\tif ((a *= 2) < 1)\r\n\t\treturn 0.5 * a * a * (3.5949095 * a - 2.5949095);\r\n\treturn 0.5 * ((a -= 2) * a * (3.5949095 * a + 2.5949095) + 2)\r\n};\r\nTWEEN.Easing.Bounce.EaseIn = function(a) {\r\n\treturn 1 - TWEEN.Easing.Bounce.EaseOut(1 - a)\r\n};\r\nTWEEN.Easing.Bounce.EaseOut = function(a) {\r\n\treturn (a /= 1) < 1 / 2.75 ? 7.5625 * a * a : a < 2 / 2.75 ? 7.5625\r\n\t\t\t* (a -= 1.5 / 2.75) * a + 0.75 : a < 2.5 / 2.75 ? 7.5625\r\n\t\t\t* (a -= 2.25 / 2.75) * a + 0.9375 : 7.5625 * (a -= 2.625 / 2.75)\r\n\t\t\t* a + 0.984375\r\n};\r\nTWEEN.Easing.Bounce.EaseInOut = function(a) {\r\n\tif (a < 0.5)\r\n\t\treturn TWEEN.Easing.Bounce.EaseIn(a * 2) * 0.5;\r\n\treturn TWEEN.Easing.Bounce.EaseOut(a * 2 - 1) * 0.5 + 0.5\r\n};\r\n","(function() {\r\n\t\r\n\tvar _Tween=TWEEN.Tween;\r\n\t\r\n\tTWEEN.Tween = function(object) {\r\n\t\tvar $this=this;\r\n\t\t$.extend(this,new _Tween(object));\r\n\t\tvar _onComplete=this.onComplete;\r\n        this.onComplete = function ( callback ) {\r\n            _onComplete.call($this,function() {\r\n            \tsetTimeout(function() {\r\n            \t\tcallback.call($this);\r\n            \t},0);\r\n            });\r\n            return this;\r\n        };\r\n\t}\r\n\t\r\n\tTWEEN.Easing.Linear.EaseNone = TWEEN.Easing.Linear.EaseNone || TWEEN.Easing.Linear.None; \r\n\tTWEEN.Easing.Quadratic.EaseIn = TWEEN.Easing.Quadratic.EaseIn || TWEEN.Easing.Quadratic.In;\r\n\tTWEEN.Easing.Quadratic.EaseOut = TWEEN.Easing.Quadratic.EaseOut || TWEEN.Easing.Quadratic.Out;\r\n\tTWEEN.Easing.Quadratic.EaseInOut = TWEEN.Easing.Quadratic.EaseInOut || TWEEN.Easing.Quadratic.InOut;\r\n\tTWEEN.Easing.Cubic.EaseIn = TWEEN.Easing.Cubic.EaseIn || TWEEN.Easing.Cubic.In; \r\n\tTWEEN.Easing.Cubic.EaseOut = TWEEN.Easing.Cubic.EaseOut || TWEEN.Easing.Cubic.Out;\r\n\tTWEEN.Easing.Cubic.EaseInOut = TWEEN.Easing.Cubic.EaseInOut || TWEEN.Easing.Cubic.InOut;\r\n\tTWEEN.Easing.Quartic.EaseIn = TWEEN.Easing.Quartic.EaseIn || TWEEN.Easing.Quartic.In;\r\n\tTWEEN.Easing.Quartic.EaseOut = TWEEN.Easing.Quartic.EaseOut || TWEEN.Easing.Quartic.Out;\r\n\tTWEEN.Easing.Quartic.EaseInOut = TWEEN.Easing.Quartic.EaseInOut || TWEEN.Easing.Quartic.InOut;\r\n\tTWEEN.Easing.Quintic.EaseIn = TWEEN.Easing.Quintic.EaseIn || TWEEN.Easing.Quintic.In;\r\n\tTWEEN.Easing.Quintic.EaseOut = TWEEN.Easing.Quintic.EaseOut || TWEEN.Easing.Quintic.Out; \r\n\tTWEEN.Easing.Quintic.EaseInOut = TWEEN.Easing.Quintic.EaseInOut || TWEEN.Easing.Quintic.InOut;\r\n\tTWEEN.Easing.Sinusoidal.EaseIn = TWEEN.Easing.Sinusoidal.EaseIn || TWEEN.Easing.Sinusoidal.In;\r\n\tTWEEN.Easing.Sinusoidal.EaseOut = TWEEN.Easing.Sinusoidal.EaseOut || TWEEN.Easing.Sinusoidal.Out;\r\n\tTWEEN.Easing.Sinusoidal.EaseInOut = TWEEN.Easing.Sinusoidal.EaseInOut || TWEEN.Easing.Sinusoidal.InOut;\r\n\tTWEEN.Easing.Exponential.EaseIn = TWEEN.Easing.Exponential.EaseIn || TWEEN.Easing.Exponential.In;\r\n\tTWEEN.Easing.Exponential.EaseOut = TWEEN.Easing.Exponential.EaseOut || TWEEN.Easing.Exponential.Out;\r\n\tTWEEN.Easing.Exponential.EaseInOut = TWEEN.Easing.Exponential.EaseInOut || TWEEN.Easing.Exponential.InOut;\r\n\tTWEEN.Easing.Circular.EaseIn = TWEEN.Easing.Circular.EaseIn || TWEEN.Easing.Circular.In;\r\n\tTWEEN.Easing.Circular.EaseOut = TWEEN.Easing.Circular.EaseOut || TWEEN.Easing.Circular.Out;\r\n\tTWEEN.Easing.Circular.EaseInOut = TWEEN.Easing.Circular.EaseInOut || TWEEN.Easing.Circular.InOut;\r\n\tTWEEN.Easing.Elastic.EaseIn = TWEEN.Easing.Elastic.EaseIn || TWEEN.Easing.Elastic.In;\r\n\tTWEEN.Easing.Elastic.EaseOut = TWEEN.Easing.Elastic.EaseOut || TWEEN.Easing.Elastic.Out;\r\n\tTWEEN.Easing.Elastic.EaseInOut = TWEEN.Easing.Elastic.EaseInOut || TWEEN.Easing.Elastic.InOut;\r\n\tTWEEN.Easing.Back.EaseIn = TWEEN.Easing.Back.EaseIn || TWEEN.Easing.Back.In;\r\n\tTWEEN.Easing.Back.EaseOut = TWEEN.Easing.Back.EaseOut || TWEEN.Easing.Back.Out;\r\n\tTWEEN.Easing.Back.EaseInOut = TWEEN.Easing.Back.EaseInOut || TWEEN.Easing.Back.InOut;\r\n\tTWEEN.Easing.Bounce.EaseIn = TWEEN.Easing.Bounce.EaseIn || TWEEN.Easing.Bounce.In;\r\n\tTWEEN.Easing.Bounce.EaseOut = TWEEN.Easing.Bounce.EaseOut || TWEEN.Easing.Bounce.Out;\r\n\tTWEEN.Easing.Bounce.EaseInOut = TWEEN.Easing.Bounce.EaseInOut || TWEEN.Easing.Bounce.InOut;\r\n\r\n})();","/**\r\n * @author qiao / https://github.com/qiao\r\n * @author mrdoob / http://mrdoob.com\r\n * @author alteredq / http://alteredqualia.com/\r\n * @author WestLangley / http://github.com/WestLangley\r\n * @author erich666 / http://erichaines.com\r\n */\r\n/*global THREE, console */\r\n\r\n// This set of controls performs orbiting, dollying (zooming), and panning. It maintains\r\n// the \"up\" direction as +Y, unlike the TrackballControls. Touch on tablet and phones is\r\n// supported.\r\n//\r\n//    Orbit - left mouse / touch: one finger move\r\n//    Zoom - middle mouse, or mousewheel / touch: two finger spread or squish\r\n//    Pan - right mouse, or arrow keys / touch: three finter swipe\r\n//\r\n// This is a drop-in replacement for (most) TrackballControls used in examples.\r\n// That is, include this js file and wherever you see:\r\n//    \tcontrols = new THREE.TrackballControls( camera );\r\n//      controls.target.z = 150;\r\n// Simple substitute \"OrbitControls\" and the control should work as-is.\r\n\r\nTHREE.OrbitControls = function ( camera, object, domElement ) {\r\n\r\n\tthis.object = object;\r\n    this.camera = camera;\r\n    \r\n\tthis.domElement = ( domElement !== undefined ) ? domElement : document;\r\n\r\n\t// API\r\n\r\n\t// Set to false to disable this control\r\n\tthis.enabled = true;\r\n\r\n\t// \"target\" sets the location of focus, where the control orbits around\r\n\t// and where it pans with respect to.\r\n\tthis.camTarget = new THREE.Vector3();\r\n\t// center is old, deprecated; use \"camTarget\" instead\r\n\tthis.center = this.camTarget;\r\n\r\n\t// This option actually enables dollying in and out; left as \"zoom\" for\r\n\t// backwards compatibility\r\n\tthis.noZoom = false;\r\n\tthis.zoomSpeed = 1.0;\r\n\t// Limits to how far you can dolly in and out\r\n\tthis.minDistance = 0;\r\n\tthis.maxDistance = Infinity;\r\n\r\n\t// Set to true to disable this control\r\n\tthis.noRotate = false;\r\n\tthis.rotateSpeed = 1.0;\r\n\r\n\t// Set to true to disable this control\r\n\tthis.noPan = false;\r\n\tthis.keyPanSpeed = 7.0;\t// pixels moved per arrow key push\r\n\r\n\t// Set to true to automatically rotate around the target\r\n\tthis.autoRotate = false;\r\n\tthis.autoRotateSpeed = 2.0; // 30 seconds per round when fps is 60\r\n\r\n\t// How far you can orbit vertically, upper and lower limits.\r\n\t// Range is 0 to Math.PI radians.\r\n\tthis.minPolarAngle = 0; // radians\r\n\tthis.maxPolarAngle = Math.PI; // radians\r\n\r\n\t// Set to true to disable use of the keys\r\n\tthis.noKeys = false;\r\n\t// The four arrow keys\r\n\tthis.keys = { LEFT: 37, UP: 38, RIGHT: 39, BOTTOM: 40 };\r\n\t\r\n\t// Jocly specific\r\n\tthis.animControl = null;\r\n\tthis.enableDrag = true;\r\n\tthis.targetBounds = [3,3,3];\r\n\r\n\t////////////\r\n\t// internals\r\n\r\n\tvar scope = this;\r\n\r\n\tvar EPS = 0.000001;\r\n\r\n\tvar rotateStart = new THREE.Vector2();\r\n\tvar rotateEnd = new THREE.Vector2();\r\n\tvar rotateDelta = new THREE.Vector2();\r\n\r\n\tvar panStart = new THREE.Vector2();\r\n\tvar panEnd = new THREE.Vector2();\r\n\tvar panDelta = new THREE.Vector2();\r\n\r\n\tvar dollyStart = new THREE.Vector2();\r\n\tvar dollyEnd = new THREE.Vector2();\r\n\tvar dollyDelta = new THREE.Vector2();\r\n\r\n\tvar phiDelta = 0;\r\n\tvar thetaDelta = 0;\r\n\tvar scale = 1;\r\n\tvar pan = new THREE.Vector3();\r\n\r\n\tvar lastPosition = new THREE.Vector3();\r\n\r\n\tvar STATE = { NONE : -1, ROTATE : 0, DOLLY : 1, PAN : 2, TOUCH_ROTATE : 3, TOUCH_DOLLY : 4, TOUCH_PAN : 5 };\r\n\tvar state = STATE.NONE;\r\n\r\n\t// events\r\n\r\n\tvar changeEvent = { type: 'change' };\r\n\r\n\r\n\tthis.rotateLeft = function ( angle ) {\r\n\r\n\t\tif ( angle === undefined ) {\r\n\r\n\t\t\tangle = getAutoRotationAngle();\r\n\r\n\t\t}\r\n\r\n\t\tthetaDelta -= angle;\r\n\r\n\t};\r\n\r\n\tthis.rotateUp = function ( angle ) {\r\n\r\n\t\tif ( angle === undefined ) {\r\n\r\n\t\t\tangle = getAutoRotationAngle();\r\n\r\n\t\t}\r\n\r\n\t\tphiDelta -= angle;\r\n\r\n\t};\r\n\r\n\t// pass in distance in world space to move left\r\n\tthis.panLeft = function ( distance ) {\r\n\r\n\t\tvar panOffset = new THREE.Vector3();\r\n\t\tvar te = this.object.matrix.elements;\r\n\t\t// get X column of matrix\r\n\t\tpanOffset.set( te[0], te[1], te[2] );\r\n\t\tpanOffset.multiplyScalar(-distance);\r\n\t\t\r\n\t\tpan.add( panOffset );\r\n\r\n\t};\r\n\r\n\t// pass in distance in world space to move up\r\n\tthis.panUp = function ( distance ) {\r\n\r\n\t\tvar panOffset = new THREE.Vector3();\r\n\t\tvar te = this.object.matrix.elements;\r\n\t\t// get Y column of matrix\r\n\t\tpanOffset.set( te[4], te[5], te[6] );\r\n\t\tpanOffset.multiplyScalar(distance);\r\n\t\t\r\n\t\tpan.add( panOffset );\r\n\t};\r\n\t\r\n\t// main entry point; pass in Vector2 of change desired in pixel space,\r\n\t// right and down are positive\r\n\tthis.pan = function ( delta ) {\r\n\r\n\t\tvar element = scope.domElement === document ? scope.domElement.body : scope.domElement;\r\n\r\n\t\tif ( scope.camera.fov !== undefined ) {\r\n\r\n\t\t\t// perspective\r\n\t\t\tvar position = scope.object.position;\r\n\t\t\tvar offset = position.clone().sub( scope.camTarget );\r\n\t\t\tvar targetDistance = offset.length();\r\n\r\n\t\t\t// half of the fov is center to top of screen\r\n\t\t\ttargetDistance *= Math.tan( (scope.camera.fov/2) * Math.PI / 180.0 );\r\n\t\t\t// we actually don't use screenWidth, since perspective camera is fixed to screen height\r\n\t\t\tscope.panLeft( 2 * delta.x * targetDistance / element.clientHeight );\r\n\t\t\tscope.panUp( 2 * delta.y * targetDistance / element.clientHeight );\r\n\r\n\t\t} else if ( scope.object.top !== undefined ) {\r\n\r\n\t\t\t// orthographic\r\n\t\t\tscope.panLeft( delta.x * (scope.object.right - scope.object.left) / element.clientWidth );\r\n\t\t\tscope.panUp( delta.y * (scope.object.top - scope.object.bottom) / element.clientHeight );\r\n\r\n\t\t} else {\r\n\r\n\t\t\t// camera neither orthographic or perspective - warn user\r\n\t\t\tconsole.warn( 'WARNING: OrbitControls.js encountered an unknown camera type - pan disabled.' );\r\n\r\n\t\t}\r\n\r\n\t};\r\n\r\n\tthis.dollyIn = function ( dollyScale ) {\r\n\r\n\t\tif ( dollyScale === undefined ) {\r\n\r\n\t\t\tdollyScale = getZoomScale();\r\n\r\n\t\t}\r\n\r\n\t\tscale /= dollyScale;\r\n\r\n\t};\r\n\r\n\tthis.dollyOut = function ( dollyScale ) {\r\n\r\n\t\tif ( dollyScale === undefined ) {\r\n\r\n\t\t\tdollyScale = getZoomScale();\r\n\r\n\t\t}\r\n\r\n\t\tscale *= dollyScale;\r\n\r\n\t};\r\n\r\n\tthis.update = function () {\r\n\r\n\t\tvar position = this.object.position;\r\n\t\tvar offset = position.clone().sub( this.camTarget );\r\n\r\n\t\t// angle from z-axis around y-axis\r\n\r\n\t\tvar theta = Math.atan2( offset.x, offset.z );\r\n\r\n\t\t// angle from y-axis\r\n\r\n\t\tvar phi = Math.atan2( Math.sqrt( offset.x * offset.x + offset.z * offset.z ), offset.y );\r\n\r\n\t\tif ( this.autoRotate ) {\r\n\r\n\t\t\tthis.rotateLeft( getAutoRotationAngle() );\r\n\r\n\t\t}\r\n\r\n\t\ttheta += thetaDelta;\r\n\t\tphi += phiDelta;\r\n\r\n\t\t// restrict phi to be between desired limits\r\n\t\tphi = Math.max( this.minPolarAngle, Math.min( this.maxPolarAngle, phi ) );\r\n\r\n\t\t// restrict phi to be betwee EPS and PI-EPS\r\n\t\tphi = Math.max( EPS, Math.min( Math.PI - EPS, phi ) );\r\n\r\n\t\tvar radius = offset.length() * scale;\r\n\r\n\t\t// restrict radius to be between desired limits\r\n\t\tradius = Math.max( this.minDistance, Math.min( this.maxDistance, radius ) );\r\n\t\t\r\n\t\t//console.log(\"radius\",radius,\"phi\",phi,\"theta\",theta);\r\n\t\t\r\n\t\t// move target to panned location\r\n\t\tthis.camTarget.add( pan );\r\n\r\n\t\toffset.x = radius * Math.sin( phi ) * Math.sin( theta );\r\n\t\toffset.y = radius * Math.cos( phi );\r\n\t\toffset.z = radius * Math.sin( phi ) * Math.cos( theta );\r\n\t\t\r\n\t\tif(this.camTarget.x<-this.targetBounds[0])\r\n\t\t\tthis.camTarget.setX(-this.targetBounds[0]);\r\n\t\tif(this.camTarget.x>this.targetBounds[0])\r\n\t\t\tthis.camTarget.setX(this.targetBounds[0]);\r\n\t\tif(this.camTarget.y<-this.targetBounds[1])\r\n\t\t\tthis.camTarget.setY(-this.targetBounds[1]);\r\n\t\tif(this.camTarget.y>this.targetBounds[1])\r\n\t\t\tthis.camTarget.setY(this.targetBounds[1]);\r\n\t\tif(this.camTarget.z<-this.targetBounds[2])\r\n\t\t\tthis.camTarget.setZ(-this.targetBounds[2]);\r\n\t\tif(this.camTarget.z>this.targetBounds[2])\r\n\t\t\tthis.camTarget.setZ(this.targetBounds[2]);\r\n\r\n\t\tposition.copy( this.camTarget ).add( offset );\r\n\r\n\t\t// apparently camera.lookAt is based on the camera relative position\r\n        // in our case, where the camera is attached to an object, we need\r\n        // to temporarily move the camera to this object for lookAt to work\r\n        // properly\r\n        var camPos = new THREE.Vector3();\r\n        camPos.copy(this.camera.position);\r\n        this.camera.position.copy(this.object.position);\r\n\t\tthis.camera.lookAt( this.camTarget );\r\n        this.camera.position.copy(camPos);\r\n\r\n\t\tthetaDelta = 0;\r\n\t\tphiDelta = 0;\r\n\t\tscale = 1;\r\n\t\tpan.set(0,0,0);\r\n\r\n\t\tif ( lastPosition.distanceTo( this.object.position ) > 0 ) {\r\n\r\n\t\t\tif(typeof this.dispatchEvent==\"function\")\r\n\t\t\t\tthis.dispatchEvent( changeEvent );\r\n\r\n\t\t\tlastPosition.copy( this.object.position );\r\n\t\t}\r\n\r\n\t};\r\n\t\r\n\tthis.destroy = function() {\r\n\t\t// things to do there ?\r\n\t}\r\n\r\n\tfunction getAutoRotationAngle() {\r\n\r\n\t\treturn 2 * Math.PI / 60 / 60 * scope.autoRotateSpeed;\r\n\r\n\t}\r\n\r\n\tfunction getZoomScale() {\r\n\r\n\t\treturn Math.pow( 0.95, scope.zoomSpeed );\r\n\r\n\t}\r\n\r\n\tfunction onMouseDown( event ) {\r\n\r\n\t\tif(THREE.Object3D._threexDomEvent.lockObject(event,scope.enableDrag))\r\n\t\t\treturn;\r\n\r\n\t\tif ( scope.enabled === false ) { return; }\r\n\t\tevent.preventDefault();\r\n\t\tevent.stopPropagation();\r\n\r\n\t\tif ( event.button === 0 ) {\r\n\t\t\tif ( scope.noRotate === true ) { return; }\r\n\r\n\t\t\tstate = STATE.ROTATE;\r\n\r\n\t\t\trotateStart.set( event.clientX, event.clientY );\r\n\r\n\t\t} else if ( event.button === 1 ) {\r\n\t\t\tif ( scope.noZoom === true ) { return; }\r\n\r\n\t\t\tstate = STATE.DOLLY;\r\n\r\n\t\t\tdollyStart.set( event.clientX, event.clientY );\r\n\r\n\t\t} else if ( event.button === 2 ) {\r\n\t\t\tif ( scope.noPan === true ) { return; }\r\n\r\n\t\t\tstate = STATE.PAN;\r\n\r\n\t\t\tpanStart.set( event.clientX, event.clientY );\r\n\r\n\t\t}\r\n\r\n\t\t// Greggman fix: https://github.com/greggman/three.js/commit/fde9f9917d6d8381f06bf22cdff766029d1761be\r\n\t\tscope.domElement.addEventListener( 'mousemove', onMouseMove, false );\r\n\t\tscope.domElement.addEventListener( 'mouseup', onMouseUp, false );\r\n\r\n\t}\r\n\r\n\tfunction onMouseMove( event ) {\r\n\r\n\t\tif ( scope.enabled === false ) return;\r\n\r\n\t\tevent.preventDefault();\r\n\t\tevent.stopPropagation();\r\n\r\n\t\tvar element = scope.domElement === document ? scope.domElement.body : scope.domElement;\r\n\r\n\t\tif ( state === STATE.ROTATE ) {\r\n\r\n\t\t\tif ( scope.noRotate === true ) return;\r\n\r\n\t\t\trotateEnd.set( event.clientX, event.clientY );\r\n\t\t\trotateDelta.subVectors( rotateEnd, rotateStart );\r\n\r\n\t\t\t// rotating across whole screen goes 360 degrees around\r\n\t\t\tscope.rotateLeft( 2 * Math.PI * rotateDelta.x / element.clientWidth * scope.rotateSpeed );\r\n\t\t\t// rotating up and down along whole screen attempts to go 360, but limited to 180\r\n\t\t\tscope.rotateUp( 2 * Math.PI * rotateDelta.y / element.clientHeight * scope.rotateSpeed );\r\n\r\n\t\t\trotateStart.copy( rotateEnd );\r\n\t\t\t\r\n\t\t} else if ( state === STATE.DOLLY ) {\r\n\r\n\t\t\tif ( scope.noZoom === true ) return;\r\n\r\n\t\t\tdollyEnd.set( event.clientX, event.clientY );\r\n\t\t\tdollyDelta.subVectors( dollyEnd, dollyStart );\r\n\r\n\t\t\tif ( dollyDelta.y > 0 ) {\r\n\r\n\t\t\t\tscope.dollyIn();\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\tscope.dollyOut();\r\n\r\n\t\t\t}\r\n\r\n\t\t\tdollyStart.copy( dollyEnd );\r\n\r\n\t\t} else if ( state === STATE.PAN ) {\r\n\r\n\t\t\tif ( scope.noPan === true ) return;\r\n\r\n\t\t\tpanEnd.set( event.clientX, event.clientY );\r\n\t\t\tpanDelta.subVectors( panEnd, panStart );\r\n\t\t\t\r\n\t\t\tscope.pan( panDelta );\r\n\r\n\t\t\tpanStart.copy( panEnd );\r\n\r\n\t\t}\r\n\r\n\t\ttrigger();\r\n\r\n\t}\r\n\r\n\tfunction onMouseUp( /* event */ ) {\r\n\r\n\t\tif ( scope.enabled === false ) return;\r\n\r\n\t\t// Greggman fix: https://github.com/greggman/three.js/commit/fde9f9917d6d8381f06bf22cdff766029d1761be\r\n\t\tscope.domElement.removeEventListener( 'mousemove', onMouseMove, false );\r\n\t\tscope.domElement.removeEventListener( 'mouseup', onMouseUp, false );\r\n\r\n\t\tstate = STATE.NONE;\r\n\r\n\t}\r\n\r\n\tfunction onMouseWheel( event ) {\r\n\t\t\r\n\t\tevent.stopPropagation();\r\n\t\tevent.preventDefault();\r\n\r\n\t\tif ( scope.enabled === false || scope.noZoom === true ) return;\r\n\r\n\t\tvar delta = 0;\r\n\r\n\t\tif ( event.wheelDelta ) { // WebKit / Opera / Explorer 9\r\n\r\n\t\t\tdelta = event.wheelDelta;\r\n\r\n\t\t} else if ( event.detail ) { // Firefox\r\n\r\n\t\t\tdelta = - event.detail;\r\n\r\n\t\t}\r\n\r\n\t\tif ( delta > 0 ) {\r\n\r\n\t\t\tscope.dollyOut();\r\n\r\n\t\t} else {\r\n\r\n\t\t\tscope.dollyIn();\r\n\r\n\t\t}\r\n\t\t\r\n\t\ttrigger();\r\n\r\n\t}\r\n\r\n\tfunction onMouseOut( event ) {\r\n\r\n\t\tif ( scope.enabled === false ) return;\r\n\t\r\n\t\tthis.mouseIsDown = false;\r\n\t\tstate = STATE.NONE;\r\n\t\t\r\n\t}\r\n\t\r\n\tfunction onKeyDown( event ) {\r\n\r\n\t\tif ( scope.enabled === false ) { return; }\r\n\t\tif ( scope.noKeys === true ) { return; }\r\n\t\tif ( scope.noPan === true ) { return; }\r\n\r\n\t\t// pan a pixel - I guess for precise positioning?\r\n\t\t// Greggman fix: https://github.com/greggman/three.js/commit/fde9f9917d6d8381f06bf22cdff766029d1761be\r\n\t\tvar needUpdate = false;\r\n\t\t\r\n\t\tswitch ( event.keyCode ) {\r\n\r\n\t\t\tcase scope.keys.UP:\r\n\t\t\t\tscope.pan( new THREE.Vector2( 0, scope.keyPanSpeed ) );\r\n\t\t\t\tneedUpdate = true;\r\n\t\t\t\tbreak;\r\n\t\t\tcase scope.keys.BOTTOM:\r\n\t\t\t\tscope.pan( new THREE.Vector2( 0, -scope.keyPanSpeed ) );\r\n\t\t\t\tneedUpdate = true;\r\n\t\t\t\tbreak;\r\n\t\t\tcase scope.keys.LEFT:\r\n\t\t\t\tscope.pan( new THREE.Vector2( scope.keyPanSpeed, 0 ) );\r\n\t\t\t\tneedUpdate = true;\r\n\t\t\t\tbreak;\r\n\t\t\tcase scope.keys.RIGHT:\r\n\t\t\t\tscope.pan( new THREE.Vector2( -scope.keyPanSpeed, 0 ) );\r\n\t\t\t\tneedUpdate = true;\r\n\t\t\t\tbreak;\r\n\t\t}\r\n\r\n\t\t// Greggman fix: https://github.com/greggman/three.js/commit/fde9f9917d6d8381f06bf22cdff766029d1761be\r\n\t\tif ( needUpdate ) {\r\n\r\n\t\t\tscope.update();\r\n\r\n\t\t}\r\n\r\n\t}\r\n\t\r\n\tfunction touchstart( event ) {\r\n\r\n\t\tif(THREE.Object3D._threexDomEvent.lockObject(event,scope.enableDrag))\r\n\t\t\treturn;\r\n\r\n\t\tif ( scope.enabled === false ) { return; }\r\n\r\n\t\tswitch ( event.touches.length ) {\r\n\r\n\t\t\tcase 1:\t// one-fingered touch: rotate\r\n\t\t\t\tif ( scope.noRotate === true ) { return; }\r\n\r\n\t\t\t\tstate = STATE.TOUCH_ROTATE;\r\n\r\n\t\t\t\trotateStart.set( event.touches[ 0 ].pageX, event.touches[ 0 ].pageY );\r\n\t\t\t\tbreak;\r\n\r\n\t\t\tcase 2:\t// two-fingered touch: dolly\r\n\t\t\t\tif ( scope.noZoom === true ) { return; }\r\n\r\n\t\t\t\tstate = STATE.TOUCH_DOLLY;\r\n\r\n\t\t\t\tvar dx = event.touches[ 0 ].pageX - event.touches[ 1 ].pageX;\r\n\t\t\t\tvar dy = event.touches[ 0 ].pageY - event.touches[ 1 ].pageY;\r\n\t\t\t\tvar distance = Math.sqrt( dx * dx + dy * dy );\r\n\t\t\t\tdollyStart.set( 0, distance );\r\n\t\t\t\tbreak;\r\n\r\n\t\t\tcase 3: // three-fingered touch: pan\r\n\t\t\t\tif ( scope.noPan === true ) { return; }\r\n\r\n\t\t\t\tstate = STATE.TOUCH_PAN;\r\n\r\n\t\t\t\tpanStart.set( event.touches[ 0 ].pageX, event.touches[ 0 ].pageY );\r\n\t\t\t\tbreak;\r\n\r\n\t\t\tdefault:\r\n\t\t\t\tstate = STATE.NONE;\r\n\r\n\t\t}\r\n\t\t\r\n\t\ttrigger();\r\n\t}\r\n\r\n\tfunction touchmove( event ) {\r\n\r\n\t\tif ( scope.enabled === false ) { return; }\r\n\r\n\t\tevent.preventDefault();\r\n\t\tevent.stopPropagation();\r\n\r\n\t\tvar element = scope.domElement === document ? scope.domElement.body : scope.domElement;\r\n\r\n\t\tswitch ( event.touches.length ) {\r\n\r\n\t\t\tcase 1: // one-fingered touch: rotate\r\n\t\t\t\tif ( scope.noRotate === true ) { return; }\r\n\t\t\t\tif ( state !== STATE.TOUCH_ROTATE ) { return; }\r\n\r\n\t\t\t\trotateEnd.set( event.touches[ 0 ].pageX, event.touches[ 0 ].pageY );\r\n\t\t\t\trotateDelta.subVectors( rotateEnd, rotateStart );\r\n\r\n\t\t\t\t// rotating across whole screen goes 360 degrees around\r\n\t\t\t\tscope.rotateLeft( 2 * Math.PI * rotateDelta.x / element.clientWidth * scope.rotateSpeed );\r\n\t\t\t\t// rotating up and down along whole screen attempts to go 360, but limited to 180\r\n\t\t\t\tscope.rotateUp( 2 * Math.PI * rotateDelta.y / element.clientHeight * scope.rotateSpeed );\r\n\r\n\t\t\t\trotateStart.copy( rotateEnd );\r\n\t\t\t\tbreak;\r\n\r\n\t\t\tcase 2: // two-fingered touch: dolly\r\n\t\t\t\tif ( scope.noZoom === true ) { return; }\r\n\t\t\t\tif ( state !== STATE.TOUCH_DOLLY ) { return; }\r\n\r\n\t\t\t\tvar dx = event.touches[ 0 ].pageX - event.touches[ 1 ].pageX;\r\n\t\t\t\tvar dy = event.touches[ 0 ].pageY - event.touches[ 1 ].pageY;\r\n\t\t\t\tvar distance = Math.sqrt( dx * dx + dy * dy );\r\n\r\n\t\t\t\tdollyEnd.set( 0, distance );\r\n\t\t\t\tdollyDelta.subVectors( dollyEnd, dollyStart );\r\n\r\n\t\t\t\tif ( dollyDelta.y > 0 ) {\r\n\r\n\t\t\t\t\tscope.dollyOut();\r\n\r\n\t\t\t\t} else {\r\n\r\n\t\t\t\t\tscope.dollyIn();\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tdollyStart.copy( dollyEnd );\r\n\t\t\t\tbreak;\r\n\r\n\t\t\tcase 3: // three-fingered touch: pan\r\n\t\t\t\tif ( scope.noPan === true ) { return; }\r\n\t\t\t\tif ( state !== STATE.TOUCH_PAN ) { return; }\r\n\r\n\t\t\t\tpanEnd.set( event.touches[ 0 ].pageX, event.touches[ 0 ].pageY );\r\n\t\t\t\tpanDelta.subVectors( panEnd, panStart );\r\n\t\t\t\t\r\n\t\t\t\tscope.pan( panDelta );\r\n\r\n\t\t\t\tpanStart.copy( panEnd );\r\n\t\t\t\tbreak;\r\n\r\n\t\t\tdefault:\r\n\t\t\t\tstate = STATE.NONE;\r\n\r\n\t\t}\r\n\r\n\t\ttrigger();\r\n\r\n\t}\r\n\r\n\tfunction touchend( /* event */ ) {\r\n\r\n\t\tif ( scope.enabled === false ) { return; }\r\n\r\n\t\tstate = STATE.NONE;\r\n\t}\r\n\r\n\tfunction trigger() {\r\n\t\tif(scope.animControl)\r\n\t\t\tscope.animControl.trigger();\r\n\t}\r\n\r\n\tthis.domElement.addEventListener( 'contextmenu', function ( event ) { event.preventDefault(); event.stopPropagation(); }, false );\r\n\tthis.domElement.addEventListener( 'mousedown', onMouseDown, false );\r\n\tthis.domElement.addEventListener( 'mousewheel', onMouseWheel, false );\r\n\tthis.domElement.addEventListener( 'mouseout', onMouseOut, false );\r\n\tthis.domElement.addEventListener( 'DOMMouseScroll', onMouseWheel, false ); // firefox\r\n\r\n\tthis.domElement.addEventListener( 'keydown', onKeyDown, false );\r\n\r\n\tthis.domElement.addEventListener( 'touchstart', touchstart, false );\r\n\tthis.domElement.addEventListener( 'touchend', touchend, false );\r\n\tthis.domElement.addEventListener( 'touchmove', touchmove, false );\r\n\r\n};\r\n\r\nTHREE.OrbitControls.prototype = Object.create( THREE.EventDispatcher.prototype );\r\n","/**\r\n * @author richt / http://richt.me\r\n * @author WestLangley / http://github.com/WestLangley\r\n *\r\n * W3C Device Orientation control (http://w3c.github.io/deviceorientation/spec-source-orientation.html)\r\n */\r\n\r\nTHREE.DeviceOrientationControls = function( object, changeCallback ) {\r\n\r\n\tvar scope = this;\r\n\r\n\tthis.object = object;\r\n\r\n\tthis.enabled = false;\r\n\r\n\tthis.deviceOrientation = {};\r\n\tthis.screenOrientation = 0;\r\n\r\n\tthis.alpha = 0;\r\n\tthis.alphaOffsetAngle = 0;\r\n\r\n\tthis.calibration = true;\r\n\r\n\tvar onDeviceOrientationChangeEvent = function( event ) {\r\n\r\n\t\tif(event.alpha!==null || event.beta!==null | event.gamma!==null) {\r\n\t\t\tscope.object.rotation.reorder( \"YXZ\" );\r\n\t\t\tscope.enabled = true;\r\n\t\t}\r\n\t\tscope.deviceOrientation = event;\r\n\t\tchangeCallback(scope);\r\n\r\n\t};\r\n\r\n\tvar onScreenOrientationChangeEvent = function() {\r\n\r\n\t\tscope.screenOrientation = window.orientation || 0;\r\n\t\tchangeCallback(scope);\r\n\r\n\t};\r\n\r\n\t// The angles alpha, beta and gamma form a set of intrinsic Tait-Bryan angles of type Z-X'-Y''\r\n\r\n\tvar setObjectQuaternion = function() {\r\n\r\n\t\tvar zee = new THREE.Vector3( 0, 0, 1 );\r\n\r\n\t\tvar euler = new THREE.Euler();\r\n\r\n\t\tvar q0 = new THREE.Quaternion();\r\n\r\n\t\tvar q1 = new THREE.Quaternion( - Math.sqrt( 0.5 ), 0, 0, Math.sqrt( 0.5 ) ); // - PI/2 around the x-axis\r\n\r\n\t\treturn function( quaternion, alpha, beta, gamma, orient ) {\r\n\r\n\t\t\teuler.set( beta, alpha, - gamma, 'YXZ' ); // 'ZXY' for the device, but 'YXZ' for us\r\n\r\n\t\t\tquaternion.setFromEuler( euler ); // orient the device\r\n\r\n\t\t\tquaternion.multiply( q1 ); // camera looks out the back of the device, not the top\r\n\r\n\t\t\tquaternion.multiply( q0.setFromAxisAngle( zee, - orient ) ); // adjust for screen orientation\r\n\r\n\t\t}\r\n\r\n\t}();\r\n\r\n\tthis.connect = function() {\r\n\r\n\t\tonScreenOrientationChangeEvent(); // run once on load\r\n\r\n\t\twindow.addEventListener( 'orientationchange', onScreenOrientationChangeEvent, false );\r\n\t\twindow.addEventListener( 'deviceorientation', onDeviceOrientationChangeEvent, false );\r\n\r\n\t};\r\n\r\n\tthis.disconnect = function() {\r\n\r\n\t\twindow.removeEventListener( 'orientationchange', onScreenOrientationChangeEvent, false );\r\n\t\twindow.removeEventListener( 'deviceorientation', onDeviceOrientationChangeEvent, false );\r\n\r\n\t\tscope.enabled = false;\r\n\r\n\t};\r\n\r\n\tthis.update = function() {\r\n\r\n\t\tif ( scope.enabled === false ) return;\r\n\r\n\t\tif(scope.calibration) {\r\n\t\t\tscope.calibration = false;\r\n\t\t\tthis.alphaOffsetAngle = - object.rotation.y - THREE.Math.degToRad( scope.deviceOrientation.alpha ) + Math.PI/2;\r\n\t\t}\r\n\r\n\t\tvar alpha = scope.deviceOrientation.alpha ? THREE.Math.degToRad( scope.deviceOrientation.alpha ) + this.alphaOffsetAngle : 0; // Z\r\n\t\tvar beta = scope.deviceOrientation.beta ? THREE.Math.degToRad( scope.deviceOrientation.beta ) : 0; // X'\r\n\t\tvar gamma = scope.deviceOrientation.gamma ? THREE.Math.degToRad( scope.deviceOrientation.gamma ) : 0; // Y''\r\n\t\tvar orient = scope.screenOrientation ? THREE.Math.degToRad( scope.screenOrientation ) : 0; // O\r\n\r\n\t\tsetObjectQuaternion( scope.object.quaternion, alpha, beta, gamma, orient );\r\n\t\tthis.alpha = alpha;\r\n\r\n\t};\r\n\r\n\tthis.updateAlphaOffsetAngle = function( angle ) {\r\n\r\n\t\tthis.alphaOffsetAngle = angle;\r\n\t\tthis.update();\r\n\r\n\t};\r\n\r\n\tthis.dispose = function() {\r\n\r\n\t\tthis.disconnect();\r\n\r\n\t};\r\n\r\n\tthis.connect();\r\n\r\n};\r\n","/**\r\n * @author mrdoob / http://mrdoob.com/\r\n * @author supereggbert / http://www.paulbrunt.co.uk/\r\n * @author julianwa / https://github.com/julianwa\r\n */\r\n\r\nTHREE.RenderableObject = function () {\r\n\r\n\tthis.id = 0;\r\n\r\n\tthis.object = null;\r\n\tthis.z = 0;\r\n\tthis.renderOrder = 0;\r\n\r\n};\r\n\r\n//\r\n\r\nTHREE.RenderableFace = function () {\r\n\r\n\tthis.id = 0;\r\n\r\n\tthis.v1 = new THREE.RenderableVertex();\r\n\tthis.v2 = new THREE.RenderableVertex();\r\n\tthis.v3 = new THREE.RenderableVertex();\r\n\r\n\tthis.normalModel = new THREE.Vector3();\r\n\r\n\tthis.vertexNormalsModel = [ new THREE.Vector3(), new THREE.Vector3(), new THREE.Vector3() ];\r\n\tthis.vertexNormalsLength = 0;\r\n\r\n\tthis.color = new THREE.Color();\r\n\tthis.material = null;\r\n\tthis.uvs = [ new THREE.Vector2(), new THREE.Vector2(), new THREE.Vector2() ];\r\n\r\n\tthis.z = 0;\r\n\tthis.renderOrder = 0;\r\n\r\n};\r\n\r\n//\r\n\r\nTHREE.RenderableVertex = function () {\r\n\r\n\tthis.position = new THREE.Vector3();\r\n\tthis.positionWorld = new THREE.Vector3();\r\n\tthis.positionScreen = new THREE.Vector4();\r\n\r\n\tthis.visible = true;\r\n\r\n};\r\n\r\nTHREE.RenderableVertex.prototype.copy = function ( vertex ) {\r\n\r\n\tthis.positionWorld.copy( vertex.positionWorld );\r\n\tthis.positionScreen.copy( vertex.positionScreen );\r\n\r\n};\r\n\r\n//\r\n\r\nTHREE.RenderableLine = function () {\r\n\r\n\tthis.id = 0;\r\n\r\n\tthis.v1 = new THREE.RenderableVertex();\r\n\tthis.v2 = new THREE.RenderableVertex();\r\n\r\n\tthis.vertexColors = [ new THREE.Color(), new THREE.Color() ];\r\n\tthis.material = null;\r\n\r\n\tthis.z = 0;\r\n\tthis.renderOrder = 0;\r\n\r\n};\r\n\r\n//\r\n\r\nTHREE.RenderableSprite = function () {\r\n\r\n\tthis.id = 0;\r\n\r\n\tthis.object = null;\r\n\r\n\tthis.x = 0;\r\n\tthis.y = 0;\r\n\tthis.z = 0;\r\n\r\n\tthis.rotation = 0;\r\n\tthis.scale = new THREE.Vector2();\r\n\r\n\tthis.material = null;\r\n\tthis.renderOrder = 0;\r\n\r\n};\r\n\r\n//\r\n\r\nTHREE.Projector = function () {\r\n\r\n\tvar _object, _objectCount, _objectPool = [], _objectPoolLength = 0,\r\n\t_vertex, _vertexCount, _vertexPool = [], _vertexPoolLength = 0,\r\n\t_face, _faceCount, _facePool = [], _facePoolLength = 0,\r\n\t_line, _lineCount, _linePool = [], _linePoolLength = 0,\r\n\t_sprite, _spriteCount, _spritePool = [], _spritePoolLength = 0,\r\n\r\n\t_renderData = { objects: [], lights: [], elements: [] },\r\n\r\n\t_vector3 = new THREE.Vector3(),\r\n\t_vector4 = new THREE.Vector4(),\r\n\r\n\t_clipBox = new THREE.Box3( new THREE.Vector3( - 1, - 1, - 1 ), new THREE.Vector3( 1, 1, 1 ) ),\r\n\t_boundingBox = new THREE.Box3(),\r\n\t_points3 = new Array( 3 ),\r\n\t_points4 = new Array( 4 ),\r\n\r\n\t_viewMatrix = new THREE.Matrix4(),\r\n\t_viewProjectionMatrix = new THREE.Matrix4(),\r\n\r\n\t_modelMatrix,\r\n\t_modelViewProjectionMatrix = new THREE.Matrix4(),\r\n\r\n\t_normalMatrix = new THREE.Matrix3(),\r\n\r\n\t_frustum = new THREE.Frustum(),\r\n\r\n\t_clippedVertex1PositionScreen = new THREE.Vector4(),\r\n\t_clippedVertex2PositionScreen = new THREE.Vector4();\r\n\r\n\t//\r\n\r\n\tthis.projectVector = function ( vector, camera ) {\r\n\r\n\t\tconsole.warn( 'THREE.Projector: .projectVector() is now vector.project().' );\r\n\t\tvector.project( camera );\r\n\r\n\t};\r\n\r\n\tthis.unprojectVector = function ( vector, camera ) {\r\n\r\n\t\tconsole.warn( 'THREE.Projector: .unprojectVector() is now vector.unproject().' );\r\n\t\tvector.unproject( camera );\r\n\r\n\t};\r\n\r\n\tthis.pickingRay = function ( vector, camera ) {\r\n\r\n\t\tconsole.error( 'THREE.Projector: .pickingRay() is now raycaster.setFromCamera().' );\r\n\r\n\t};\r\n\r\n\t//\r\n\r\n\tvar RenderList = function () {\r\n\r\n\t\tvar normals = [];\r\n\t\tvar uvs = [];\r\n\r\n\t\tvar object = null;\r\n\t\tvar material = null;\r\n\r\n\t\tvar normalMatrix = new THREE.Matrix3();\r\n\r\n\t\tfunction setObject( value ) {\r\n\r\n\t\t\tobject = value;\r\n\t\t\tmaterial = object.material;\r\n\r\n\t\t\tnormalMatrix.getNormalMatrix( object.matrixWorld );\r\n\r\n\t\t\tnormals.length = 0;\r\n\t\t\tuvs.length = 0;\r\n\r\n\t\t}\r\n\r\n\t\tfunction projectVertex( vertex ) {\r\n\r\n\t\t\tvar position = vertex.position;\r\n\t\t\tvar positionWorld = vertex.positionWorld;\r\n\t\t\tvar positionScreen = vertex.positionScreen;\r\n\r\n\t\t\tpositionWorld.copy( position ).applyMatrix4( _modelMatrix );\r\n\t\t\tpositionScreen.copy( positionWorld ).applyMatrix4( _viewProjectionMatrix );\r\n\r\n\t\t\tvar invW = 1 / positionScreen.w;\r\n\r\n\t\t\tpositionScreen.x *= invW;\r\n\t\t\tpositionScreen.y *= invW;\r\n\t\t\tpositionScreen.z *= invW;\r\n\r\n\t\t\tvertex.visible = positionScreen.x >= - 1 && positionScreen.x <= 1 &&\r\n\t\t\t\t\t positionScreen.y >= - 1 && positionScreen.y <= 1 &&\r\n\t\t\t\t\t positionScreen.z >= - 1 && positionScreen.z <= 1;\r\n\r\n\t\t}\r\n\r\n\t\tfunction pushVertex( x, y, z ) {\r\n\r\n\t\t\t_vertex = getNextVertexInPool();\r\n\t\t\t_vertex.position.set( x, y, z );\r\n\r\n\t\t\tprojectVertex( _vertex );\r\n\r\n\t\t}\r\n\r\n\t\tfunction pushNormal( x, y, z ) {\r\n\r\n\t\t\tnormals.push( x, y, z );\r\n\r\n\t\t}\r\n\r\n\t\tfunction pushUv( x, y ) {\r\n\r\n\t\t\tuvs.push( x, y );\r\n\r\n\t\t}\r\n\r\n\t\tfunction checkTriangleVisibility( v1, v2, v3 ) {\r\n\r\n\t\t\tif ( v1.visible === true || v2.visible === true || v3.visible === true ) return true;\r\n\r\n\t\t\t_points3[ 0 ] = v1.positionScreen;\r\n\t\t\t_points3[ 1 ] = v2.positionScreen;\r\n\t\t\t_points3[ 2 ] = v3.positionScreen;\r\n\r\n\t\t\treturn _clipBox.intersectsBox( _boundingBox.setFromPoints( _points3 ) );\r\n\r\n\t\t}\r\n\r\n\t\tfunction checkBackfaceCulling( v1, v2, v3 ) {\r\n\r\n\t\t\treturn ( ( v3.positionScreen.x - v1.positionScreen.x ) *\r\n\t\t\t\t    ( v2.positionScreen.y - v1.positionScreen.y ) -\r\n\t\t\t\t    ( v3.positionScreen.y - v1.positionScreen.y ) *\r\n\t\t\t\t    ( v2.positionScreen.x - v1.positionScreen.x ) ) < 0;\r\n\r\n\t\t}\r\n\r\n\t\tfunction pushLine( a, b ) {\r\n\r\n\t\t\tvar v1 = _vertexPool[ a ];\r\n\t\t\tvar v2 = _vertexPool[ b ];\r\n\r\n\t\t\t_line = getNextLineInPool();\r\n\r\n\t\t\t_line.id = object.id;\r\n\t\t\t_line.v1.copy( v1 );\r\n\t\t\t_line.v2.copy( v2 );\r\n\t\t\t_line.z = ( v1.positionScreen.z + v2.positionScreen.z ) / 2;\r\n\t\t\t_line.renderOrder = object.renderOrder;\r\n\r\n\t\t\t_line.material = object.material;\r\n\r\n\t\t\t_renderData.elements.push( _line );\r\n\r\n\t\t}\r\n\r\n\t\tfunction pushTriangle( a, b, c ) {\r\n\r\n\t\t\tvar v1 = _vertexPool[ a ];\r\n\t\t\tvar v2 = _vertexPool[ b ];\r\n\t\t\tvar v3 = _vertexPool[ c ];\r\n\r\n\t\t\tif ( checkTriangleVisibility( v1, v2, v3 ) === false ) return;\r\n\r\n\t\t\tif ( material.side === THREE.DoubleSide || checkBackfaceCulling( v1, v2, v3 ) === true ) {\r\n\r\n\t\t\t\t_face = getNextFaceInPool();\r\n\r\n\t\t\t\t_face.id = object.id;\r\n\t\t\t\t_face.v1.copy( v1 );\r\n\t\t\t\t_face.v2.copy( v2 );\r\n\t\t\t\t_face.v3.copy( v3 );\r\n\t\t\t\t_face.z = ( v1.positionScreen.z + v2.positionScreen.z + v3.positionScreen.z ) / 3;\r\n\t\t\t\t_face.renderOrder = object.renderOrder;\r\n\r\n\t\t\t\t// use first vertex normal as face normal\r\n\r\n\t\t\t\t_face.normalModel.fromArray( normals, a * 3 );\r\n\t\t\t\t_face.normalModel.applyMatrix3( normalMatrix ).normalize();\r\n\r\n\t\t\t\tfor ( var i = 0; i < 3; i ++ ) {\r\n\r\n\t\t\t\t\tvar normal = _face.vertexNormalsModel[ i ];\r\n\t\t\t\t\tnormal.fromArray( normals, arguments[ i ] * 3 );\r\n\t\t\t\t\tnormal.applyMatrix3( normalMatrix ).normalize();\r\n\r\n\t\t\t\t\tvar uv = _face.uvs[ i ];\r\n\t\t\t\t\tuv.fromArray( uvs, arguments[ i ] * 2 );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\t_face.vertexNormalsLength = 3;\r\n\r\n\t\t\t\t_face.material = object.material;\r\n\r\n\t\t\t\t_renderData.elements.push( _face );\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\treturn {\r\n\t\t\tsetObject: setObject,\r\n\t\t\tprojectVertex: projectVertex,\r\n\t\t\tcheckTriangleVisibility: checkTriangleVisibility,\r\n\t\t\tcheckBackfaceCulling: checkBackfaceCulling,\r\n\t\t\tpushVertex: pushVertex,\r\n\t\t\tpushNormal: pushNormal,\r\n\t\t\tpushUv: pushUv,\r\n\t\t\tpushLine: pushLine,\r\n\t\t\tpushTriangle: pushTriangle\r\n\t\t}\r\n\r\n\t};\r\n\r\n\tvar renderList = new RenderList();\r\n\r\n\tthis.projectScene = function ( scene, camera, sortObjects, sortElements ) {\r\n\r\n\t\t_faceCount = 0;\r\n\t\t_lineCount = 0;\r\n\t\t_spriteCount = 0;\r\n\r\n\t\t_renderData.elements.length = 0;\r\n\r\n\t\tif ( scene.autoUpdate === true ) scene.updateMatrixWorld();\r\n\t\tif ( camera.parent === null ) camera.updateMatrixWorld();\r\n\r\n\t\t_viewMatrix.copy( camera.matrixWorldInverse.getInverse( camera.matrixWorld ) );\r\n\t\t_viewProjectionMatrix.multiplyMatrices( camera.projectionMatrix, _viewMatrix );\r\n\r\n\t\t_frustum.setFromMatrix( _viewProjectionMatrix );\r\n\r\n\t\t//\r\n\r\n\t\t_objectCount = 0;\r\n\r\n\t\t_renderData.objects.length = 0;\r\n\t\t_renderData.lights.length = 0;\r\n\r\n\t\tfunction addObject( object ) {\r\n\r\n\t\t\t_object = getNextObjectInPool();\r\n\t\t\t_object.id = object.id;\r\n\t\t\t_object.object = object;\r\n\r\n\t\t\t_vector3.setFromMatrixPosition( object.matrixWorld );\r\n\t\t\t_vector3.applyMatrix4( _viewProjectionMatrix );\r\n\t\t\t_object.z = _vector3.z;\r\n\t\t\t_object.renderOrder = object.renderOrder;\r\n\r\n\t\t\t_renderData.objects.push( _object );\r\n\r\n\t\t}\r\n\r\n\t\tscene.traverseVisible( function ( object ) {\r\n\r\n\t\t\tif ( object instanceof THREE.Light ) {\r\n\r\n\t\t\t\t_renderData.lights.push( object );\r\n\r\n\t\t\t} else if ( object instanceof THREE.Mesh || object instanceof THREE.Line ) {\r\n\r\n\t\t\t\tif ( object.material.visible === false ) return;\r\n\t\t\t\tif ( object.frustumCulled === true && _frustum.intersectsObject( object ) === false ) return;\r\n\r\n\t\t\t\taddObject( object );\r\n\r\n\t\t\t} else if ( object instanceof THREE.Sprite ) {\r\n\r\n\t\t\t\tif ( object.material.visible === false ) return;\r\n\t\t\t\tif ( object.frustumCulled === true && _frustum.intersectsSprite( object ) === false ) return;\r\n\r\n\t\t\t\taddObject( object );\r\n\r\n\t\t\t}\r\n\r\n\t\t} );\r\n\r\n\t\tif ( sortObjects === true ) {\r\n\r\n\t\t\t_renderData.objects.sort( painterSort );\r\n\r\n\t\t}\r\n\r\n\t\t//\r\n\r\n\t\tfor ( var o = 0, ol = _renderData.objects.length; o < ol; o ++ ) {\r\n\r\n\t\t\tvar object = _renderData.objects[ o ].object;\r\n\t\t\tvar geometry = object.geometry;\r\n\r\n\t\t\trenderList.setObject( object );\r\n\r\n\t\t\t_modelMatrix = object.matrixWorld;\r\n\r\n\t\t\t_vertexCount = 0;\r\n\r\n\t\t\tif ( object instanceof THREE.Mesh ) {\r\n\r\n\t\t\t\tif ( geometry instanceof THREE.BufferGeometry ) {\r\n\r\n\t\t\t\t\tvar attributes = geometry.attributes;\r\n\t\t\t\t\tvar groups = geometry.groups;\r\n\r\n\t\t\t\t\tif ( attributes.position === undefined ) continue;\r\n\r\n\t\t\t\t\tvar positions = attributes.position.array;\r\n\r\n\t\t\t\t\tfor ( var i = 0, l = positions.length; i < l; i += 3 ) {\r\n\r\n\t\t\t\t\t\trenderList.pushVertex( positions[ i ], positions[ i + 1 ], positions[ i + 2 ] );\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tif ( attributes.normal !== undefined ) {\r\n\r\n\t\t\t\t\t\tvar normals = attributes.normal.array;\r\n\r\n\t\t\t\t\t\tfor ( var i = 0, l = normals.length; i < l; i += 3 ) {\r\n\r\n\t\t\t\t\t\t\trenderList.pushNormal( normals[ i ], normals[ i + 1 ], normals[ i + 2 ] );\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tif ( attributes.uv !== undefined ) {\r\n\r\n\t\t\t\t\t\tvar uvs = attributes.uv.array;\r\n\r\n\t\t\t\t\t\tfor ( var i = 0, l = uvs.length; i < l; i += 2 ) {\r\n\r\n\t\t\t\t\t\t\trenderList.pushUv( uvs[ i ], uvs[ i + 1 ] );\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tif ( geometry.index !== null ) {\r\n\r\n\t\t\t\t\t\tvar indices = geometry.index.array;\r\n\r\n\t\t\t\t\t\tif ( groups.length > 0 ) {\r\n\r\n\t\t\t\t\t\t\tfor ( var g = 0; g < groups.length; g ++ ) {\r\n\r\n\t\t\t\t\t\t\t\tvar group = groups[ g ];\r\n\r\n\t\t\t\t\t\t\t\tfor ( var i = group.start, l = group.start + group.count; i < l; i += 3 ) {\r\n\r\n\t\t\t\t\t\t\t\t\trenderList.pushTriangle( indices[ i ], indices[ i + 1 ], indices[ i + 2 ] );\r\n\r\n\t\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t} else {\r\n\r\n\t\t\t\t\t\t\tfor ( var i = 0, l = indices.length; i < l; i += 3 ) {\r\n\r\n\t\t\t\t\t\t\t\trenderList.pushTriangle( indices[ i ], indices[ i + 1 ], indices[ i + 2 ] );\r\n\r\n\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t} else {\r\n\r\n\t\t\t\t\t\tfor ( var i = 0, l = positions.length / 3; i < l; i += 3 ) {\r\n\r\n\t\t\t\t\t\t\trenderList.pushTriangle( i, i + 1, i + 2 );\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t} else if ( geometry instanceof THREE.Geometry ) {\r\n\r\n\t\t\t\t\tvar vertices = geometry.vertices;\r\n\t\t\t\t\tvar faces = geometry.faces;\r\n\t\t\t\t\tvar faceVertexUvs = geometry.faceVertexUvs[ 0 ];\r\n\r\n\t\t\t\t\t_normalMatrix.getNormalMatrix( _modelMatrix );\r\n\r\n\t\t\t\t\tvar material = object.material;\r\n\r\n\t\t\t\t\tvar isFaceMaterial = material instanceof THREE.MultiMaterial;\r\n\t\t\t\t\tvar objectMaterials = isFaceMaterial === true ? object.material : null;\r\n\r\n\t\t\t\t\tfor ( var v = 0, vl = vertices.length; v < vl; v ++ ) {\r\n\r\n\t\t\t\t\t\tvar vertex = vertices[ v ];\r\n\r\n\t\t\t\t\t\t_vector3.copy( vertex );\r\n\r\n\t\t\t\t\t\tif ( material.morphTargets === true ) {\r\n\r\n\t\t\t\t\t\t\tvar morphTargets = geometry.morphTargets;\r\n\t\t\t\t\t\t\tvar morphInfluences = object.morphTargetInfluences;\r\n\r\n\t\t\t\t\t\t\tfor ( var t = 0, tl = morphTargets.length; t < tl; t ++ ) {\r\n\r\n\t\t\t\t\t\t\t\tvar influence = morphInfluences[ t ];\r\n\r\n\t\t\t\t\t\t\t\tif ( influence === 0 ) continue;\r\n\r\n\t\t\t\t\t\t\t\tvar target = morphTargets[ t ];\r\n\t\t\t\t\t\t\t\tvar targetVertex = target.vertices[ v ];\r\n\r\n\t\t\t\t\t\t\t\t_vector3.x += ( targetVertex.x - vertex.x ) * influence;\r\n\t\t\t\t\t\t\t\t_vector3.y += ( targetVertex.y - vertex.y ) * influence;\r\n\t\t\t\t\t\t\t\t_vector3.z += ( targetVertex.z - vertex.z ) * influence;\r\n\r\n\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\trenderList.pushVertex( _vector3.x, _vector3.y, _vector3.z );\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tfor ( var f = 0, fl = faces.length; f < fl; f ++ ) {\r\n\r\n\t\t\t\t\t\tvar face = faces[ f ];\r\n\r\n\t\t\t\t\t\tmaterial = isFaceMaterial === true\r\n\t\t\t\t\t\t\t ? objectMaterials.materials[ face.materialIndex ]\r\n\t\t\t\t\t\t\t : object.material;\r\n\r\n\t\t\t\t\t\tif ( material === undefined ) continue;\r\n\r\n\t\t\t\t\t\tvar side = material.side;\r\n\r\n\t\t\t\t\t\tvar v1 = _vertexPool[ face.a ];\r\n\t\t\t\t\t\tvar v2 = _vertexPool[ face.b ];\r\n\t\t\t\t\t\tvar v3 = _vertexPool[ face.c ];\r\n\r\n\t\t\t\t\t\tif ( renderList.checkTriangleVisibility( v1, v2, v3 ) === false ) continue;\r\n\r\n\t\t\t\t\t\tvar visible = renderList.checkBackfaceCulling( v1, v2, v3 );\r\n\r\n\t\t\t\t\t\tif ( side !== THREE.DoubleSide ) {\r\n\r\n\t\t\t\t\t\t\tif ( side === THREE.FrontSide && visible === false ) continue;\r\n\t\t\t\t\t\t\tif ( side === THREE.BackSide && visible === true ) continue;\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t_face = getNextFaceInPool();\r\n\r\n\t\t\t\t\t\t_face.id = object.id;\r\n\t\t\t\t\t\t_face.v1.copy( v1 );\r\n\t\t\t\t\t\t_face.v2.copy( v2 );\r\n\t\t\t\t\t\t_face.v3.copy( v3 );\r\n\r\n\t\t\t\t\t\t_face.normalModel.copy( face.normal );\r\n\r\n\t\t\t\t\t\tif ( visible === false && ( side === THREE.BackSide || side === THREE.DoubleSide ) ) {\r\n\r\n\t\t\t\t\t\t\t_face.normalModel.negate();\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t_face.normalModel.applyMatrix3( _normalMatrix ).normalize();\r\n\r\n\t\t\t\t\t\tvar faceVertexNormals = face.vertexNormals;\r\n\r\n\t\t\t\t\t\tfor ( var n = 0, nl = Math.min( faceVertexNormals.length, 3 ); n < nl; n ++ ) {\r\n\r\n\t\t\t\t\t\t\tvar normalModel = _face.vertexNormalsModel[ n ];\r\n\t\t\t\t\t\t\tnormalModel.copy( faceVertexNormals[ n ] );\r\n\r\n\t\t\t\t\t\t\tif ( visible === false && ( side === THREE.BackSide || side === THREE.DoubleSide ) ) {\r\n\r\n\t\t\t\t\t\t\t\tnormalModel.negate();\r\n\r\n\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t\tnormalModel.applyMatrix3( _normalMatrix ).normalize();\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t_face.vertexNormalsLength = faceVertexNormals.length;\r\n\r\n\t\t\t\t\t\tvar vertexUvs = faceVertexUvs[ f ];\r\n\r\n\t\t\t\t\t\tif ( vertexUvs !== undefined ) {\r\n\r\n\t\t\t\t\t\t\tfor ( var u = 0; u < 3; u ++ ) {\r\n\r\n\t\t\t\t\t\t\t\t_face.uvs[ u ].copy( vertexUvs[ u ] );\r\n\r\n\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t_face.color = face.color;\r\n\t\t\t\t\t\t_face.material = material;\r\n\r\n\t\t\t\t\t\t_face.z = ( v1.positionScreen.z + v2.positionScreen.z + v3.positionScreen.z ) / 3;\r\n\t\t\t\t\t\t_face.renderOrder = object.renderOrder;\r\n\r\n\t\t\t\t\t\t_renderData.elements.push( _face );\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t} else if ( object instanceof THREE.Line ) {\r\n\r\n\t\t\t\tif ( geometry instanceof THREE.BufferGeometry ) {\r\n\r\n\t\t\t\t\tvar attributes = geometry.attributes;\r\n\r\n\t\t\t\t\tif ( attributes.position !== undefined ) {\r\n\r\n\t\t\t\t\t\tvar positions = attributes.position.array;\r\n\r\n\t\t\t\t\t\tfor ( var i = 0, l = positions.length; i < l; i += 3 ) {\r\n\r\n\t\t\t\t\t\t\trenderList.pushVertex( positions[ i ], positions[ i + 1 ], positions[ i + 2 ] );\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\tif ( geometry.index !== null ) {\r\n\r\n\t\t\t\t\t\t\tvar indices = geometry.index.array;\r\n\r\n\t\t\t\t\t\t\tfor ( var i = 0, l = indices.length; i < l; i += 2 ) {\r\n\r\n\t\t\t\t\t\t\t\trenderList.pushLine( indices[ i ], indices[ i + 1 ] );\r\n\r\n\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t} else {\r\n\r\n\t\t\t\t\t\t\tvar step = object instanceof THREE.LineSegments ? 2 : 1;\r\n\r\n\t\t\t\t\t\t\tfor ( var i = 0, l = ( positions.length / 3 ) - 1; i < l; i += step ) {\r\n\r\n\t\t\t\t\t\t\t\trenderList.pushLine( i, i + 1 );\r\n\r\n\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t} else if ( geometry instanceof THREE.Geometry ) {\r\n\r\n\t\t\t\t\t_modelViewProjectionMatrix.multiplyMatrices( _viewProjectionMatrix, _modelMatrix );\r\n\r\n\t\t\t\t\tvar vertices = object.geometry.vertices;\r\n\r\n\t\t\t\t\tif ( vertices.length === 0 ) continue;\r\n\r\n\t\t\t\t\tv1 = getNextVertexInPool();\r\n\t\t\t\t\tv1.positionScreen.copy( vertices[ 0 ] ).applyMatrix4( _modelViewProjectionMatrix );\r\n\r\n\t\t\t\t\tvar step = object instanceof THREE.LineSegments ? 2 : 1;\r\n\r\n\t\t\t\t\tfor ( var v = 1, vl = vertices.length; v < vl; v ++ ) {\r\n\r\n\t\t\t\t\t\tv1 = getNextVertexInPool();\r\n\t\t\t\t\t\tv1.positionScreen.copy( vertices[ v ] ).applyMatrix4( _modelViewProjectionMatrix );\r\n\r\n\t\t\t\t\t\tif ( ( v + 1 ) % step > 0 ) continue;\r\n\r\n\t\t\t\t\t\tv2 = _vertexPool[ _vertexCount - 2 ];\r\n\r\n\t\t\t\t\t\t_clippedVertex1PositionScreen.copy( v1.positionScreen );\r\n\t\t\t\t\t\t_clippedVertex2PositionScreen.copy( v2.positionScreen );\r\n\r\n\t\t\t\t\t\tif ( clipLine( _clippedVertex1PositionScreen, _clippedVertex2PositionScreen ) === true ) {\r\n\r\n\t\t\t\t\t\t\t// Perform the perspective divide\r\n\t\t\t\t\t\t\t_clippedVertex1PositionScreen.multiplyScalar( 1 / _clippedVertex1PositionScreen.w );\r\n\t\t\t\t\t\t\t_clippedVertex2PositionScreen.multiplyScalar( 1 / _clippedVertex2PositionScreen.w );\r\n\r\n\t\t\t\t\t\t\t_line = getNextLineInPool();\r\n\r\n\t\t\t\t\t\t\t_line.id = object.id;\r\n\t\t\t\t\t\t\t_line.v1.positionScreen.copy( _clippedVertex1PositionScreen );\r\n\t\t\t\t\t\t\t_line.v2.positionScreen.copy( _clippedVertex2PositionScreen );\r\n\r\n\t\t\t\t\t\t\t_line.z = Math.max( _clippedVertex1PositionScreen.z, _clippedVertex2PositionScreen.z );\r\n\t\t\t\t\t\t\t_line.renderOrder = object.renderOrder;\r\n\r\n\t\t\t\t\t\t\t_line.material = object.material;\r\n\r\n\t\t\t\t\t\t\tif ( object.material.vertexColors === THREE.VertexColors ) {\r\n\r\n\t\t\t\t\t\t\t\t_line.vertexColors[ 0 ].copy( object.geometry.colors[ v ] );\r\n\t\t\t\t\t\t\t\t_line.vertexColors[ 1 ].copy( object.geometry.colors[ v - 1 ] );\r\n\r\n\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t\t_renderData.elements.push( _line );\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t} else if ( object instanceof THREE.Sprite ) {\r\n\r\n\t\t\t\t_vector4.set( _modelMatrix.elements[ 12 ], _modelMatrix.elements[ 13 ], _modelMatrix.elements[ 14 ], 1 );\r\n\t\t\t\t_vector4.applyMatrix4( _viewProjectionMatrix );\r\n\r\n\t\t\t\tvar invW = 1 / _vector4.w;\r\n\r\n\t\t\t\t_vector4.z *= invW;\r\n\r\n\t\t\t\tif ( _vector4.z >= - 1 && _vector4.z <= 1 ) {\r\n\r\n\t\t\t\t\t_sprite = getNextSpriteInPool();\r\n\t\t\t\t\t_sprite.id = object.id;\r\n\t\t\t\t\t_sprite.x = _vector4.x * invW;\r\n\t\t\t\t\t_sprite.y = _vector4.y * invW;\r\n\t\t\t\t\t_sprite.z = _vector4.z;\r\n\t\t\t\t\t_sprite.renderOrder = object.renderOrder;\r\n\t\t\t\t\t_sprite.object = object;\r\n\r\n\t\t\t\t\t_sprite.rotation = object.rotation;\r\n\r\n\t\t\t\t\t_sprite.scale.x = object.scale.x * Math.abs( _sprite.x - ( _vector4.x + camera.projectionMatrix.elements[ 0 ] ) / ( _vector4.w + camera.projectionMatrix.elements[ 12 ] ) );\r\n\t\t\t\t\t_sprite.scale.y = object.scale.y * Math.abs( _sprite.y - ( _vector4.y + camera.projectionMatrix.elements[ 5 ] ) / ( _vector4.w + camera.projectionMatrix.elements[ 13 ] ) );\r\n\r\n\t\t\t\t\t_sprite.material = object.material;\r\n\r\n\t\t\t\t\t_renderData.elements.push( _sprite );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\tif ( sortElements === true ) {\r\n\r\n\t\t\t_renderData.elements.sort( painterSort );\r\n\r\n\t\t}\r\n\r\n\t\treturn _renderData;\r\n\r\n\t};\r\n\r\n\t// Pools\r\n\r\n\tfunction getNextObjectInPool() {\r\n\r\n\t\tif ( _objectCount === _objectPoolLength ) {\r\n\r\n\t\t\tvar object = new THREE.RenderableObject();\r\n\t\t\t_objectPool.push( object );\r\n\t\t\t_objectPoolLength ++;\r\n\t\t\t_objectCount ++;\r\n\t\t\treturn object;\r\n\r\n\t\t}\r\n\r\n\t\treturn _objectPool[ _objectCount ++ ];\r\n\r\n\t}\r\n\r\n\tfunction getNextVertexInPool() {\r\n\r\n\t\tif ( _vertexCount === _vertexPoolLength ) {\r\n\r\n\t\t\tvar vertex = new THREE.RenderableVertex();\r\n\t\t\t_vertexPool.push( vertex );\r\n\t\t\t_vertexPoolLength ++;\r\n\t\t\t_vertexCount ++;\r\n\t\t\treturn vertex;\r\n\r\n\t\t}\r\n\r\n\t\treturn _vertexPool[ _vertexCount ++ ];\r\n\r\n\t}\r\n\r\n\tfunction getNextFaceInPool() {\r\n\r\n\t\tif ( _faceCount === _facePoolLength ) {\r\n\r\n\t\t\tvar face = new THREE.RenderableFace();\r\n\t\t\t_facePool.push( face );\r\n\t\t\t_facePoolLength ++;\r\n\t\t\t_faceCount ++;\r\n\t\t\treturn face;\r\n\r\n\t\t}\r\n\r\n\t\treturn _facePool[ _faceCount ++ ];\r\n\r\n\r\n\t}\r\n\r\n\tfunction getNextLineInPool() {\r\n\r\n\t\tif ( _lineCount === _linePoolLength ) {\r\n\r\n\t\t\tvar line = new THREE.RenderableLine();\r\n\t\t\t_linePool.push( line );\r\n\t\t\t_linePoolLength ++;\r\n\t\t\t_lineCount ++;\r\n\t\t\treturn line;\r\n\r\n\t\t}\r\n\r\n\t\treturn _linePool[ _lineCount ++ ];\r\n\r\n\t}\r\n\r\n\tfunction getNextSpriteInPool() {\r\n\r\n\t\tif ( _spriteCount === _spritePoolLength ) {\r\n\r\n\t\t\tvar sprite = new THREE.RenderableSprite();\r\n\t\t\t_spritePool.push( sprite );\r\n\t\t\t_spritePoolLength ++;\r\n\t\t\t_spriteCount ++;\r\n\t\t\treturn sprite;\r\n\r\n\t\t}\r\n\r\n\t\treturn _spritePool[ _spriteCount ++ ];\r\n\r\n\t}\r\n\r\n\t//\r\n\r\n\tfunction painterSort( a, b ) {\r\n\r\n\t\tif ( a.renderOrder !== b.renderOrder ) {\r\n\r\n\t\t\treturn a.renderOrder - b.renderOrder;\r\n\r\n\t\t} else if ( a.z !== b.z ) {\r\n\r\n\t\t\treturn b.z - a.z;\r\n\r\n\t\t} else if ( a.id !== b.id ) {\r\n\r\n\t\t\treturn a.id - b.id;\r\n\r\n\t\t} else {\r\n\r\n\t\t\treturn 0;\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\tfunction clipLine( s1, s2 ) {\r\n\r\n\t\tvar alpha1 = 0, alpha2 = 1,\r\n\r\n\t\t// Calculate the boundary coordinate of each vertex for the near and far clip planes,\r\n\t\t// Z = -1 and Z = +1, respectively.\r\n\t\tbc1near =  s1.z + s1.w,\r\n\t\tbc2near =  s2.z + s2.w,\r\n\t\tbc1far =  - s1.z + s1.w,\r\n\t\tbc2far =  - s2.z + s2.w;\r\n\r\n\t\tif ( bc1near >= 0 && bc2near >= 0 && bc1far >= 0 && bc2far >= 0 ) {\r\n\r\n\t\t\t// Both vertices lie entirely within all clip planes.\r\n\t\t\treturn true;\r\n\r\n\t\t} else if ( ( bc1near < 0 && bc2near < 0 ) || ( bc1far < 0 && bc2far < 0 ) ) {\r\n\r\n\t\t\t// Both vertices lie entirely outside one of the clip planes.\r\n\t\t\treturn false;\r\n\r\n\t\t} else {\r\n\r\n\t\t\t// The line segment spans at least one clip plane.\r\n\r\n\t\t\tif ( bc1near < 0 ) {\r\n\r\n\t\t\t\t// v1 lies outside the near plane, v2 inside\r\n\t\t\t\talpha1 = Math.max( alpha1, bc1near / ( bc1near - bc2near ) );\r\n\r\n\t\t\t} else if ( bc2near < 0 ) {\r\n\r\n\t\t\t\t// v2 lies outside the near plane, v1 inside\r\n\t\t\t\talpha2 = Math.min( alpha2, bc1near / ( bc1near - bc2near ) );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tif ( bc1far < 0 ) {\r\n\r\n\t\t\t\t// v1 lies outside the far plane, v2 inside\r\n\t\t\t\talpha1 = Math.max( alpha1, bc1far / ( bc1far - bc2far ) );\r\n\r\n\t\t\t} else if ( bc2far < 0 ) {\r\n\r\n\t\t\t\t// v2 lies outside the far plane, v2 inside\r\n\t\t\t\talpha2 = Math.min( alpha2, bc1far / ( bc1far - bc2far ) );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tif ( alpha2 < alpha1 ) {\r\n\r\n\t\t\t\t// The line segment spans two boundaries, but is outside both of them.\r\n\t\t\t\t// (This can't happen when we're only clipping against just near/far but good\r\n\t\t\t\t//  to leave the check here for future usage if other clip planes are added.)\r\n\t\t\t\treturn false;\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\t// Update the s1 and s2 vertices to match the clipped line segment.\r\n\t\t\t\ts1.lerp( s2, alpha1 );\r\n\t\t\t\ts2.lerp( s1, 1 - alpha2 );\r\n\r\n\t\t\t\treturn true;\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n};\r\n","// This THREEx helper makes it easy to handle the mouse events in your 3D scene\r\n//\r\n// * CHANGES NEEDED\r\n//   * handle drag/drop\r\n//   * notify events not object3D - like DOM\r\n//     * so single object with property\r\n//   * DONE bubling implement bubling/capturing\r\n//   * DONE implement event.stopPropagation()\r\n//   * DONE implement event.type = \"click\" and co\r\n//   * DONE implement event.target\r\n//\r\n// # Lets get started\r\n//\r\n// First you include it in your page\r\n//\r\n// ```<script src='threex.domevent.js'></script>```\r\n//\r\n// # use the object oriented api\r\n//\r\n// You bind an event like this\r\n// \r\n// ```mesh.on('click', function(object3d){ ... })```\r\n//\r\n// To unbind an event, just do\r\n//\r\n// ```mesh.off('click', function(object3d){ ... })```\r\n//\r\n// As an alternative, there is another naming closer DOM events.\r\n// Pick the one you like, they are doing the same thing\r\n//\r\n// ```mesh.addEventListener('click', function(object3d){ ... })```\r\n// ```mesh.removeEventListener('click', function(object3d){ ... })```\r\n//\r\n// # Supported Events\r\n//\r\n// Always in a effort to stay close to usual pratices, the events name are the same as in DOM.\r\n// The semantic is the same too.\r\n// Currently, the available events are\r\n// [click, dblclick, mouseup, mousedown](http://www.quirksmode.org/dom/events/click.html),\r\n// [mouseover and mouse out](http://www.quirksmode.org/dom/events/mouseover.html).\r\n//\r\n// # use the standalone api\r\n//\r\n// The object-oriented api modifies THREE.Object3D class.\r\n// It is a global class, so it may be legitimatly considered unclean by some people.\r\n// If this bother you, simply do ```THREEx.DomEvent.noConflict()``` and use the\r\n// standalone API. In fact, the object oriented API is just a thin wrapper\r\n// on top of the standalone API.\r\n//\r\n// First, you instanciate the object\r\n//\r\n// ```var domEvent = new THREEx.DomEvent();```\r\n// \r\n// Then you bind an event like this\r\n//\r\n// ```domEvent.bind(mesh, 'click', function(object3d){ object3d.scale.x *= 2; });```\r\n//\r\n// To unbind an event, just do\r\n//\r\n// ```domEvent.unbind(mesh, 'click', callback);```\r\n//\r\n// \r\n// # Code\r\n\r\n//\r\n\r\n/** @namespace */\r\nvar THREEx\t\t= THREEx \t\t|| {};\r\n\r\n// # Constructor\r\nTHREEx.DomEvent\t= function(camera)\r\n{\r\n\tthis._camera\t= camera || null;\r\n\tthis._domElement= null;\r\n\tthis._projector\t= new THREE.Projector();\r\n\tthis._selected\t= null;\r\n\tthis._boundObjs\t= {};\r\n\tthis.setBoundContext('_');\r\n\tthis.mouseIsDown = false;\r\n\tthis.mouseDragNotified = false;\r\n\tthis.lastDownTime = 0;\r\n\r\n\t// Bind dom event for mouse and touch\r\n\tvar _this\t= this;\r\n\t//this._$onClick\t\t= function(){ _this._onClick.apply(_this, arguments);\t\t};\r\n\t//this._$onDblClick\t= function(){ _this._onDblClick.apply(_this, arguments);\t};\r\n\tthis._$onMouseMove\t= function(){ _this._onMouseMove.apply(_this, arguments);\t};\r\n\tthis._$onMouseDown\t= function(){ _this._onMouseDown.apply(_this, arguments);\t};\r\n\tthis._$onMouseUp\t= function(){ _this._onMouseUp.apply(_this, arguments);\t\t};\r\n\tthis._$onTouchMove\t= function(){ _this._onTouchMove.apply(_this, arguments);\t};\r\n\tthis._$onTouchStart\t= function(){ _this._onTouchStart.apply(_this, arguments);\t};\r\n\tthis._$onTouchEnd\t= function(){ _this._onTouchEnd.apply(_this, arguments);\t};\r\n}\r\n\r\nTHREEx.DomEvent.prototype.setDOMElement = function(domElement) {\r\n\tif(this._domElement)\r\n\t\tthis.unsetDOMElement();\r\n\tthis._domElement=domElement;\r\n\t//this._domElement.addEventListener( 'click'\t, this._$onClick\t, false );\r\n\t//this._domElement.addEventListener( 'dblclick'\t, this._$onDblClick\t, false );\r\n\tthis._domElement.addEventListener( 'mousemove'\t, this._$onMouseMove\t, false );\r\n\tthis._domElement.addEventListener( 'mousedown'\t, this._$onMouseDown\t, false );\r\n\tthis._domElement.addEventListener( 'mouseup'\t, this._$onMouseUp\t, false );\r\n\tthis._domElement.addEventListener( 'touchmove'\t, this._$onTouchMove\t, false );\r\n\tthis._domElement.addEventListener( 'touchstart'\t, this._$onTouchStart\t, false );\r\n\tthis._domElement.addEventListener( 'touchend'\t, this._$onTouchEnd\t, false );\r\n}\r\n\r\nTHREEx.DomEvent.prototype.unsetDOMElement = function() {\r\n\tif(this._domElement) {\r\n\t\t//this._domElement.removeEventListener( 'click'\t\t, this._$onClick\t, false );\r\n\t\t//this._domElement.removeEventListener( 'dblclick'\t, this._$onDblClick\t, false );\r\n\t\tthis._domElement.removeEventListener( 'mousemove'\t, this._$onMouseMove\t, false );\r\n\t\tthis._domElement.removeEventListener( 'mousedown'\t, this._$onMouseDown\t, false );\r\n\t\tthis._domElement.removeEventListener( 'mouseup'\t\t, this._$onMouseUp\t, false );\r\n\t\tthis._domElement.removeEventListener( 'touchmove'\t, this._$onTouchMove\t, false );\r\n\t\tthis._domElement.removeEventListener( 'touchstart'\t, this._$onTouchStart\t, false );\r\n\t\tthis._domElement.removeEventListener( 'touchend'\t, this._$onTouchEnd\t, false );\r\n\t\tthis._domElement=null;\r\n\t}\r\n}\r\n\r\nTHREEx.DomEvent.prototype.setBoundContext = function(boundContext) {\r\n\tthis._boundContext=boundContext;\r\n\tif(this._boundObjs[boundContext]===undefined)\r\n\t\tthis._boundObjs[boundContext]=[];\r\n}\r\n\r\nTHREEx.DomEvent.prototype.unsetBoundContext = function(boundContext) {\r\n\tif(this._boundObjs[boundContext]!==undefined) {\r\n\t\tvar boundObjs=this._boundObjs[boundContext];\r\n\t\tfor(var i=0;i<boundObjs.length;i++) {\r\n\t\t\tvar object3d=boundObjs[i];\r\n\t\t\tif(object3d._3xDomEvent) {\r\n\t\t\t\tfor(var f in object3d._3xDomEvent) {\r\n\t\t\t\t\tvar m=/^(.*)Handlers$/.exec(f);\r\n\t\t\t\t\tif(m) {\r\n\t\t\t\t\t\tvar event=m[1];\r\n\t\t\t\t\t\tvar handlers=object3d._3xDomEvent[f];\r\n\t\t\t\t\t\tfor(var j=0;j<handlers.length;j++) {\r\n\t\t\t\t\t\t\tvar handler=handlers[j];\r\n\t\t\t\t\t\t\tthis.unbind(object3d,event,handler.callback,handler.useCapture);\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n}\r\n\r\n\r\n// # Destructor\r\nTHREEx.DomEvent.prototype.destroy\t= function()\r\n{\r\n\tfor(var bc in this._boundObjs)\r\n\t\tthis.unsetBoundContext(bc);\r\n\t\r\n\t// unBind dom event for mouse and touch\r\n\tthis.unsetDOMElement();\r\n}\r\n\r\nTHREEx.DomEvent.eventNames\t= [\r\n\t//\"click\",\r\n\t//\"dblclick\",\r\n\t//\"holdclick\",\r\n\t//\"mouseover\",\r\n\t//\"mouseout\",\r\n\t\"mousedown\",\r\n\t\"mouseup\",\r\n\t\"mousemove\",\r\n\t\"touchmove\",\r\n\t\"touchstart\",\r\n\t\"touchend\",\r\n];\r\n\r\n/********************************************************************************/\r\n/*\t\tdomevent context\t\t\t\t\t\t*/\r\n/********************************************************************************/\r\n\r\n// handle domevent context in object3d instance\r\n\r\nTHREEx.DomEvent.prototype._objectCtxInit\t= function(object3d){\r\n\tobject3d._3xDomEvent = {};\r\n}\r\nTHREEx.DomEvent.prototype._objectCtxDeinit\t= function(object3d){\r\n\tdelete object3d._3xDomEvent;\r\n}\r\nTHREEx.DomEvent.prototype._objectCtxIsInit\t= function(object3d){\r\n\treturn object3d._3xDomEvent ? true : false;\r\n}\r\nTHREEx.DomEvent.prototype._objectCtxGet\t= function(object3d){\r\n\treturn object3d._3xDomEvent;\r\n}\r\n\r\n/********************************************************************************/\r\n/*\t\t\t\t\t\t\t\t\t\t*/\r\n/********************************************************************************/\r\n\r\n/**\r\n * Getter/Setter for camera\r\n*/\r\nTHREEx.DomEvent.prototype.camera\t= function(value)\r\n{\r\n\tif( value )\tthis._camera\t= value;\r\n\treturn this._camera;\r\n}\r\n\r\nTHREEx.DomEvent.prototype.bind\t= function(object3d, eventName, callback, useCapture)\r\n{\r\n\tvar $this=this;\r\n\tconsole.assert( THREEx.DomEvent.eventNames.indexOf(eventName) !== -1, \"not available events:\"+eventName );\r\n\r\n\tif( !this._objectCtxIsInit(object3d) )\tthis._objectCtxInit(object3d);\r\n\tvar objectCtx\t= this._objectCtxGet(object3d);\t\r\n\tif( !objectCtx[eventName+'Handlers'] )\tobjectCtx[eventName+'Handlers']\t= [];\r\n\r\n\tobjectCtx[eventName+'Handlers'].push({\r\n\t\tcallback\t: callback,\r\n\t\tuseCapture\t: useCapture\r\n\t});\r\n\t\r\n\tfunction AddToBoundObjs(object3d) {\r\n\t\t$this._boundObjs[$this._boundContext].push(object3d);\r\n\t\tfor(var i=0;i<object3d.children.length;i++)\r\n\t\t\tAddToBoundObjs(object3d.children[i]);\r\n\t}\r\n\t\r\n\t// add this object in this._boundObjs\r\n\tAddToBoundObjs(object3d);\r\n\t//console.log(\"boundObjs\",this._boundObjs)\r\n}\r\n\r\nTHREEx.DomEvent.prototype.unbind\t= function(object3d, eventName, callback)\r\n{\r\n\tvar $this=this;\r\n\tconsole.assert( THREEx.DomEvent.eventNames.indexOf(eventName) !== -1, \"not available events:\"+eventName );\r\n\r\n\tif( !this._objectCtxIsInit(object3d) )\tthis._objectCtxInit(object3d);\r\n\r\n\tvar objectCtx\t= this._objectCtxGet(object3d);\r\n\tif( !objectCtx[eventName+'Handlers'] )\tobjectCtx[eventName+'Handlers']\t= [];\r\n\r\n\tfunction RemoveFromBoundObjs(object3d) {\r\n\t\tvar index = $this._boundObjs[$this._boundContext].indexOf(object3d);\r\n\t\tif(index>=0)\r\n\t\t\t$this._boundObjs[$this._boundContext].splice(index, 1);\r\n\t\tfor(var i=0;i<object3d.children.length;i++)\r\n\t\t\tRemoveFromBoundObjs(object3d.children[i]);\r\n\t}\r\n\t\r\n\tvar handlers\t= objectCtx[eventName+'Handlers'];\r\n\tfor(var i = 0; i < handlers.length; i++){\r\n\t\tvar handler\t= handlers[i];\r\n\t\tif( callback && callback != handler.callback )\tcontinue;\r\n\t\t//if( useCapture != handler.useCapture )\tcontinue;\r\n\t\thandlers.splice(i, 1)\r\n\t\t// from this object from this._boundObjs\r\n\t\tRemoveFromBoundObjs(object3d);\r\n\t\tbreak;\r\n\t}\r\n}\r\n\r\nTHREEx.DomEvent.prototype._bound\t= function(eventName, object3d)\r\n{\r\n\tvar objectCtx\t= this._objectCtxGet(this.getRootObject(object3d));\r\n\tif( !objectCtx )\treturn false;\r\n\treturn objectCtx[eventName+'Handlers'] ? true : false;\r\n}\r\n\r\nTHREEx.DomEvent.prototype.getRootObject = function(object3d) {\r\n\tvar object3d0=object3d;\r\n\twhile(object3d && !object3d._3xDomEvent)\r\n\t\tobject3d=object3d.parent;\r\n\tif(!object3d)\r\n\t\tconsole.error(\"Could not find root object for\",object3d0);\r\n\treturn object3d;\r\n}\r\n\r\nTHREEx.DomEvent.prototype.isTHREExTarget = function(clientX, clientY) {\r\n\tvar domElement=$(this._domElement);\r\n\tvar offset=domElement.offset();\r\n\tvar mouseX\t= +((clientX-offset.left) / domElement.width() ) * 2 - 1;\r\n\tvar mouseY\t= -((clientY-offset.top) / domElement.height()) * 2 + 1;\r\n\r\n\tvar vector\t= new THREE.Vector3( mouseX, mouseY, 1 );\r\n\tvector.unproject( this._camera );\r\n\tvar worldPos = new THREE.Vector3();\r\n\tthis._camera.getWorldPosition(worldPos);\r\n\tvector.sub( worldPos ).normalize()\r\n\tvar ray\t\t= new THREE.Raycaster( worldPos, vector );\r\n\tvar intersects\t= ray.intersectObjects( this._boundObjs[this._boundContext] );\r\n\treturn intersects.length !== 0;\r\n}\r\n\r\nTHREEx.DomEvent.prototype.lockObject = function(event,enableDrag) {\r\n\tif(/^mouse/.test(event.type) && event.button!=0)\r\n\t\treturn false;\r\n\tvar domElement=$(this._domElement);\r\n\tvar offset=domElement.offset();\r\n\tvar x, y;\r\n\tif(event.clientX!==undefined && event.clientY!==undefined) {\r\n\t\tx = event.clientX;\r\n\t\ty = event.clientY;\r\n\t} else if(event.touches && event.touches.length>0) {\r\n\t\tx = event.touches[0].pageX;\r\n\t\ty = event.touches[0].pageY;\r\n\t} else if(event.changedTouches && event.changedTouches.length>0) {\r\n\t\tx = event.changedTouches[0].pageX;\r\n\t\ty = event.changedTouches[0].pageY;\r\n\t} else {\r\n\t\tconsole.warn(\"Unable to get event position\");\r\n\t\treturn false;\r\n\t}\r\n\t\t\r\n\tvar mouseX\t= +((x-offset.left) / domElement.width() ) * 2 - 1;\r\n\tvar mouseY\t= -((y-offset.top) / domElement.height()) * 2 + 1;\r\n\t\r\n\tvar vector\t= new THREE.Vector3( mouseX, mouseY, 1 );\r\n\tvector.unproject( this._camera );\r\n    var worldPos = new THREE.Vector3();\r\n    this._camera.getWorldPosition(worldPos);\r\n    //vector.sub( this._camera.position ).normalize()\r\n    vector.sub( worldPos ).normalize()\r\n\tvar ray\t\t= new THREE.Raycaster( worldPos, vector );\r\n\tvar intersects\t= ray.intersectObjects( this._boundObjs[this._boundContext] );\r\n\tthis.objectLocked = intersects.length !== 0;\r\n\tthis.enableDrag = this.objectLocked && enableDrag;\r\n\treturn this.objectLocked;\r\n}\r\n\r\n/********************************************************************************/\r\n/*\t\tonEvent\t\t\t\t\t\t\t\t*/\r\n/********************************************************************************/\r\n\r\n// # handle click kind of events\r\n\r\nTHREEx.DomEvent.prototype._onEvent\t= function(eventName, mouseX, mouseY, origDomEvent, eventX, eventY)\r\n{\r\n\t//console.log(\"_onEvent\",eventName,mouseX,mouseY);\r\n\r\n\tif(eventName==\"mouseup\") {\r\n\t\tthis.mouseIsDown = false;\t\t\r\n\t\tif(!this.objectLocked)\r\n\t\t\treturn null;\r\n\t} else if(eventName==\"mousedown\") {\r\n\t\tthis.mouseIsDown = true;\r\n\t\tthis.mouseDownPos = [eventX, eventY];\r\n\t\tthis.mouseDragNotified = false;\r\n\t\tthis.lastDownTime = Date.now();\r\n\t} else if(eventName==\"mousemove\") {\r\n\t\tif(this.mouseIsDown) {\r\n\t\t\tvar dx = this.mouseDownPos[0] - eventX;\r\n\t\t\tvar dy = this.mouseDownPos[1] - eventY;\r\n\t\t\tvar distSq = dx * dx + dy * dy;\r\n\t\t\tif(this.enableDrag) {\r\n\t\t\t\tif(distSq < 100)\r\n\t\t\t\t\treturn null;\r\n\t\t\t\tif(!this.mouseDragNotified) {\r\n\t\t\t\t\tif(Date.now()-this.lastDownTime<50)\r\n\t\t\t\t\t\treturn null;\r\n\t\t\t\t\tthis.mouseDragNotified = true;\r\n\t\t\t\t\treturn this._onEvent(\"mouseup\", this.mouseEventPos[0], this.mouseEventPos[1], origDomEvent, eventX, eventY);\r\n\t\t\t\t}\r\n\t\t\t} else {\r\n\t\t\t\tif(distSq > 100) {\r\n\t\t\t\t\tthis.objectLocked = false;\r\n\t\t\t\t\treturn null;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\tvar vector\t= new THREE.Vector3( mouseX, mouseY, 1 );\r\n\tvector.unproject( this._camera );\r\n    var worldPos = new THREE.Vector3();\r\n    this._camera.getWorldPosition(worldPos);\r\n\tvector.sub( worldPos ).normalize()\r\n\tvar ray\t\t= new THREE.Raycaster( worldPos, vector );\r\n\tvar intersects\t= ray.intersectObjects( this._boundObjs[this._boundContext] );\r\n\t\r\n\t//console.log(\"camera\",this._camera.position,\"ray\",ray,\"bound\",this._boundObjs)\r\n\r\n\t// if there are no intersections, return now\r\n\tif( intersects.length === 0 )\t{\r\n\t\t//console.warn(\"THREEx\",eventName,\"No hit\");\r\n\t\treturn null;\r\n\t}\r\n\t\r\n\t// init some vairables\r\n\tvar intersect\t= intersects[0];\r\n\tvar object3d\t= this.getRootObject(intersect.object);\r\n\tvar objectCtx\t= this._objectCtxGet(object3d);\r\n\tif( !objectCtx )\treturn null;\r\n\r\n\t// notify handlers\r\n\tthis._notify(eventName, object3d, origDomEvent, intersect.point);\r\n}\r\n\r\nTHREEx.DomEvent.prototype._notify\t= function(eventName, object3d, origDomEvent, point)\r\n{\r\n\t//console.log(\"notify\",eventName,\"to\",object3d.id)\r\n\tvar objectCtx\t= this._objectCtxGet(object3d);\r\n\tvar handlers\t= objectCtx ? objectCtx[eventName+'Handlers'] : null;\r\n\r\n\t// do bubbling\r\n\tif( !objectCtx || !handlers || handlers.length === 0 ) {\r\n\t\tif(object3d.parent)\r\n\t\t\tthis._notify(eventName, object3d.parent);\r\n\t\treturn;\r\n\t}\r\n\t\r\n\t// notify all handlers\r\n\tvar handlers\t= objectCtx[eventName+'Handlers'];\r\n\tfor(var i = 0; i < handlers.length; i++){\r\n\t\tvar handler\t= handlers[i];\r\n\t\tvar toPropagate\t= true;\r\n\t\thandler.callback({\r\n\t\t\ttype\t\t: eventName,\r\n\t\t\ttarget\t\t: object3d,\r\n\t\t\torigDomEvent\t: origDomEvent,\r\n\t\t\tstopPropagation\t: function(){\r\n\t\t\t\ttoPropagate\t= false;\r\n\t\t\t},\r\n\t\t\tpoint: point\r\n\t\t});\r\n\t\tif( !toPropagate )\tcontinue;\r\n\t\t// do bubbling\r\n\t\tif( handler.useCapture === false ){\r\n\t\t\tobject3d.parent && this._notify(eventName, object3d.parent, origDomEvent, point);\r\n\t\t}\r\n\t}\r\n}\r\n\r\n/********************************************************************************/\r\n/*\t\thandle mouse events\t\t\t\t\t\t*/\r\n/********************************************************************************/\r\n// # handle mouse events\r\n\r\n//THREEx.DomEvent.longClickTimer=null;\r\n\r\nTHREEx.DomEvent.prototype._onMouseDown\t= function(event) {\r\n\t//console.log(\"_onMouseDown\",event.type)\r\n\tvar $this=this;\r\n\t\r\n\tif(event.button!==0)\r\n\t\treturn;\r\n\t/*\r\n\tif(THREEx.DomEvent.longClickTimer)\r\n\t\tclearTimeout(THREEx.DomEvent.longClickTimer);\r\n\tTHREEx.DomEvent.longClickTimer=setTimeout(function() {\r\n\t\tTHREEx.DomEvent.longClickTimer=null;\r\n\t\t$this._onMouseEvent('holdclick', event);\r\n\t},500);\r\n\t*/\r\n\treturn this._onMouseEvent('mousedown', event);\t\r\n}\r\nTHREEx.DomEvent.prototype._onMouseUp\t= function(event) {\r\n\r\n\tif(event.button!==0)\r\n\t\treturn;\r\n\r\n\t//console.log(\"_onMouseUp\",event.type)\r\n\t/*\r\n\tif(THREEx.DomEvent.longClickTimer) {\r\n\t\tclearTimeout(THREEx.DomEvent.longClickTimer);\r\n\t\tTHREEx.DomEvent.longClickTimer=null;\r\n\t}\r\n\t*/\r\n\treturn this._onMouseEvent('mouseup'\t, event);\t\r\n}\r\n\r\nTHREEx.DomEvent.prototype._onMouseMove\t= function(event)\r\n{\r\n\t//console.log(\"_onMouseMove\",event.type)\r\n\tif(!this.mouseIsDown)\r\n\t\treturn null;\r\n\t/*\r\n\tif(THREEx.DomEvent.longClickTimer) {\r\n\t\tclearTimeout(THREEx.DomEvent.longClickTimer);\r\n\t\tTHREEx.DomEvent.longClickTimer = null;\r\n\t}\r\n\t*/\r\n\treturn this._onMouseEvent('mousemove', event);\t\r\n}\r\n\r\nTHREEx.DomEvent.prototype._onMouseEvent\t= function(eventName, domEvent)\r\n{\r\n\tvar domElement=$(this._domElement);\r\n\tvar offset=domElement.offset();\r\n\tvar mouseX\t= +((domEvent.clientX-offset.left) / domElement.width() ) * 2 - 1;\r\n\tvar mouseY\t= -((domEvent.clientY-offset.top) / domElement.height()) * 2 + 1;\r\n\tthis.mouseEventPos = [ mouseX, mouseY ];\r\n\treturn this._onEvent(eventName, mouseX, mouseY, domEvent, domEvent.clientX-offset.left, domEvent.clientY-offset.top);\r\n}\r\n\r\n/*\r\nTHREEx.DomEvent.prototype._onClick\t\t= function(event)\r\n{\r\n\t// TODO handle touch ?\r\n\treturn this._onMouseEvent('click'\t, event);\r\n}\r\nTHREEx.DomEvent.prototype._onDblClick\t\t= function(event)\r\n{\r\n\t// TODO handle touch ?\r\n\treturn this._onMouseEvent('dblclick'\t, event);\r\n}\r\n*/\r\n\r\n/********************************************************************************/\r\n/*\t\thandle touch events\t\t\t\t\t\t*/\r\n/********************************************************************************/\r\n// # handle touch events\r\n\r\n\r\nTHREEx.DomEvent.prototype._onTouchStart\t= function(event){ return this._onTouchEvent('mousedown', event);\t}\r\nTHREEx.DomEvent.prototype._onTouchEnd\t= function(event){ return this._onTouchEvent('mouseup'\t, event);\t}\r\nTHREEx.DomEvent.prototype._onTouchMove\t= function(event){ \t\r\n\tif(!this.mouseIsDown) \r\n\t\treturn null; \r\n\telse \r\n\t\treturn this._onTouchEvent('mousemove', event);\t\r\n}\r\n\r\n/*\r\nTHREEx.DomEvent.prototype._onTouchMove\t= function(domEvent)\r\n{\r\n\tif( domEvent.touches.length != 1 )\treturn undefined;\r\n\r\n\tdomEvent.preventDefault();\r\n\r\n\tvar mouseX\t= +(domEvent.touches[ 0 ].pageX / window.innerWidth ) * 2 - 1;\r\n\tvar mouseY\t= -(domEvent.touches[ 0 ].pageY / window.innerHeight) * 2 + 1;\r\n\treturn this._onMove('mousemove', mouseX, mouseY, domEvent);\r\n}\r\n*/\r\n\r\nTHREEx.DomEvent.prototype._onTouchEvent\t= function(eventName, domEvent)\r\n{\r\n\tvar domElement=$(this._domElement);\r\n\tvar offset=domElement.offset();\r\n\tvar mouseX=0, mouseY=0, eventX=0, eventY=0;\r\n\tif(domEvent.touches && domEvent.touches.length>0) {\r\n\t\tmouseX\t= +((domEvent.touches[0].clientX-offset.left) / domElement.width() ) * 2 - 1;\r\n\t\tmouseY\t= -((domEvent.touches[0].clientY-offset.top) / domElement.height()) * 2 + 1;\r\n\t\teventX = domEvent.touches[0].clientX-offset.left;\r\n\t\teventY = domEvent.touches[0].clientY-offset.top;\r\n\t} else if(domEvent.changedTouches && domEvent.changedTouches.length>0) {\r\n\t\tmouseX\t= +((domEvent.changedTouches[0].clientX-offset.left) / domElement.width() ) * 2 - 1;\r\n\t\tmouseY\t= -((domEvent.changedTouches[0].clientY-offset.top) / domElement.height()) * 2 + 1;\r\n\t\teventX = domEvent.changedTouches[0].clientX-offset.left;\r\n\t\teventY = domEvent.changedTouches[0].clientY-offset.top;\r\n\t}\r\n\tthis.mouseEventPos = [ mouseX, mouseY ];\r\n\treturn this._onEvent(eventName, mouseX, mouseY, domEvent, eventX, eventY);\r\n}\r\n\r\n","/********************************************************************************/\r\n// # Patch THREE.Object3D\r\n/********************************************************************************/\r\n\r\n// handle noConflit.\r\nTHREEx.DomEvent.noConflict\t= function(){\r\n\tTHREEx.DomEvent.noConflict.symbols.forEach(function(symbol){\r\n\t\tTHREE.Object3D.prototype[symbol]\t= THREEx.DomEvent.noConflict.previous[symbol]\r\n\t})\r\n}\r\n// Backup previous values to restore them later if needed.\r\nTHREEx.DomEvent.noConflict.symbols\t= ['on', 'off', 'addEventListener', 'removeEventListener'];\r\nTHREEx.DomEvent.noConflict.previous\t= {};\r\nTHREEx.DomEvent.noConflict.symbols.forEach(function(symbol){\r\n\tTHREEx.DomEvent.noConflict.previous[symbol]\t= THREE.Object3D.prototype[symbol]\r\n})\r\n\r\n// begin the actual patching of THREE.Object3D\r\n\r\n// create the global instance of THREEx.DomEvent\r\n//THREE.Object3D._threexDomEvent\t= new THREEx.DomEvent();\r\n\r\n// # wrap mouseevents.bind()\r\nTHREE.Object3D.prototype._addEventListener = THREE.Object3D.prototype.addEventListener;\r\nTHREE.Object3D.prototype.on\t=\r\nTHREE.Object3D.prototype.addEventListener = function(eventName, callback){\r\n\tTHREE.Object3D._threexDomEvent.bind(this, eventName, callback);\r\n\treturn this;\r\n}\r\n\r\n// # wrap mouseevents.unbind()\r\nTHREE.Object3D.prototype._removeEventListener = THREE.Object3D.prototype.removeEventListener;\r\nTHREE.Object3D.prototype.off\t=\r\nTHREE.Object3D.prototype.removeEventListener\t= function(eventName, callback){\r\n\tTHREE.Object3D._threexDomEvent.unbind(this, eventName, callback);\r\n\treturn this;\r\n}\r\n","/**\r\n * @author alteredq / http://alteredqualia.com/\r\n * @authod mrdoob / http://mrdoob.com/\r\n * @authod arodic / http://aleksandarrodic.com/\r\n * @authod fonserbc / http://fonserbc.github.io/\r\n*/\r\n\r\nTHREE.StereoEffect = function ( renderer ) {\r\n\r\n\tvar _stereo = new THREE.StereoCamera();\r\n\t_stereo.aspect = 0.5;\r\n\r\n\tthis.setEyeSeparation = function ( eyeSep ) {\r\n\r\n\t\t_stereo.eyeSep = eyeSep;\r\n\r\n\t};\r\n\r\n\tthis.setSize = function ( width, height ) {\r\n\r\n\t\trenderer.setSize( width, height );\r\n\r\n\t};\r\n\r\n\tthis.render = function ( scene, camera ) {\r\n\r\n\t\tscene.updateMatrixWorld();\r\n\r\n\t\tif ( camera.parent === null ) camera.updateMatrixWorld();\r\n\r\n\t\t_stereo.update( camera );\r\n\r\n\t\tvar size = renderer.getSize();\r\n\r\n\t\tif ( renderer.autoClear ) renderer.clear();\r\n\t\trenderer.setScissorTest( true );\r\n\r\n\t\trenderer.setScissor( 0, 0, size.width / 2, size.height );\r\n\t\trenderer.setViewport( 0, 0, size.width / 2, size.height );\r\n\t\trenderer.render( scene, _stereo.cameraL );\r\n\r\n\t\trenderer.setScissor( size.width / 2, 0, size.width / 2, size.height );\r\n\t\trenderer.setViewport( size.width / 2, 0, size.width / 2, size.height );\r\n\t\trenderer.render( scene, _stereo.cameraR );\r\n\r\n\t\trenderer.setScissorTest( false );\r\n\r\n\t};\r\n\r\n};\r\n","/**\r\n * @author mrdoob / http://mrdoob.com/\r\n * @author marklundin / http://mark-lundin.com/\r\n * @author alteredq / http://alteredqualia.com/\r\n * @author tschw\r\n */\r\n\r\nTHREE.AnaglyphEffect = function ( renderer, width, height ) {\r\n\r\n\t// Matrices generated with angler.js https://github.com/tschw/angler.js/\r\n\t// (in column-major element order, as accepted by WebGL)\r\n\r\n\tthis.colorMatrixLeft = new THREE.Matrix3().fromArray( [\r\n\r\n\t\t\t1.0671679973602295, \t-0.0016435992438346148,\t\t 0.0001777536963345483, // r out\r\n\t\t\t-0.028107794001698494,\t-0.00019593400065787137,\t-0.0002875397040043026, // g out\r\n\t\t\t-0.04279090091586113,\t 0.000015809757314855233,\t-0.00024287120322696865 // b out\r\n\r\n\t] );\r\n\r\n\t//\t\tred\t\t\t\t\t\tgreen \t\t\t\t\t\tblue  \t\t\t\t\t\tin\r\n\r\n\tthis.colorMatrixRight = new THREE.Matrix3().fromArray( [\r\n\r\n\t\t\t-0.0355340838432312,\t-0.06440307199954987,\t\t 0.018319187685847282,\t// r out\r\n\t\t\t-0.10269022732973099,\t 0.8079727292060852,\t\t-0.04835830628871918,\t// g out\r\n\t\t\t0.0001224992738571018,\t-0.009558862075209618,\t\t 0.567823588848114\t\t// b out\r\n\r\n\t] );\r\n\r\n\tvar _camera = new THREE.OrthographicCamera( - 1, 1, 1, - 1, 0, 1 );\r\n\r\n\tvar _scene = new THREE.Scene();\r\n\r\n\tvar _stereo = new THREE.StereoCamera();\r\n\r\n\tvar _params = { minFilter: THREE.LinearFilter, magFilter: THREE.NearestFilter, format: THREE.RGBAFormat };\r\n\r\n\tif ( width === undefined ) width = 512;\r\n\tif ( height === undefined ) height = 512;\r\n\r\n\tvar _renderTargetL = new THREE.WebGLRenderTarget( width, height, _params );\r\n\tvar _renderTargetR = new THREE.WebGLRenderTarget( width, height, _params );\r\n\r\n\tvar _material = new THREE.ShaderMaterial( {\r\n\r\n\t\tuniforms: {\r\n\r\n\t\t\t\"mapLeft\": { value: _renderTargetL.texture },\r\n\t\t\t\"mapRight\": { value: _renderTargetR.texture },\r\n\r\n\t\t\t\"colorMatrixLeft\": { value: this.colorMatrixLeft },\r\n\t\t\t\"colorMatrixRight\": { value: this.colorMatrixRight }\r\n\r\n\t\t},\r\n\r\n\t\tvertexShader: [\r\n\r\n\t\t\t\"varying vec2 vUv;\",\r\n\r\n\t\t\t\"void main() {\",\r\n\r\n\t\t\t\"\tvUv = vec2( uv.x, uv.y );\",\r\n\t\t\t\"\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\",\r\n\r\n\t\t\t\"}\"\r\n\r\n\t\t].join( \"\\n\" ),\r\n\r\n\t\tfragmentShader: [\r\n\r\n\t\t\t\"uniform sampler2D mapLeft;\",\r\n\t\t\t\"uniform sampler2D mapRight;\",\r\n\t\t\t\"varying vec2 vUv;\",\r\n\r\n\t\t\t\"uniform mat3 colorMatrixLeft;\",\r\n\t\t\t\"uniform mat3 colorMatrixRight;\",\r\n\r\n\t\t\t// These functions implement sRGB linearization and gamma correction\r\n\r\n\t\t\t\"float lin( float c ) {\",\r\n\t\t\t\"\treturn c <= 0.04045 ? c * 0.0773993808 :\",\r\n\t\t\t\"\t\t\tpow( c * 0.9478672986 + 0.0521327014, 2.4 );\",\r\n\t\t\t\"}\",\r\n\r\n\t\t\t\"vec4 lin( vec4 c ) {\",\r\n\t\t\t\"\treturn vec4( lin( c.r ), lin( c.g ), lin( c.b ), c.a );\",\r\n\t\t\t\"}\",\r\n\r\n\t\t\t\"float dev( float c ) {\",\r\n\t\t\t\"\treturn c <= 0.0031308 ? c * 12.92\",\r\n\t\t\t\"\t\t\t: pow( c, 0.41666 ) * 1.055 - 0.055;\",\r\n\t\t\t\"}\",\r\n\r\n\r\n\t\t\t\"void main() {\",\r\n\r\n\t\t\t\"\tvec2 uv = vUv;\",\r\n\r\n\t\t\t\"\tvec4 colorL = lin( texture2D( mapLeft, uv ) );\",\r\n\t\t\t\"\tvec4 colorR = lin( texture2D( mapRight, uv ) );\",\r\n\r\n\t\t\t\"\tvec3 color = clamp(\",\r\n\t\t\t\"\t\t\tcolorMatrixLeft * colorL.rgb +\",\r\n\t\t\t\"\t\t\tcolorMatrixRight * colorR.rgb, 0., 1. );\",\r\n\r\n\t\t\t\"\tgl_FragColor = vec4(\",\r\n\t\t\t\"\t\t\tdev( color.r ), dev( color.g ), dev( color.b ),\",\r\n\t\t\t\"\t\t\tmax( colorL.a, colorR.a ) );\",\r\n\r\n\t\t\t\"}\"\r\n\r\n\t\t].join( \"\\n\" )\r\n\r\n\t} );\r\n\r\n\tvar mesh = new THREE.Mesh( new THREE.PlaneBufferGeometry( 2, 2 ), _material );\r\n\t_scene.add( mesh );\r\n\r\n\tthis.setSize = function ( width, height ) {\r\n\r\n\t\trenderer.setSize( width, height );\r\n\r\n\t\tvar pixelRatio = renderer.getPixelRatio();\r\n\r\n\t\t_renderTargetL.setSize( width * pixelRatio, height * pixelRatio );\r\n\t\t_renderTargetR.setSize( width * pixelRatio, height * pixelRatio );\r\n\r\n\t};\r\n\r\n\tthis.render = function ( scene, camera ) {\r\n\r\n\t\tscene.updateMatrixWorld();\r\n\r\n\t\tif ( camera.parent === null ) camera.updateMatrixWorld();\r\n\r\n\t\t_stereo.update( camera );\r\n\r\n\t\trenderer.render( scene, _stereo.cameraL, _renderTargetL, true );\r\n\t\trenderer.render( scene, _stereo.cameraR, _renderTargetR, true );\r\n\t\trenderer.render( _scene, _camera );\r\n\r\n\t};\r\n\r\n\tthis.dispose = function() {\r\n\r\n\t\tif ( _renderTargetL ) _renderTargetL.dispose();\r\n\t\tif ( _renderTargetR ) _renderTargetR.dispose();\r\n\r\n\t};\r\n\r\n};\r\n","\r\nfunction VRGamepads(opts) {\r\n    var options = Object.assign({\r\n        drag: function(position,direction) {\r\n            return false;\r\n        },\r\n        click: function(position,direction) {\r\n        },\r\n        reset: function() {\r\n        },\r\n        speed: 10,\r\n        move: function(delta) {\r\n        },\r\n        visionCrosshairAngle: -Math.PI/8,\r\n        movementMin: .2,\r\n    },opts);\r\n\r\n    var harborpad = null;\r\n\r\n    function VRGamepad(gamepad) {\r\n\r\n        THREE.Object3D.call( this );\r\n\r\n        this.matrixAutoUpdate = false;\r\n        this.isVRPad = false;\r\n\r\n        var axes = [];\r\n        var buttons = [];\r\n        var buttonsIndexes = {\r\n            move: -1,\r\n            click: -1,\r\n            reset: -1\r\n        }\r\n\r\n        this.getGamepad = function () {\r\n            return gamepad;\r\n        }\r\n\r\n        this.getButtonState = function ( button ) {\r\n            return false;\r\n        }\r\n\r\n        this.drag = function() {\r\n            var pointer = this.getPointer();\r\n            var progress = this.progressObject;\r\n            var pointed = options.drag(pointer.position,pointer.direction);\r\n            if(pointed) {\r\n                if(this.pointerRescale) {\r\n                    var distance = pointer.position.distanceTo(pointed.point);\r\n                    var thickness = harborpad ? .1 : 1;\r\n                    this.pointerObject.scale.set(thickness,distance,thickness);\r\n                }\r\n                this.pointerObject.material.color.setRGB(0,1,0);\r\n\r\n                if(progress) {\r\n                    var oid = pointed.object.id;\r\n                    if(this.pointedId==oid) {\r\n                        const pointingTime = 2000;\r\n                        var now = Date.now();\r\n                        var ratio = 1-(now-this.pointedTime)/pointingTime;\r\n                        if(ratio<0) {\r\n                            options.click(pointer.position,pointer.direction);\r\n                            this.pointedId = null;\r\n                        } else\r\n                            progress.scale.set(ratio,ratio,ratio);\r\n                    } else {\r\n                        this.pointedId = oid;\r\n                        progress.scale.set(1,1,1);\r\n                        this.pointedTime = Date.now();\r\n                        progress.visible = true;\r\n                    }\r\n                }\r\n            } else {\r\n                this.pointerObject.material.color.setRGB(1,.75,0);\r\n                if(this.pointerRescale) {\r\n                    var thickness = harborpad ? .1 : 1;\r\n                    this.pointerObject.scale.set(thickness,100,thickness);\r\n                }\r\n\r\n                if(progress && this.pointedId) {\r\n                    progress.visible = false;\r\n                    this.pointedId = null;\r\n                }\r\n\r\n            }\r\n        }\r\n\r\n        this.update = function() {\r\n            var $this = this;\r\n\r\n            if(this.crosshairNeedsUpdate) {\r\n                var pointer = this.getPointer();\r\n                this.pointerObject.position.copy(pointer.position);\r\n                this.pointerObject.position.add(pointer.direction);\r\n            }\r\n\r\n            if(this.progressNeedsUpdate) {\r\n                var pointer = this.getPointer();\r\n                this.progressObject.position.copy(pointer.position);\r\n                this.progressObject.position.add(pointer.direction);\r\n            }\r\n\r\n\t\t\tvar pose = gamepad.pose;\r\n            if(pose) {\r\n                if(pose.position)\r\n                    this.position.fromArray(pose.position);\r\n                if(pose.orientation)\r\n                    this.quaternion.fromArray(pose.orientation);\r\n                this.matrix.compose(this.position,this.quaternion,this.scale );\r\n                this.matrixWorldNeedsUpdate = true;\r\n            }\r\n            if(gamepad.buttons) {\r\n                var changedButtons = false;\r\n                gamepad.buttons.forEach(function(button,index) {\r\n                    if(index===buttonsIndexes.click && button.pressed)\r\n                        $this.drag();\r\n                    if(button.pressed!==buttons[index]) {\r\n                        buttons[index] = button.pressed;\r\n                        if(buttons[index]!==undefined) {\r\n                            changedButtons = true;\r\n                            if(index===buttonsIndexes.move)\r\n                                $this.moveButtonChanged(button.pressed);\r\n                            if(index===buttonsIndexes.click)\r\n                                $this.clickButtonChanged(button.pressed);\r\n                            if(index===buttonsIndexes.reset)\r\n                                $this.resetButtonChanged(button.pressed);\r\n                        }\r\n                    }\r\n                });\r\n            }\r\n            if(gamepad.axes) {\r\n                var changedAxes = false;\r\n                gamepad.axes.forEach(function(axe,index) {\r\n                    if(axe!==axes[index]) {\r\n                        axes[index] = axe;\r\n                        changedAxes = true;\r\n                    }\r\n                });\r\n                if(buttonsIndexes.move>=0 && buttons[buttonsIndexes.move]) {\r\n                    var now = window.performance.now();\r\n                    var last = this.lastThumbpadTimestamp;\r\n                    var deltaT = now - last;\r\n                    var rotation = new THREE.Matrix4().extractRotation(this.matrixWorld);\r\n                    var direction = new THREE.Vector3(axes[0],0,-axes[1]).applyMatrix4(rotation);\r\n                    direction.multiplyScalar(options.speed*deltaT/1000);\r\n                    options.move(direction);\r\n                    this.lastThumbpadTimestamp = now;\r\n                }\r\n                if(buttonsIndexes.move<0) {\r\n                    var now = window.performance.now();\r\n                    var movement = new THREE.Vector3(axes[0],0,axes[1]);\r\n                    if(movement.length()>options.movementMin) {\r\n                        var last = this.lastThumbpadTimestamp;\r\n                        var deltaT = now - last;\r\n                        // yeah i know, it could have been simpler\r\n                        var direction = options.camera.getWorldDirection();\r\n                        var xzDirection = new THREE.Vector3(direction.x,0,direction.z);\r\n                        xzDirection.normalize();\r\n                        xzDirection.applyAxisAngle(new THREE.Vector3(0,1,0),-Math.PI/2);\r\n                        var rotateAxis = new THREE.Vector3(xzDirection.x,0,xzDirection.z)\r\n                        rotateAxis.normalize();\r\n                        var rotateAxis2 = new THREE.Vector3().copy(direction);\r\n                        rotateAxis2.applyAxisAngle(rotateAxis,Math.PI/2);\r\n                        var angle = Math.atan2(-axes[0],-axes[1]);\r\n                        direction.applyAxisAngle(rotateAxis2,angle);\r\n                        direction.multiplyScalar(options.speed*deltaT/1000);\r\n                        options.move(direction);\r\n                    }\r\n                    this.lastThumbpadTimestamp = now;\r\n                }\r\n            }\r\n\r\n            if(this.alwaysDrag)\r\n                this.drag();\r\n        }\r\n\r\n        this.getPointer = function() {\r\n            var position = this.getWorldPosition();\r\n            if(gamepad.pose && gamepad.pose.hasOrientation) {\r\n                var line = this.pointerObject;\r\n                var pos0 = new THREE.Vector3(0,0,0);\r\n                pos0.applyMatrix4(line.matrixWorld);\r\n                var direction = new THREE.Vector3(0,-1,0);\r\n                direction.applyMatrix4(line.matrixWorld);\r\n                direction.sub(pos0);\r\n                direction.normalize();\r\n                return {\r\n                    position: position,\r\n                    direction: direction\r\n                }\r\n            } else {\r\n                var position = options.camera.getWorldPosition();\r\n                var direction = options.camera.getWorldDirection();\r\n                position.add(direction);\r\n                return {\r\n                    position: position,\r\n                    direction: direction\r\n                }\r\n            }\r\n        }\r\n\r\n        this.moveButtonChanged = function(on) {\r\n            if(on)\r\n                this.lastThumbpadTimestamp = window.performance.now();\r\n        }\r\n\r\n        this.clickButtonChanged = function(on) {\r\n            if(on)\r\n                this.pointerObject.visible = true;\r\n            else {\r\n                this.pointerObject.visible = false;\r\n                var pointer = this.getPointer();\r\n                options.click(pointer.position,pointer.direction);\r\n            }\r\n        }\r\n\r\n        this.resetButtonChanged = function(on) {\r\n\r\n        }\r\n\r\n        this.destroyGamepad = function() {\r\n            if(this.parent)\r\n                this.parent.remove(this);\r\n            if(this.pointerObject && this.pointerObject.parent)\r\n                this.pointerObject.parent.remove(this.pointerObject);\r\n            if(this.progressObject && this.progressObject.parent)\r\n                this.progressObject.parent.remove(this.progressObject);\r\n        }\r\n\r\n        var cache = {}\r\n\r\n        this.createCrosshair = function() {\r\n            var crosshair = cache[\"crosshair\"];\r\n            if(crosshair===undefined) {\r\n                var geometry = new THREE.SphereGeometry(.02);\r\n                var material = new THREE.MeshBasicMaterial( {color: 0xff0000 } );\r\n                crosshair = new THREE.Mesh(geometry,material);\r\n                cache[\"crosshair\"] = crosshair;\r\n            }\r\n            crosshair = crosshair.clone();\r\n            this.crosshairNeedsUpdate = true;\r\n            this.pointerObject = crosshair;\r\n            options.scene.add(crosshair);\r\n            this.pointerRescale = false;\r\n        }\r\n\r\n        this.createProgress = function() {\r\n            var progress = cache[\"progress\"];\r\n            if(progress===undefined) {\r\n                var geometry = new THREE.SphereGeometry(.2,16,12);\r\n                var material = new THREE.MeshBasicMaterial( {\r\n                    color: 0xff0000,\r\n                    opacity: .5,\r\n                    transparent: true\r\n                } );\r\n                progress = new THREE.Mesh(geometry,material);\r\n                progress.visible = false;\r\n                cache[\"progress\"] = progress;\r\n            }\r\n            progress = progress.clone();\r\n            this.progressNeedsUpdate = true;\r\n            this.progressObject = progress;\r\n            options.scene.add(progress);\r\n        }\r\n\r\n        this.createViveControllerMesh = function() {\r\n\r\n            var $this = this;\r\n            // create clicking ray\r\n            var line = cache[\"vive-controller-ray\"];\r\n            if(line===undefined) {\r\n                var geometry = new THREE.CylinderGeometry(.008,.008,1,8);\r\n                geometry.translate(0,-.5,0);\r\n                var material = new THREE.MeshBasicMaterial( {color: 0x80ff80} );\r\n                line = new THREE.Mesh( geometry, material );\r\n                line.scale.set(1,100,1);\r\n                line.rotateX(Math.PI/6);\r\n                line.visible = false;\r\n                cache[\"vive-controller-ray\"] = line;\r\n            }\r\n            this.pointerObject = line.clone();\r\n            this.add(this.pointerObject);\r\n            this.pointerRescale = true;\r\n\r\n            // create controller\r\n            function AddController(object) {\r\n                $this.add(object);\r\n            }\r\n            var controllerObject = cache[\"vive-controller\"];\r\n            if(controllerObject===undefined) {\r\n                cache[\"vive-controller\"] = [AddController];\r\n                var loader = new THREE.JSONLoader();\r\n                loader.load( options.resBase + 'vive-controller/vr_controller_vive_1_5.js',\r\n                    function(geometry) {\r\n                        var loader = new THREE.TextureLoader();\r\n                        loader.setPath( options.resBase + 'vive-controller/' );\r\n                        var material = new THREE.MeshBasicMaterial({ color: 0xffffff });\r\n                        material.map = loader.load( 'onepointfive_texture.png');\r\n                        material.specularMap = loader.load( 'onepointfive_spec.png');\r\n                        var controller = new THREE.Mesh(geometry,material);\r\n                        var object = new THREE.Object3D();\r\n                        object.add(controller);\r\n                        cache[\"vive-controller\"].forEach(function(callback) {\r\n                            callback(object.clone());\r\n                        });\r\n                        cache[\"vive-controller\"] = object;\r\n                });\r\n            } else if(Array.isArray(controllerObject)) {\r\n                cache[\"vive-controller\"].push(AddController);\r\n            } else\r\n                AddController(controllerObject.clone());\r\n            options.camera.parent.add(this);\r\n        }\r\n\r\n        this.createOculusTouchMesh = function() {\r\n            var $this = this;\r\n            // create clicking ray\r\n            var line = cache[\"touch-controller-ray\"];\r\n            if(line===undefined) {\r\n                var geometry = new THREE.CylinderGeometry(.008,.008,1,8);\r\n                geometry.translate(0,-.5,0);\r\n                var material = new THREE.MeshBasicMaterial( {color: 0x80ff80} );\r\n                line = new THREE.Mesh( geometry, material );\r\n                line.scale.set(1,100,1);\r\n                line.rotateX(Math.PI/6);\r\n                line.visible = false;\r\n                cache[\"touch-controller-ray\"] = line;\r\n            }\r\n            this.pointerObject = line.clone();\r\n            this.add(this.pointerObject);\r\n            this.pointerRescale = true;\r\n\r\n            // create controller\r\n            function AddController(object) {\r\n                $this.add(object);\r\n            }\r\n\t\t\tvar cacheName = \"touch-controller-\"+this.whichHand;\r\n            var controllerObject = cache[cacheName];\r\n            if(controllerObject===undefined) {\r\n                cache[cacheName] = [AddController];\r\n\t\t\t\tvar loader = new THREE.MTLLoader();\r\n\t\t\t\tloader.setPath(options.resBase + 'touch-controller/');\r\n\t\t\t\tloader.load(\"oculus-touch-controller-\"+this.whichHand+\".mtl\",function(materials) {\r\n\t\t\t\t\tmaterials.preload();\r\n\t\t\t\t\tvar objLoader = new THREE.OBJLoader();\r\n\t\t\t\t\tobjLoader.setMaterials( materials );\r\n\t\t\t\t\tobjLoader.setPath(options.resBase + 'touch-controller/');\r\n\t\t\t\t\tobjLoader.load( \"oculus-touch-controller-\"+$this.whichHand+\".obj\" , function ( controller ) {\r\n                        var object = new THREE.Object3D();\r\n\t\t\t\t\t\tcontroller.position.add(new THREE.Vector3(.008,0.03,-.03));\r\n                        object.add(controller);\r\n                        cache[cacheName].forEach(function(callback) {\r\n                            callback(object.clone());\r\n                        });\r\n                        cache[cacheName] = object;\t\t\t\t\r\n\t\t\t\t\t});\r\n\r\n\t\t\t\t});\r\n            } else if(Array.isArray(controllerObject)) {\r\n                cache[cacheName].push(AddController);\r\n            } else\r\n                AddController(controllerObject.clone());\r\n            options.camera.parent.add(this);\r\n\t\t}\r\n\r\n        this.getAxes = function() {\r\n            return axes;\r\n        }\r\n\r\n\t\tif(/left/i.test(gamepad.id))\r\n\t\t\tthis.whichHand = \"left\";\r\n\t\tif(/right/i.test(gamepad.id))\r\n\t\t\tthis.whichHand = \"right\";\r\n\t\t\r\n        if(/openvr/i.test(gamepad.id)) {\r\n            this.createViveControllerMesh();\r\n            buttonsIndexes = {\r\n                move: 0,\r\n                click: 1,\r\n                reset: 3\r\n            }\r\n            this.isVRPad = true;\r\n        } else if(/touch/i.test(gamepad.id)) {\r\n            this.createOculusTouchMesh();\r\n            buttonsIndexes = {\r\n                move: -1,\r\n                click: 1,\r\n                reset: 3\r\n            }\r\n            this.isVRPad = true;\r\n        } else if(gamepad.id==\"simulated\") {\r\n            this.createCrosshair();\r\n            this.createProgress();\r\n            this.alwaysDrag = true;\r\n        } else if(gamepad.id==/gear vr/i.test(gamepad.id)) {\r\n            this.createCrosshair();\r\n            buttonsIndexes = {\r\n                move: -1,\r\n                click: 1,\r\n                reset: 1\r\n            }\r\n        } else {\r\n            this.createCrosshair();\r\n            buttonsIndexes = {\r\n                move: -1,\r\n                click: 7,\r\n                reset: 1\r\n            }\r\n        }\r\n\r\n    };\r\n\r\n    VRGamepad.prototype = Object.create( THREE.Object3D.prototype );\r\n    VRGamepad.prototype.constructor = VRGamepad;\r\n\r\n    var knownGamepads = [];\r\n\r\n    function mapGamepads() {\r\n        var newGamepads = [];\r\n        if(typeof navigator.getGamepads==\"function\") {\r\n            var gamepadsList = navigator.getGamepads();\r\n            for(var i = 0;i<gamepadsList.length;i++) {\r\n                var gamepad = gamepadsList[i];\r\n                if(gamepad) {\r\n                    var isNewGamepad = true;\r\n                    for(var j=0;j<knownGamepads.length;j++) {\r\n                        var knownGamepad = knownGamepads[j];\r\n                        if(gamepad===knownGamepad.getGamepad()) {\r\n                            newGamepads.push(knownGamepad);\r\n                            knownGamepads.splice(j,1);\r\n                            isNewGamepad = false;\r\n                            break;\r\n                        }\r\n                    }\r\n                    if(isNewGamepad)\r\n                        newGamepads.push(new VRGamepad(gamepad));\r\n                }\r\n            }\r\n        }\r\n        if(newGamepads.length==0) {\r\n            var needSimulated = true;\r\n            for(var j=0;j<knownGamepads.length;j++) {\r\n                var knownGamepad = knownGamepads[j];\r\n                if(knownGamepad.getGamepad().id==\"simulated\") {\r\n                    newGamepads.push(knownGamepad);\r\n                    knownGamepads.splice(j,1);\r\n                    needSimulated = false;\r\n                }\r\n            }\r\n            if(needSimulated)\r\n                newGamepads.push(new VRGamepad({\r\n                    id: \"simulated\"\r\n                }));\r\n        }\r\n        knownGamepads.forEach(function(gamepad) {\r\n            gamepad.destroyGamepad();\r\n        });\r\n        knownGamepads = newGamepads;\r\n        harborpad = null;\r\n        var firstVRPad = null;\r\n        for(var i=0;i<knownGamepads.length;i++) {\r\n            var gamepad = knownGamepads[i];\r\n            if(gamepad.isVRPad) {\r\n                if(firstVRPad) {\r\n                    harborpad = gamepad;\r\n                    break;\r\n                } else\r\n                    firstVRPad = gamepad;\r\n            }\r\n        }\r\n        if(harborpad) {\r\n\t\t\tif(harborpad.whichHand==\"right\" && firstVRPad.whichHand==\"left\") {\r\n\t\t\t\tvar tmpPad = harborpad;\r\n\t\t\t\tharborpad = firstVRPad;\r\n\t\t\t\tfirstVRPad = tmpPad;\r\n\t\t\t}\r\n            firstVRPad.pointerObject.scale.setX(.1);\r\n            firstVRPad.pointerObject.scale.setZ(.1);\r\n        } else if(firstVRPad) {\r\n            firstVRPad.pointerObject.scale.setX(1);\r\n            firstVRPad.pointerObject.scale.setZ(1);\r\n        }\r\n\r\n    }\r\n\r\n    this.getHarborPad = function() {\r\n        return harborpad;\r\n    }\r\n\r\n    this.update = function() {\r\n        mapGamepads();\r\n        knownGamepads.forEach(function(gamepad) {\r\n            gamepad.update();\r\n        });\r\n    }\r\n\r\n    this.clearAll = function() {\r\n        knownGamepads.forEach(function(gamepad) {\r\n            gamepad.destroyGamepad();\r\n        });\r\n        knownGamepads = [];\r\n    }\r\n\r\n}\r\n","/**\r\n * @author dmarcos / https://github.com/dmarcos\r\n * @author mrdoob / http://mrdoob.com\r\n */\r\n\r\nTHREE.VRControls = function ( object, onError ) {\r\n\r\n\tvar scope = this;\r\n\r\n\tvar vrDisplay, vrDisplays;\r\n\r\n\tvar standingMatrix = new THREE.Matrix4();\r\n\r\n\tvar frameData = null;\r\n\r\n\tif ( 'VRFrameData' in window ) {\r\n\r\n\t\tframeData = new VRFrameData();\r\n\r\n\t}\r\n\r\n\tfunction gotVRDisplays( displays ) {\r\n\r\n\t\tvrDisplays = displays;\r\n\r\n\t\tif ( displays.length > 0 ) {\r\n\r\n\t\t\tvrDisplay = displays[ 0 ];\r\n\r\n\t\t} else {\r\n\r\n\t\t\tif ( onError ) onError( 'VR input not available.' );\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\tif ( navigator.getVRDisplays ) {\r\n\r\n\t\tnavigator.getVRDisplays().then( gotVRDisplays ).catch ( function () {\r\n\r\n\t\t\tconsole.warn( 'THREE.VRControls: Unable to get VR Displays' );\r\n\r\n\t\t} );\r\n\r\n\t}\r\n\r\n\t// the Rift SDK returns the position in meters\r\n\t// this scale factor allows the user to define how meters\r\n\t// are converted to scene units.\r\n\r\n\tthis.scale = 1;\r\n\r\n\t// If true will use \"standing space\" coordinate system where y=0 is the\r\n\t// floor and x=0, z=0 is the center of the room.\r\n\tthis.standing = false;\r\n\r\n\t// Distance from the users eyes to the floor in meters. Used when\r\n\t// standing=true but the VRDisplay doesn't provide stageParameters.\r\n\tthis.userHeight = 1.6;\r\n\r\n\tthis.getVRDisplay = function () {\r\n\r\n\t\treturn vrDisplay;\r\n\r\n\t};\r\n\r\n\tthis.setVRDisplay = function ( value ) {\r\n\r\n\t\tvrDisplay = value;\r\n\r\n\t};\r\n\r\n\tthis.getVRDisplays = function () {\r\n\r\n\t\tconsole.warn( 'THREE.VRControls: getVRDisplays() is being deprecated.' );\r\n\t\treturn vrDisplays;\r\n\r\n\t};\r\n\r\n\tthis.getStandingMatrix = function () {\r\n\r\n\t\treturn standingMatrix;\r\n\r\n\t};\r\n\r\n\tthis.update = function () {\r\n\r\n\t\tif ( vrDisplay ) {\r\n\r\n\t\t\tvar pose;\r\n\r\n\t\t\tif ( vrDisplay.getFrameData ) {\r\n\r\n\t\t\t\tvrDisplay.getFrameData( frameData );\r\n\t\t\t\tpose = frameData.pose;\r\n\r\n\t\t\t} else if ( vrDisplay.getPose ) {\r\n\r\n\t\t\t\tpose = vrDisplay.getPose();\r\n\r\n\t\t\t}\r\n\r\n\t\t\tif ( pose.orientation !== null ) {\r\n\r\n\t\t\t\tobject.quaternion.fromArray( pose.orientation );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tif ( pose.position !== null ) {\r\n\r\n\t\t\t\tobject.position.fromArray( pose.position );\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\tobject.position.set( 0, 0, 0 );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tif ( this.standing ) {\r\n\r\n\t\t\t\tif ( vrDisplay.stageParameters ) {\r\n\r\n\t\t\t\t\tobject.updateMatrix();\r\n\r\n\t\t\t\t\tstandingMatrix.fromArray( vrDisplay.stageParameters.sittingToStandingTransform );\r\n\t\t\t\t\tobject.applyMatrix( standingMatrix );\r\n\r\n\t\t\t\t} else {\r\n\r\n\t\t\t\t\tobject.position.setY( object.position.y + this.userHeight );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t\tobject.position.multiplyScalar( scope.scale );\r\n\r\n\t\t}\r\n\r\n\t};\r\n\r\n\tthis.resetPose = function () {\r\n\r\n\t\tif ( vrDisplay ) {\r\n\r\n\t\t\tvrDisplay.resetPose();\r\n\r\n\t\t}\r\n\r\n\t};\r\n\r\n\tthis.resetSensor = function () {\r\n\r\n\t\tconsole.warn( 'THREE.VRControls: .resetSensor() is now .resetPose().' );\r\n\t\tthis.resetPose();\r\n\r\n\t};\r\n\r\n\tthis.zeroSensor = function () {\r\n\r\n\t\tconsole.warn( 'THREE.VRControls: .zeroSensor() is now .resetPose().' );\r\n\t\tthis.resetPose();\r\n\r\n\t};\r\n\r\n\tthis.dispose = function () {\r\n\r\n\t\tvrDisplay = null;\r\n\r\n\t};\r\n\r\n};\r\n","/**\r\n * @author dmarcos / https://github.com/dmarcos\r\n * @author mrdoob / http://mrdoob.com\r\n *\r\n * WebVR Spec: http://mozvr.github.io/webvr-spec/webvr.html\r\n *\r\n * Firefox: http://mozvr.com/downloads/\r\n * Chromium: https://webvr.info/get-chrome\r\n *\r\n */\r\n\r\nTHREE.VREffect = function( renderer, onError ) {\r\n\r\n\tvar vrDisplay, vrDisplays;\r\n\tvar eyeTranslationL = new THREE.Vector3();\r\n\tvar eyeTranslationR = new THREE.Vector3();\r\n\tvar renderRectL, renderRectR;\r\n\r\n\tvar frameData = null;\r\n\r\n\tif ( 'VRFrameData' in window ) {\r\n\r\n\t\tframeData = new window.VRFrameData();\r\n\r\n\t}\r\n\r\n\tfunction gotVRDisplays( displays ) {\r\n\r\n\t\tvrDisplays = displays;\r\n\r\n\t\tif ( displays.length > 0 ) {\r\n\r\n\t\t\tvrDisplay = displays[ 0 ];\r\n\r\n\t\t} else {\r\n\r\n\t\t\tif ( onError ) onError( 'HMD not available' );\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\tif ( navigator.getVRDisplays ) {\r\n\r\n\t\tnavigator.getVRDisplays().then( gotVRDisplays ).catch( function() {\r\n\r\n\t\t\tconsole.warn( 'THREE.VREffect: Unable to get VR Displays' );\r\n\r\n\t\t} );\r\n\r\n\t}\r\n\r\n\t//\r\n\r\n\tthis.isPresenting = false;\r\n\tthis.scale = 1;\r\n\r\n\tvar scope = this;\r\n\r\n\tvar rendererSize = renderer.getSize();\r\n\tvar rendererUpdateStyle = false;\r\n\tvar rendererPixelRatio = renderer.getPixelRatio();\r\n\r\n\tthis.getVRDisplay = function() {\r\n\r\n\t\treturn vrDisplay;\r\n\r\n\t};\r\n\r\n\tthis.setVRDisplay = function( value ) {\r\n\r\n\t\tvrDisplay = value;\r\n\r\n\t};\r\n\r\n\tthis.getVRDisplays = function() {\r\n\r\n\t\tconsole.warn( 'THREE.VREffect: getVRDisplays() is being deprecated.' );\r\n\t\treturn vrDisplays;\r\n\r\n\t};\r\n\r\n\tthis.setSize = function( width, height, updateStyle ) {\r\n\r\n\t\trendererSize = { width: width, height: height };\r\n\t\trendererUpdateStyle = updateStyle;\r\n\r\n\t\tif ( scope.isPresenting ) {\r\n\r\n\t\t\tvar eyeParamsL = vrDisplay.getEyeParameters( 'left' );\r\n\t\t\trenderer.setPixelRatio( 1 );\r\n\t\t\trenderer.setSize( eyeParamsL.renderWidth * 2, eyeParamsL.renderHeight, false );\r\n\r\n\t\t} else {\r\n\r\n\t\t\trenderer.setPixelRatio( rendererPixelRatio );\r\n\t\t\trenderer.setSize( width, height, updateStyle );\r\n\r\n\t\t}\r\n\r\n\t};\r\n\r\n\t// VR presentation\r\n\r\n\tvar canvas = renderer.domElement;\r\n\tvar defaultLeftBounds = [ 0.0, 0.0, 0.5, 1.0 ];\r\n\tvar defaultRightBounds = [ 0.5, 0.0, 0.5, 1.0 ];\r\n\r\n\tfunction onVRDisplayPresentChange() {\r\n\r\n\t\tvar wasPresenting = scope.isPresenting;\r\n\t\tscope.isPresenting = vrDisplay !== undefined && vrDisplay.isPresenting;\r\n\r\n\t\tif ( scope.isPresenting ) {\r\n\r\n\t\t\tvar eyeParamsL = vrDisplay.getEyeParameters( 'left' );\r\n\t\t\tvar eyeWidth = eyeParamsL.renderWidth;\r\n\t\t\tvar eyeHeight = eyeParamsL.renderHeight;\r\n\r\n\t\t\tif ( ! wasPresenting ) {\r\n\r\n\t\t\t\trendererPixelRatio = renderer.getPixelRatio();\r\n\t\t\t\trendererSize = renderer.getSize();\r\n\r\n\t\t\t\trenderer.setPixelRatio( 1 );\r\n\t\t\t\trenderer.setSize( eyeWidth * 2, eyeHeight, false );\r\n\r\n\t\t\t}\r\n\r\n\t\t} else if ( wasPresenting ) {\r\n\r\n\t\t\trenderer.setPixelRatio( rendererPixelRatio );\r\n\t\t\trenderer.setSize( rendererSize.width, rendererSize.height, rendererUpdateStyle );\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\twindow.addEventListener( 'vrdisplaypresentchange', onVRDisplayPresentChange, false );\r\n\r\n\tthis.setFullScreen = function( boolean ) {\r\n\r\n\t\treturn new Promise( function( resolve, reject ) {\r\n\r\n\t\t\tif ( vrDisplay === undefined ) {\r\n\r\n\t\t\t\treject( new Error( 'No VR hardware found.' ) );\r\n\t\t\t\treturn;\r\n\r\n\t\t\t}\r\n\r\n\t\t\tif ( scope.isPresenting === boolean ) {\r\n\r\n\t\t\t\tresolve();\r\n\t\t\t\treturn;\r\n\r\n\t\t\t}\r\n\r\n\t\t\tif ( boolean ) {\r\n\r\n\t\t\t\tresolve( vrDisplay.requestPresent( [ { source: canvas } ] ) );\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\tresolve( vrDisplay.exitPresent() );\r\n\r\n\t\t\t}\r\n\r\n\t\t} );\r\n\r\n\t};\r\n\r\n\tthis.requestPresent = function() {\r\n\r\n\t\treturn this.setFullScreen( true );\r\n\r\n\t};\r\n\r\n\tthis.exitPresent = function() {\r\n\r\n\t\treturn this.setFullScreen( false );\r\n\r\n\t};\r\n\r\n\tthis.requestAnimationFrame = function( f ) {\r\n\r\n\t\tif ( vrDisplay !== undefined ) {\r\n\r\n\t\t\treturn vrDisplay.requestAnimationFrame( f );\r\n\r\n\t\t} else {\r\n\r\n\t\t\treturn window.requestAnimationFrame( f );\r\n\r\n\t\t}\r\n\r\n\t};\r\n\r\n\tthis.cancelAnimationFrame = function( h ) {\r\n\r\n\t\tif ( vrDisplay !== undefined ) {\r\n\r\n\t\t\tvrDisplay.cancelAnimationFrame( h );\r\n\r\n\t\t} else {\r\n\r\n\t\t\twindow.cancelAnimationFrame( h );\r\n\r\n\t\t}\r\n\r\n\t};\r\n\r\n\tthis.submitFrame = function() {\r\n\r\n\t\tif ( vrDisplay !== undefined && scope.isPresenting ) {\r\n\r\n\t\t\tvrDisplay.submitFrame();\r\n\r\n\t\t}\r\n\r\n\t};\r\n\r\n\tthis.autoSubmitFrame = true;\r\n\r\n\t// render\r\n\r\n\tvar cameraL = new THREE.PerspectiveCamera();\r\n\tcameraL.layers.enable( 1 );\r\n\r\n\tvar cameraR = new THREE.PerspectiveCamera();\r\n\tcameraR.layers.enable( 2 );\r\n\r\n\tthis.render = function( scene, camera, renderTarget, forceClear ) {\r\n\r\n\t\tif ( vrDisplay && scope.isPresenting ) {\r\n\r\n\t\t\tvar autoUpdate = scene.autoUpdate;\r\n\r\n\t\t\tif ( autoUpdate ) {\r\n\r\n\t\t\t\tscene.updateMatrixWorld();\r\n\t\t\t\tscene.autoUpdate = false;\r\n\r\n\t\t\t}\r\n\r\n\t\t\tvar eyeParamsL = vrDisplay.getEyeParameters( 'left' );\r\n\t\t\tvar eyeParamsR = vrDisplay.getEyeParameters( 'right' );\r\n\r\n\t\t\teyeTranslationL.fromArray( eyeParamsL.offset );\r\n\t\t\teyeTranslationR.fromArray( eyeParamsR.offset );\r\n\r\n\t\t\tif ( Array.isArray( scene ) ) {\r\n\r\n\t\t\t\tconsole.warn( 'THREE.VREffect.render() no longer supports arrays. Use object.layers instead.' );\r\n\t\t\t\tscene = scene[ 0 ];\r\n\r\n\t\t\t}\r\n\r\n\t\t\t// When rendering we don't care what the recommended size is, only what the actual size\r\n\t\t\t// of the backbuffer is.\r\n\t\t\tvar size = renderer.getSize();\r\n\t\t\tvar layers = vrDisplay.getLayers();\r\n\t\t\tvar leftBounds;\r\n\t\t\tvar rightBounds;\r\n\r\n\t\t\tif ( layers.length ) {\r\n\r\n\t\t\t\tvar layer = layers[ 0 ];\r\n\r\n\t\t\t\tleftBounds = layer.leftBounds !== null && layer.leftBounds.length === 4 ? layer.leftBounds : defaultLeftBounds;\r\n\t\t\t\trightBounds = layer.rightBounds !== null && layer.rightBounds.length === 4 ? layer.rightBounds : defaultRightBounds;\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\tleftBounds = defaultLeftBounds;\r\n\t\t\t\trightBounds = defaultRightBounds;\r\n\r\n\t\t\t}\r\n\r\n\t\t\trenderRectL = {\r\n\t\t\t\tx: Math.round( size.width * leftBounds[ 0 ] ),\r\n\t\t\t\ty: Math.round( size.height * leftBounds[ 1 ] ),\r\n\t\t\t\twidth: Math.round( size.width * leftBounds[ 2 ] ),\r\n\t\t\t\theight: Math.round( size.height * leftBounds[ 3 ] )\r\n\t\t\t};\r\n\t\t\trenderRectR = {\r\n\t\t\t\tx: Math.round( size.width * rightBounds[ 0 ] ),\r\n\t\t\t\ty: Math.round( size.height * rightBounds[ 1 ] ),\r\n\t\t\t\twidth: Math.round( size.width * rightBounds[ 2 ] ),\r\n\t\t\t\theight: Math.round( size.height * rightBounds[ 3 ] )\r\n\t\t\t};\r\n\r\n\t\t\tif ( renderTarget ) {\r\n\r\n\t\t\t\trenderer.setRenderTarget( renderTarget );\r\n\t\t\t\trenderTarget.scissorTest = true;\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\trenderer.setRenderTarget( null );\r\n\t\t\t\trenderer.setScissorTest( true );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tif ( renderer.autoClear || forceClear ) renderer.clear();\r\n\r\n\t\t\tif ( camera.parent === null ) camera.updateMatrixWorld();\r\n\r\n\t\t\tcamera.matrixWorld.decompose( cameraL.position, cameraL.quaternion, cameraL.scale );\r\n\t\t\tcamera.matrixWorld.decompose( cameraR.position, cameraR.quaternion, cameraR.scale );\r\n\r\n\t\t\tvar scale = this.scale;\r\n\t\t\tcameraL.translateOnAxis( eyeTranslationL, scale );\r\n\t\t\tcameraR.translateOnAxis( eyeTranslationR, scale );\r\n\r\n\t\t\tif ( vrDisplay.getFrameData ) {\r\n\r\n\t\t\t\tvrDisplay.depthNear = camera.near;\r\n\t\t\t\tvrDisplay.depthFar = camera.far;\r\n\r\n\t\t\t\tvrDisplay.getFrameData( frameData );\r\n\r\n\t\t\t\tcameraL.projectionMatrix.elements = frameData.leftProjectionMatrix;\r\n\t\t\t\tcameraR.projectionMatrix.elements = frameData.rightProjectionMatrix;\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\tcameraL.projectionMatrix = fovToProjection( eyeParamsL.fieldOfView, true, camera.near, camera.far );\r\n\t\t\t\tcameraR.projectionMatrix = fovToProjection( eyeParamsR.fieldOfView, true, camera.near, camera.far );\r\n\r\n\t\t\t}\r\n\r\n\t\t\t// render left eye\r\n\t\t\tif ( renderTarget ) {\r\n\r\n\t\t\t\trenderTarget.viewport.set( renderRectL.x, renderRectL.y, renderRectL.width, renderRectL.height );\r\n\t\t\t\trenderTarget.scissor.set( renderRectL.x, renderRectL.y, renderRectL.width, renderRectL.height );\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\trenderer.setViewport( renderRectL.x, renderRectL.y, renderRectL.width, renderRectL.height );\r\n\t\t\t\trenderer.setScissor( renderRectL.x, renderRectL.y, renderRectL.width, renderRectL.height );\r\n\r\n\t\t\t}\r\n\t\t\trenderer.render( scene, cameraL, renderTarget, forceClear );\r\n\r\n\t\t\t// render right eye\r\n\t\t\tif ( renderTarget ) {\r\n\r\n\t\t\t\trenderTarget.viewport.set( renderRectR.x, renderRectR.y, renderRectR.width, renderRectR.height );\r\n\t\t\t\trenderTarget.scissor.set( renderRectR.x, renderRectR.y, renderRectR.width, renderRectR.height );\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\trenderer.setViewport( renderRectR.x, renderRectR.y, renderRectR.width, renderRectR.height );\r\n\t\t\t\trenderer.setScissor( renderRectR.x, renderRectR.y, renderRectR.width, renderRectR.height );\r\n\r\n\t\t\t}\r\n\t\t\trenderer.render( scene, cameraR, renderTarget, forceClear );\r\n\r\n\t\t\tif ( renderTarget ) {\r\n\r\n\t\t\t\trenderTarget.viewport.set( 0, 0, size.width, size.height );\r\n\t\t\t\trenderTarget.scissor.set( 0, 0, size.width, size.height );\r\n\t\t\t\trenderTarget.scissorTest = false;\r\n\t\t\t\trenderer.setRenderTarget( null );\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\trenderer.setViewport( 0, 0, size.width, size.height );\r\n\t\t\t\trenderer.setScissorTest( false );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tif ( autoUpdate ) {\r\n\r\n\t\t\t\tscene.autoUpdate = true;\r\n\r\n\t\t\t}\r\n\r\n\t\t\tif ( scope.autoSubmitFrame ) {\r\n\r\n\t\t\t\tscope.submitFrame();\r\n\r\n\t\t\t}\r\n\r\n\t\t\treturn;\r\n\r\n\t\t}\r\n\r\n\t\t// Regular render mode if not HMD\r\n\r\n\t\trenderer.render( scene, camera, renderTarget, forceClear );\r\n\r\n\t};\r\n\r\n\tthis.dispose = function() {\r\n\r\n\t\twindow.removeEventListener( 'vrdisplaypresentchange', onVRDisplayPresentChange, false );\r\n\r\n\t};\r\n\r\n\t//\r\n\r\n\tfunction fovToNDCScaleOffset( fov ) {\r\n\r\n\t\tvar pxscale = 2.0 / ( fov.leftTan + fov.rightTan );\r\n\t\tvar pxoffset = ( fov.leftTan - fov.rightTan ) * pxscale * 0.5;\r\n\t\tvar pyscale = 2.0 / ( fov.upTan + fov.downTan );\r\n\t\tvar pyoffset = ( fov.upTan - fov.downTan ) * pyscale * 0.5;\r\n\t\treturn { scale: [ pxscale, pyscale ], offset: [ pxoffset, pyoffset ] };\r\n\r\n\t}\r\n\r\n\tfunction fovPortToProjection( fov, rightHanded, zNear, zFar ) {\r\n\r\n\t\trightHanded = rightHanded === undefined ? true : rightHanded;\r\n\t\tzNear = zNear === undefined ? 0.01 : zNear;\r\n\t\tzFar = zFar === undefined ? 10000.0 : zFar;\r\n\r\n\t\tvar handednessScale = rightHanded ? - 1.0 : 1.0;\r\n\r\n\t\t// start with an identity matrix\r\n\t\tvar mobj = new THREE.Matrix4();\r\n\t\tvar m = mobj.elements;\r\n\r\n\t\t// and with scale/offset info for normalized device coords\r\n\t\tvar scaleAndOffset = fovToNDCScaleOffset( fov );\r\n\r\n\t\t// X result, map clip edges to [-w,+w]\r\n\t\tm[ 0 * 4 + 0 ] = scaleAndOffset.scale[ 0 ];\r\n\t\tm[ 0 * 4 + 1 ] = 0.0;\r\n\t\tm[ 0 * 4 + 2 ] = scaleAndOffset.offset[ 0 ] * handednessScale;\r\n\t\tm[ 0 * 4 + 3 ] = 0.0;\r\n\r\n\t\t// Y result, map clip edges to [-w,+w]\r\n\t\t// Y offset is negated because this proj matrix transforms from world coords with Y=up,\r\n\t\t// but the NDC scaling has Y=down (thanks D3D?)\r\n\t\tm[ 1 * 4 + 0 ] = 0.0;\r\n\t\tm[ 1 * 4 + 1 ] = scaleAndOffset.scale[ 1 ];\r\n\t\tm[ 1 * 4 + 2 ] = - scaleAndOffset.offset[ 1 ] * handednessScale;\r\n\t\tm[ 1 * 4 + 3 ] = 0.0;\r\n\r\n\t\t// Z result (up to the app)\r\n\t\tm[ 2 * 4 + 0 ] = 0.0;\r\n\t\tm[ 2 * 4 + 1 ] = 0.0;\r\n\t\tm[ 2 * 4 + 2 ] = zFar / ( zNear - zFar ) * - handednessScale;\r\n\t\tm[ 2 * 4 + 3 ] = ( zFar * zNear ) / ( zNear - zFar );\r\n\r\n\t\t// W result (= Z in)\r\n\t\tm[ 3 * 4 + 0 ] = 0.0;\r\n\t\tm[ 3 * 4 + 1 ] = 0.0;\r\n\t\tm[ 3 * 4 + 2 ] = handednessScale;\r\n\t\tm[ 3 * 4 + 3 ] = 0.0;\r\n\r\n\t\tmobj.transpose();\r\n\r\n\t\treturn mobj;\r\n\r\n\t}\r\n\r\n\tfunction fovToProjection( fov, rightHanded, zNear, zFar ) {\r\n\r\n\t\tvar DEG2RAD = Math.PI / 180.0;\r\n\r\n\t\tvar fovPort = {\r\n\t\t\tupTan: Math.tan( fov.upDegrees * DEG2RAD ),\r\n\t\t\tdownTan: Math.tan( fov.downDegrees * DEG2RAD ),\r\n\t\t\tleftTan: Math.tan( fov.leftDegrees * DEG2RAD ),\r\n\t\t\trightTan: Math.tan( fov.rightDegrees * DEG2RAD )\r\n\t\t};\r\n\r\n\t\treturn fovPortToProjection( fovPort, rightHanded, zNear, zFar );\r\n\r\n\t}\r\n\r\n};\r\n","/**\r\n * @author mrdoob / http://mrdoob.com/\r\n */\r\n\r\nTHREE.OBJLoader = function ( manager ) {\r\n\r\n\tthis.manager = ( manager !== undefined ) ? manager : THREE.DefaultLoadingManager;\r\n\r\n\tthis.materials = null;\r\n\r\n\tthis.regexp = {\r\n\t\t// v float float float\r\n\t\tvertex_pattern           : /^v\\s+([\\d|\\.|\\+|\\-|e|E]+)\\s+([\\d|\\.|\\+|\\-|e|E]+)\\s+([\\d|\\.|\\+|\\-|e|E]+)/,\r\n\t\t// vn float float float\r\n\t\tnormal_pattern           : /^vn\\s+([\\d|\\.|\\+|\\-|e|E]+)\\s+([\\d|\\.|\\+|\\-|e|E]+)\\s+([\\d|\\.|\\+|\\-|e|E]+)/,\r\n\t\t// vt float float\r\n\t\tuv_pattern               : /^vt\\s+([\\d|\\.|\\+|\\-|e|E]+)\\s+([\\d|\\.|\\+|\\-|e|E]+)/,\r\n\t\t// f vertex vertex vertex\r\n\t\tface_vertex              : /^f\\s+(-?\\d+)\\s+(-?\\d+)\\s+(-?\\d+)(?:\\s+(-?\\d+))?/,\r\n\t\t// f vertex/uv vertex/uv vertex/uv\r\n\t\tface_vertex_uv           : /^f\\s+(-?\\d+)\\/(-?\\d+)\\s+(-?\\d+)\\/(-?\\d+)\\s+(-?\\d+)\\/(-?\\d+)(?:\\s+(-?\\d+)\\/(-?\\d+))?/,\r\n\t\t// f vertex/uv/normal vertex/uv/normal vertex/uv/normal\r\n\t\tface_vertex_uv_normal    : /^f\\s+(-?\\d+)\\/(-?\\d+)\\/(-?\\d+)\\s+(-?\\d+)\\/(-?\\d+)\\/(-?\\d+)\\s+(-?\\d+)\\/(-?\\d+)\\/(-?\\d+)(?:\\s+(-?\\d+)\\/(-?\\d+)\\/(-?\\d+))?/,\r\n\t\t// f vertex//normal vertex//normal vertex//normal\r\n\t\tface_vertex_normal       : /^f\\s+(-?\\d+)\\/\\/(-?\\d+)\\s+(-?\\d+)\\/\\/(-?\\d+)\\s+(-?\\d+)\\/\\/(-?\\d+)(?:\\s+(-?\\d+)\\/\\/(-?\\d+))?/,\r\n\t\t// o object_name | g group_name\r\n\t\tobject_pattern           : /^[og]\\s*(.+)?/,\r\n\t\t// s boolean\r\n\t\tsmoothing_pattern        : /^s\\s+(\\d+|on|off)/,\r\n\t\t// mtllib file_reference\r\n\t\tmaterial_library_pattern : /^mtllib /,\r\n\t\t// usemtl material_name\r\n\t\tmaterial_use_pattern     : /^usemtl /\r\n\t};\r\n\r\n};\r\n\r\nTHREE.OBJLoader.prototype = {\r\n\r\n\tconstructor: THREE.OBJLoader,\r\n\r\n\tload: function ( url, onLoad, onProgress, onError ) {\r\n\r\n\t\tvar scope = this;\r\n\r\n\t\tvar loader = new THREE.FileLoader( scope.manager );\r\n\t\tloader.setPath( this.path );\r\n\t\tloader.load( url, function ( text ) {\r\n\r\n\t\t\tonLoad( scope.parse( text ) );\r\n\r\n\t\t}, onProgress, onError );\r\n\r\n\t},\r\n\r\n\tsetPath: function ( value ) {\r\n\r\n\t\tthis.path = value;\r\n\r\n\t},\r\n\r\n\tsetMaterials: function ( materials ) {\r\n\r\n\t\tthis.materials = materials;\r\n\r\n\t},\r\n\r\n\t_createParserState : function () {\r\n\r\n\t\tvar state = {\r\n\t\t\tobjects  : [],\r\n\t\t\tobject   : {},\r\n\r\n\t\t\tvertices : [],\r\n\t\t\tnormals  : [],\r\n\t\t\tuvs      : [],\r\n\r\n\t\t\tmaterialLibraries : [],\r\n\r\n\t\t\tstartObject: function ( name, fromDeclaration ) {\r\n\r\n\t\t\t\t// If the current object (initial from reset) is not from a g/o declaration in the parsed\r\n\t\t\t\t// file. We need to use it for the first parsed g/o to keep things in sync.\r\n\t\t\t\tif ( this.object && this.object.fromDeclaration === false ) {\r\n\r\n\t\t\t\t\tthis.object.name = name;\r\n\t\t\t\t\tthis.object.fromDeclaration = ( fromDeclaration !== false );\r\n\t\t\t\t\treturn;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tvar previousMaterial = ( this.object && typeof this.object.currentMaterial === 'function' ? this.object.currentMaterial() : undefined );\r\n\r\n\t\t\t\tif ( this.object && typeof this.object._finalize === 'function' ) {\r\n\r\n\t\t\t\t\tthis.object._finalize( true );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tthis.object = {\r\n\t\t\t\t\tname : name || '',\r\n\t\t\t\t\tfromDeclaration : ( fromDeclaration !== false ),\r\n\r\n\t\t\t\t\tgeometry : {\r\n\t\t\t\t\t\tvertices : [],\r\n\t\t\t\t\t\tnormals  : [],\r\n\t\t\t\t\t\tuvs      : []\r\n\t\t\t\t\t},\r\n\t\t\t\t\tmaterials : [],\r\n\t\t\t\t\tsmooth : true,\r\n\r\n\t\t\t\t\tstartMaterial : function( name, libraries ) {\r\n\r\n\t\t\t\t\t\tvar previous = this._finalize( false );\r\n\r\n\t\t\t\t\t\t// New usemtl declaration overwrites an inherited material, except if faces were declared\r\n\t\t\t\t\t\t// after the material, then it must be preserved for proper MultiMaterial continuation.\r\n\t\t\t\t\t\tif ( previous && ( previous.inherited || previous.groupCount <= 0 ) ) {\r\n\r\n\t\t\t\t\t\t\tthis.materials.splice( previous.index, 1 );\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\tvar material = {\r\n\t\t\t\t\t\t\tindex      : this.materials.length,\r\n\t\t\t\t\t\t\tname       : name || '',\r\n\t\t\t\t\t\t\tmtllib     : ( Array.isArray( libraries ) && libraries.length > 0 ? libraries[ libraries.length - 1 ] : '' ),\r\n\t\t\t\t\t\t\tsmooth     : ( previous !== undefined ? previous.smooth : this.smooth ),\r\n\t\t\t\t\t\t\tgroupStart : ( previous !== undefined ? previous.groupEnd : 0 ),\r\n\t\t\t\t\t\t\tgroupEnd   : -1,\r\n\t\t\t\t\t\t\tgroupCount : -1,\r\n\t\t\t\t\t\t\tinherited  : false,\r\n\r\n\t\t\t\t\t\t\tclone : function( index ) {\r\n\t\t\t\t\t\t\t\tvar cloned = {\r\n\t\t\t\t\t\t\t\t\tindex      : ( typeof index === 'number' ? index : this.index ),\r\n\t\t\t\t\t\t\t\t\tname       : this.name,\r\n\t\t\t\t\t\t\t\t\tmtllib     : this.mtllib,\r\n\t\t\t\t\t\t\t\t\tsmooth     : this.smooth,\r\n\t\t\t\t\t\t\t\t\tgroupStart : 0,\r\n\t\t\t\t\t\t\t\t\tgroupEnd   : -1,\r\n\t\t\t\t\t\t\t\t\tgroupCount : -1,\r\n\t\t\t\t\t\t\t\t\tinherited  : false\r\n\t\t\t\t\t\t\t\t};\r\n\t\t\t\t\t\t\t\tcloned.clone = this.clone.bind(cloned);\r\n\t\t\t\t\t\t\t\treturn cloned;\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t};\r\n\r\n\t\t\t\t\t\tthis.materials.push( material );\r\n\r\n\t\t\t\t\t\treturn material;\r\n\r\n\t\t\t\t\t},\r\n\r\n\t\t\t\t\tcurrentMaterial : function() {\r\n\r\n\t\t\t\t\t\tif ( this.materials.length > 0 ) {\r\n\t\t\t\t\t\t\treturn this.materials[ this.materials.length - 1 ];\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\treturn undefined;\r\n\r\n\t\t\t\t\t},\r\n\r\n\t\t\t\t\t_finalize : function( end ) {\r\n\r\n\t\t\t\t\t\tvar lastMultiMaterial = this.currentMaterial();\r\n\t\t\t\t\t\tif ( lastMultiMaterial && lastMultiMaterial.groupEnd === -1 ) {\r\n\r\n\t\t\t\t\t\t\tlastMultiMaterial.groupEnd = this.geometry.vertices.length / 3;\r\n\t\t\t\t\t\t\tlastMultiMaterial.groupCount = lastMultiMaterial.groupEnd - lastMultiMaterial.groupStart;\r\n\t\t\t\t\t\t\tlastMultiMaterial.inherited = false;\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t// Ignore objects tail materials if no face declarations followed them before a new o/g started.\r\n\t\t\t\t\t\tif ( end && this.materials.length > 1 ) {\r\n\r\n\t\t\t\t\t\t\tfor ( var mi = this.materials.length - 1; mi >= 0; mi-- ) {\r\n\t\t\t\t\t\t\t\tif ( this.materials[mi].groupCount <= 0 ) {\r\n\t\t\t\t\t\t\t\t\tthis.materials.splice( mi, 1 );\r\n\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t// Guarantee at least one empty material, this makes the creation later more straight forward.\r\n\t\t\t\t\t\tif ( end && this.materials.length === 0 ) {\r\n\r\n\t\t\t\t\t\t\tthis.materials.push({\r\n\t\t\t\t\t\t\t\tname   : '',\r\n\t\t\t\t\t\t\t\tsmooth : this.smooth\r\n\t\t\t\t\t\t\t});\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\treturn lastMultiMaterial;\r\n\r\n\t\t\t\t\t}\r\n\t\t\t\t};\r\n\r\n\t\t\t\t// Inherit previous objects material.\r\n\t\t\t\t// Spec tells us that a declared material must be set to all objects until a new material is declared.\r\n\t\t\t\t// If a usemtl declaration is encountered while this new object is being parsed, it will\r\n\t\t\t\t// overwrite the inherited material. Exception being that there was already face declarations\r\n\t\t\t\t// to the inherited material, then it will be preserved for proper MultiMaterial continuation.\r\n\r\n\t\t\t\tif ( previousMaterial && previousMaterial.name && typeof previousMaterial.clone === \"function\" ) {\r\n\r\n\t\t\t\t\tvar declared = previousMaterial.clone( 0 );\r\n\t\t\t\t\tdeclared.inherited = true;\r\n\t\t\t\t\tthis.object.materials.push( declared );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tthis.objects.push( this.object );\r\n\r\n\t\t\t},\r\n\r\n\t\t\tfinalize : function() {\r\n\r\n\t\t\t\tif ( this.object && typeof this.object._finalize === 'function' ) {\r\n\r\n\t\t\t\t\tthis.object._finalize( true );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t},\r\n\r\n\t\t\tparseVertexIndex: function ( value, len ) {\r\n\r\n\t\t\t\tvar index = parseInt( value, 10 );\r\n\t\t\t\treturn ( index >= 0 ? index - 1 : index + len / 3 ) * 3;\r\n\r\n\t\t\t},\r\n\r\n\t\t\tparseNormalIndex: function ( value, len ) {\r\n\r\n\t\t\t\tvar index = parseInt( value, 10 );\r\n\t\t\t\treturn ( index >= 0 ? index - 1 : index + len / 3 ) * 3;\r\n\r\n\t\t\t},\r\n\r\n\t\t\tparseUVIndex: function ( value, len ) {\r\n\r\n\t\t\t\tvar index = parseInt( value, 10 );\r\n\t\t\t\treturn ( index >= 0 ? index - 1 : index + len / 2 ) * 2;\r\n\r\n\t\t\t},\r\n\r\n\t\t\taddVertex: function ( a, b, c ) {\r\n\r\n\t\t\t\tvar src = this.vertices;\r\n\t\t\t\tvar dst = this.object.geometry.vertices;\r\n\r\n\t\t\t\tdst.push( src[ a + 0 ] );\r\n\t\t\t\tdst.push( src[ a + 1 ] );\r\n\t\t\t\tdst.push( src[ a + 2 ] );\r\n\t\t\t\tdst.push( src[ b + 0 ] );\r\n\t\t\t\tdst.push( src[ b + 1 ] );\r\n\t\t\t\tdst.push( src[ b + 2 ] );\r\n\t\t\t\tdst.push( src[ c + 0 ] );\r\n\t\t\t\tdst.push( src[ c + 1 ] );\r\n\t\t\t\tdst.push( src[ c + 2 ] );\r\n\r\n\t\t\t},\r\n\r\n\t\t\taddVertexLine: function ( a ) {\r\n\r\n\t\t\t\tvar src = this.vertices;\r\n\t\t\t\tvar dst = this.object.geometry.vertices;\r\n\r\n\t\t\t\tdst.push( src[ a + 0 ] );\r\n\t\t\t\tdst.push( src[ a + 1 ] );\r\n\t\t\t\tdst.push( src[ a + 2 ] );\r\n\r\n\t\t\t},\r\n\r\n\t\t\taddNormal : function ( a, b, c ) {\r\n\r\n\t\t\t\tvar src = this.normals;\r\n\t\t\t\tvar dst = this.object.geometry.normals;\r\n\r\n\t\t\t\tdst.push( src[ a + 0 ] );\r\n\t\t\t\tdst.push( src[ a + 1 ] );\r\n\t\t\t\tdst.push( src[ a + 2 ] );\r\n\t\t\t\tdst.push( src[ b + 0 ] );\r\n\t\t\t\tdst.push( src[ b + 1 ] );\r\n\t\t\t\tdst.push( src[ b + 2 ] );\r\n\t\t\t\tdst.push( src[ c + 0 ] );\r\n\t\t\t\tdst.push( src[ c + 1 ] );\r\n\t\t\t\tdst.push( src[ c + 2 ] );\r\n\r\n\t\t\t},\r\n\r\n\t\t\taddUV: function ( a, b, c ) {\r\n\r\n\t\t\t\tvar src = this.uvs;\r\n\t\t\t\tvar dst = this.object.geometry.uvs;\r\n\r\n\t\t\t\tdst.push( src[ a + 0 ] );\r\n\t\t\t\tdst.push( src[ a + 1 ] );\r\n\t\t\t\tdst.push( src[ b + 0 ] );\r\n\t\t\t\tdst.push( src[ b + 1 ] );\r\n\t\t\t\tdst.push( src[ c + 0 ] );\r\n\t\t\t\tdst.push( src[ c + 1 ] );\r\n\r\n\t\t\t},\r\n\r\n\t\t\taddUVLine: function ( a ) {\r\n\r\n\t\t\t\tvar src = this.uvs;\r\n\t\t\t\tvar dst = this.object.geometry.uvs;\r\n\r\n\t\t\t\tdst.push( src[ a + 0 ] );\r\n\t\t\t\tdst.push( src[ a + 1 ] );\r\n\r\n\t\t\t},\r\n\r\n\t\t\taddFace: function ( a, b, c, d, ua, ub, uc, ud, na, nb, nc, nd ) {\r\n\r\n\t\t\t\tvar vLen = this.vertices.length;\r\n\r\n\t\t\t\tvar ia = this.parseVertexIndex( a, vLen );\r\n\t\t\t\tvar ib = this.parseVertexIndex( b, vLen );\r\n\t\t\t\tvar ic = this.parseVertexIndex( c, vLen );\r\n\t\t\t\tvar id;\r\n\r\n\t\t\t\tif ( d === undefined ) {\r\n\r\n\t\t\t\t\tthis.addVertex( ia, ib, ic );\r\n\r\n\t\t\t\t} else {\r\n\r\n\t\t\t\t\tid = this.parseVertexIndex( d, vLen );\r\n\r\n\t\t\t\t\tthis.addVertex( ia, ib, id );\r\n\t\t\t\t\tthis.addVertex( ib, ic, id );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif ( ua !== undefined ) {\r\n\r\n\t\t\t\t\tvar uvLen = this.uvs.length;\r\n\r\n\t\t\t\t\tia = this.parseUVIndex( ua, uvLen );\r\n\t\t\t\t\tib = this.parseUVIndex( ub, uvLen );\r\n\t\t\t\t\tic = this.parseUVIndex( uc, uvLen );\r\n\r\n\t\t\t\t\tif ( d === undefined ) {\r\n\r\n\t\t\t\t\t\tthis.addUV( ia, ib, ic );\r\n\r\n\t\t\t\t\t} else {\r\n\r\n\t\t\t\t\t\tid = this.parseUVIndex( ud, uvLen );\r\n\r\n\t\t\t\t\t\tthis.addUV( ia, ib, id );\r\n\t\t\t\t\t\tthis.addUV( ib, ic, id );\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif ( na !== undefined ) {\r\n\r\n\t\t\t\t\t// Normals are many times the same. If so, skip function call and parseInt.\r\n\t\t\t\t\tvar nLen = this.normals.length;\r\n\t\t\t\t\tia = this.parseNormalIndex( na, nLen );\r\n\r\n\t\t\t\t\tib = na === nb ? ia : this.parseNormalIndex( nb, nLen );\r\n\t\t\t\t\tic = na === nc ? ia : this.parseNormalIndex( nc, nLen );\r\n\r\n\t\t\t\t\tif ( d === undefined ) {\r\n\r\n\t\t\t\t\t\tthis.addNormal( ia, ib, ic );\r\n\r\n\t\t\t\t\t} else {\r\n\r\n\t\t\t\t\t\tid = this.parseNormalIndex( nd, nLen );\r\n\r\n\t\t\t\t\t\tthis.addNormal( ia, ib, id );\r\n\t\t\t\t\t\tthis.addNormal( ib, ic, id );\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t},\r\n\r\n\t\t\taddLineGeometry: function ( vertices, uvs ) {\r\n\r\n\t\t\t\tthis.object.geometry.type = 'Line';\r\n\r\n\t\t\t\tvar vLen = this.vertices.length;\r\n\t\t\t\tvar uvLen = this.uvs.length;\r\n\r\n\t\t\t\tfor ( var vi = 0, l = vertices.length; vi < l; vi ++ ) {\r\n\r\n\t\t\t\t\tthis.addVertexLine( this.parseVertexIndex( vertices[ vi ], vLen ) );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tfor ( var uvi = 0, l = uvs.length; uvi < l; uvi ++ ) {\r\n\r\n\t\t\t\t\tthis.addUVLine( this.parseUVIndex( uvs[ uvi ], uvLen ) );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t};\r\n\r\n\t\tstate.startObject( '', false );\r\n\r\n\t\treturn state;\r\n\r\n\t},\r\n\r\n\tparse: function ( text ) {\r\n\r\n\t\tconsole.time( 'OBJLoader' );\r\n\r\n\t\tvar state = this._createParserState();\r\n\r\n\t\tif ( text.indexOf( '\\r\\n' ) !== - 1 ) {\r\n\r\n\t\t\t// This is faster than String.split with regex that splits on both\r\n\t\t\ttext = text.replace( /\\r\\n/g, '\\n' );\r\n\r\n\t\t}\r\n\r\n\t\tif ( text.indexOf( '\\\\\\n' ) !== - 1) {\r\n\r\n\t\t\t// join lines separated by a line continuation character (\\)\r\n\t\t\ttext = text.replace( /\\\\\\n/g, '' );\r\n\r\n\t\t}\r\n\r\n\t\tvar lines = text.split( '\\n' );\r\n\t\tvar line = '', lineFirstChar = '', lineSecondChar = '';\r\n\t\tvar lineLength = 0;\r\n\t\tvar result = [];\r\n\r\n\t\t// Faster to just trim left side of the line. Use if available.\r\n\t\tvar trimLeft = ( typeof ''.trimLeft === 'function' );\r\n\r\n\t\tfor ( var i = 0, l = lines.length; i < l; i ++ ) {\r\n\r\n\t\t\tline = lines[ i ];\r\n\r\n\t\t\tline = trimLeft ? line.trimLeft() : line.trim();\r\n\r\n\t\t\tlineLength = line.length;\r\n\r\n\t\t\tif ( lineLength === 0 ) continue;\r\n\r\n\t\t\tlineFirstChar = line.charAt( 0 );\r\n\r\n\t\t\t// @todo invoke passed in handler if any\r\n\t\t\tif ( lineFirstChar === '#' ) continue;\r\n\r\n\t\t\tif ( lineFirstChar === 'v' ) {\r\n\r\n\t\t\t\tlineSecondChar = line.charAt( 1 );\r\n\r\n\t\t\t\tif ( lineSecondChar === ' ' && ( result = this.regexp.vertex_pattern.exec( line ) ) !== null ) {\r\n\r\n\t\t\t\t\t// 0                  1      2      3\r\n\t\t\t\t\t// [\"v 1.0 2.0 3.0\", \"1.0\", \"2.0\", \"3.0\"]\r\n\r\n\t\t\t\t\tstate.vertices.push(\r\n\t\t\t\t\t\tparseFloat( result[ 1 ] ),\r\n\t\t\t\t\t\tparseFloat( result[ 2 ] ),\r\n\t\t\t\t\t\tparseFloat( result[ 3 ] )\r\n\t\t\t\t\t);\r\n\r\n\t\t\t\t} else if ( lineSecondChar === 'n' && ( result = this.regexp.normal_pattern.exec( line ) ) !== null ) {\r\n\r\n\t\t\t\t\t// 0                   1      2      3\r\n\t\t\t\t\t// [\"vn 1.0 2.0 3.0\", \"1.0\", \"2.0\", \"3.0\"]\r\n\r\n\t\t\t\t\tstate.normals.push(\r\n\t\t\t\t\t\tparseFloat( result[ 1 ] ),\r\n\t\t\t\t\t\tparseFloat( result[ 2 ] ),\r\n\t\t\t\t\t\tparseFloat( result[ 3 ] )\r\n\t\t\t\t\t);\r\n\r\n\t\t\t\t} else if ( lineSecondChar === 't' && ( result = this.regexp.uv_pattern.exec( line ) ) !== null ) {\r\n\r\n\t\t\t\t\t// 0               1      2\r\n\t\t\t\t\t// [\"vt 0.1 0.2\", \"0.1\", \"0.2\"]\r\n\r\n\t\t\t\t\tstate.uvs.push(\r\n\t\t\t\t\t\tparseFloat( result[ 1 ] ),\r\n\t\t\t\t\t\tparseFloat( result[ 2 ] )\r\n\t\t\t\t\t);\r\n\r\n\t\t\t\t} else {\r\n\r\n\t\t\t\t\tthrow new Error( \"Unexpected vertex/normal/uv line: '\" + line  + \"'\" );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t} else if ( lineFirstChar === \"f\" ) {\r\n\r\n\t\t\t\tif ( ( result = this.regexp.face_vertex_uv_normal.exec( line ) ) !== null ) {\r\n\r\n\t\t\t\t\t// f vertex/uv/normal vertex/uv/normal vertex/uv/normal\r\n\t\t\t\t\t// 0                        1    2    3    4    5    6    7    8    9   10         11         12\r\n\t\t\t\t\t// [\"f 1/1/1 2/2/2 3/3/3\", \"1\", \"1\", \"1\", \"2\", \"2\", \"2\", \"3\", \"3\", \"3\", undefined, undefined, undefined]\r\n\r\n\t\t\t\t\tstate.addFace(\r\n\t\t\t\t\t\tresult[ 1 ], result[ 4 ], result[ 7 ], result[ 10 ],\r\n\t\t\t\t\t\tresult[ 2 ], result[ 5 ], result[ 8 ], result[ 11 ],\r\n\t\t\t\t\t\tresult[ 3 ], result[ 6 ], result[ 9 ], result[ 12 ]\r\n\t\t\t\t\t);\r\n\r\n\t\t\t\t} else if ( ( result = this.regexp.face_vertex_uv.exec( line ) ) !== null ) {\r\n\r\n\t\t\t\t\t// f vertex/uv vertex/uv vertex/uv\r\n\t\t\t\t\t// 0                  1    2    3    4    5    6   7          8\r\n\t\t\t\t\t// [\"f 1/1 2/2 3/3\", \"1\", \"1\", \"2\", \"2\", \"3\", \"3\", undefined, undefined]\r\n\r\n\t\t\t\t\tstate.addFace(\r\n\t\t\t\t\t\tresult[ 1 ], result[ 3 ], result[ 5 ], result[ 7 ],\r\n\t\t\t\t\t\tresult[ 2 ], result[ 4 ], result[ 6 ], result[ 8 ]\r\n\t\t\t\t\t);\r\n\r\n\t\t\t\t} else if ( ( result = this.regexp.face_vertex_normal.exec( line ) ) !== null ) {\r\n\r\n\t\t\t\t\t// f vertex//normal vertex//normal vertex//normal\r\n\t\t\t\t\t// 0                     1    2    3    4    5    6   7          8\r\n\t\t\t\t\t// [\"f 1//1 2//2 3//3\", \"1\", \"1\", \"2\", \"2\", \"3\", \"3\", undefined, undefined]\r\n\r\n\t\t\t\t\tstate.addFace(\r\n\t\t\t\t\t\tresult[ 1 ], result[ 3 ], result[ 5 ], result[ 7 ],\r\n\t\t\t\t\t\tundefined, undefined, undefined, undefined,\r\n\t\t\t\t\t\tresult[ 2 ], result[ 4 ], result[ 6 ], result[ 8 ]\r\n\t\t\t\t\t);\r\n\r\n\t\t\t\t} else if ( ( result = this.regexp.face_vertex.exec( line ) ) !== null ) {\r\n\r\n\t\t\t\t\t// f vertex vertex vertex\r\n\t\t\t\t\t// 0            1    2    3   4\r\n\t\t\t\t\t// [\"f 1 2 3\", \"1\", \"2\", \"3\", undefined]\r\n\r\n\t\t\t\t\tstate.addFace(\r\n\t\t\t\t\t\tresult[ 1 ], result[ 2 ], result[ 3 ], result[ 4 ]\r\n\t\t\t\t\t);\r\n\r\n\t\t\t\t} else {\r\n\r\n\t\t\t\t\tthrow new Error( \"Unexpected face line: '\" + line  + \"'\" );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t} else if ( lineFirstChar === \"l\" ) {\r\n\r\n\t\t\t\tvar lineParts = line.substring( 1 ).trim().split( \" \" );\r\n\t\t\t\tvar lineVertices = [], lineUVs = [];\r\n\r\n\t\t\t\tif ( line.indexOf( \"/\" ) === - 1 ) {\r\n\r\n\t\t\t\t\tlineVertices = lineParts;\r\n\r\n\t\t\t\t} else {\r\n\r\n\t\t\t\t\tfor ( var li = 0, llen = lineParts.length; li < llen; li ++ ) {\r\n\r\n\t\t\t\t\t\tvar parts = lineParts[ li ].split( \"/\" );\r\n\r\n\t\t\t\t\t\tif ( parts[ 0 ] !== \"\" ) lineVertices.push( parts[ 0 ] );\r\n\t\t\t\t\t\tif ( parts[ 1 ] !== \"\" ) lineUVs.push( parts[ 1 ] );\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t}\r\n\t\t\t\tstate.addLineGeometry( lineVertices, lineUVs );\r\n\r\n\t\t\t} else if ( ( result = this.regexp.object_pattern.exec( line ) ) !== null ) {\r\n\r\n\t\t\t\t// o object_name\r\n\t\t\t\t// or\r\n\t\t\t\t// g group_name\r\n\r\n\t\t\t\t// WORKAROUND: https://bugs.chromium.org/p/v8/issues/detail?id=2869\r\n\t\t\t\t// var name = result[ 0 ].substr( 1 ).trim();\r\n\t\t\t\tvar name = ( \" \" + result[ 0 ].substr( 1 ).trim() ).substr( 1 );\r\n\r\n\t\t\t\tstate.startObject( name );\r\n\r\n\t\t\t} else if ( this.regexp.material_use_pattern.test( line ) ) {\r\n\r\n\t\t\t\t// material\r\n\r\n\t\t\t\tstate.object.startMaterial( line.substring( 7 ).trim(), state.materialLibraries );\r\n\r\n\t\t\t} else if ( this.regexp.material_library_pattern.test( line ) ) {\r\n\r\n\t\t\t\t// mtl file\r\n\r\n\t\t\t\tstate.materialLibraries.push( line.substring( 7 ).trim() );\r\n\r\n\t\t\t} else if ( ( result = this.regexp.smoothing_pattern.exec( line ) ) !== null ) {\r\n\r\n\t\t\t\t// smooth shading\r\n\r\n\t\t\t\t// @todo Handle files that have varying smooth values for a set of faces inside one geometry,\r\n\t\t\t\t// but does not define a usemtl for each face set.\r\n\t\t\t\t// This should be detected and a dummy material created (later MultiMaterial and geometry groups).\r\n\t\t\t\t// This requires some care to not create extra material on each smooth value for \"normal\" obj files.\r\n\t\t\t\t// where explicit usemtl defines geometry groups.\r\n\t\t\t\t// Example asset: examples/models/obj/cerberus/Cerberus.obj\r\n\r\n\t\t\t\tvar value = result[ 1 ].trim().toLowerCase();\r\n\t\t\t\tstate.object.smooth = ( value === '1' || value === 'on' );\r\n\r\n\t\t\t\tvar material = state.object.currentMaterial();\r\n\t\t\t\tif ( material ) {\r\n\r\n\t\t\t\t\tmaterial.smooth = state.object.smooth;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\t// Handle null terminated files without exception\r\n\t\t\t\tif ( line === '\\0' ) continue;\r\n\r\n\t\t\t\tthrow new Error( \"Unexpected line: '\" + line  + \"'\" );\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\tstate.finalize();\r\n\r\n\t\tvar container = new THREE.Group();\r\n\t\tcontainer.materialLibraries = [].concat( state.materialLibraries );\r\n\r\n\t\tfor ( var i = 0, l = state.objects.length; i < l; i ++ ) {\r\n\r\n\t\t\tvar object = state.objects[ i ];\r\n\t\t\tvar geometry = object.geometry;\r\n\t\t\tvar materials = object.materials;\r\n\t\t\tvar isLine = ( geometry.type === 'Line' );\r\n\r\n\t\t\t// Skip o/g line declarations that did not follow with any faces\r\n\t\t\tif ( geometry.vertices.length === 0 ) continue;\r\n\r\n\t\t\tvar buffergeometry = new THREE.BufferGeometry();\r\n\r\n\t\t\tbuffergeometry.addAttribute( 'position', new THREE.BufferAttribute( new Float32Array( geometry.vertices ), 3 ) );\r\n\r\n\t\t\tif ( geometry.normals.length > 0 ) {\r\n\r\n\t\t\t\tbuffergeometry.addAttribute( 'normal', new THREE.BufferAttribute( new Float32Array( geometry.normals ), 3 ) );\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\tbuffergeometry.computeVertexNormals();\r\n\r\n\t\t\t}\r\n\r\n\t\t\tif ( geometry.uvs.length > 0 ) {\r\n\r\n\t\t\t\tbuffergeometry.addAttribute( 'uv', new THREE.BufferAttribute( new Float32Array( geometry.uvs ), 2 ) );\r\n\r\n\t\t\t}\r\n\r\n\t\t\t// Create materials\r\n\r\n\t\t\tvar createdMaterials = [];\r\n\r\n\t\t\tfor ( var mi = 0, miLen = materials.length; mi < miLen ; mi++ ) {\r\n\r\n\t\t\t\tvar sourceMaterial = materials[mi];\r\n\t\t\t\tvar material = undefined;\r\n\r\n\t\t\t\tif ( this.materials !== null ) {\r\n\r\n\t\t\t\t\tmaterial = this.materials.create( sourceMaterial.name );\r\n\r\n\t\t\t\t\t// mtl etc. loaders probably can't create line materials correctly, copy properties to a line material.\r\n\t\t\t\t\tif ( isLine && material && ! ( material instanceof THREE.LineBasicMaterial ) ) {\r\n\r\n\t\t\t\t\t\tvar materialLine = new THREE.LineBasicMaterial();\r\n\t\t\t\t\t\tmaterialLine.copy( material );\r\n\t\t\t\t\t\tmaterial = materialLine;\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif ( ! material ) {\r\n\r\n\t\t\t\t\tmaterial = ( ! isLine ? new THREE.MeshPhongMaterial() : new THREE.LineBasicMaterial() );\r\n\t\t\t\t\tmaterial.name = sourceMaterial.name;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tmaterial.shading = sourceMaterial.smooth ? THREE.SmoothShading : THREE.FlatShading;\r\n\r\n\t\t\t\tcreatedMaterials.push(material);\r\n\r\n\t\t\t}\r\n\r\n\t\t\t// Create mesh\r\n\r\n\t\t\tvar mesh;\r\n\r\n\t\t\tif ( createdMaterials.length > 1 ) {\r\n\r\n\t\t\t\tfor ( var mi = 0, miLen = materials.length; mi < miLen ; mi++ ) {\r\n\r\n\t\t\t\t\tvar sourceMaterial = materials[mi];\r\n\t\t\t\t\tbuffergeometry.addGroup( sourceMaterial.groupStart, sourceMaterial.groupCount, mi );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tmesh = ( ! isLine ? new THREE.Mesh( buffergeometry, createdMaterials ) : new THREE.LineSegments( buffergeometry, createdMaterials ) );\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\tmesh = ( ! isLine ? new THREE.Mesh( buffergeometry, createdMaterials[ 0 ] ) : new THREE.LineSegments( buffergeometry, createdMaterials[ 0 ] ) );\r\n\t\t\t}\r\n\r\n\t\t\tmesh.name = object.name;\r\n\r\n\t\t\tcontainer.add( mesh );\r\n\r\n\t\t}\r\n\r\n\t\tconsole.timeEnd( 'OBJLoader' );\r\n\r\n\t\treturn container;\r\n\r\n\t}\r\n\r\n};\r\n","/**\r\n * Loads a Wavefront .mtl file specifying materials\r\n *\r\n * @author angelxuanchang\r\n */\r\n\r\nTHREE.MTLLoader = function ( manager ) {\r\n\r\n\tthis.manager = ( manager !== undefined ) ? manager : THREE.DefaultLoadingManager;\r\n\r\n};\r\n\r\nTHREE.MTLLoader.prototype = {\r\n\r\n\tconstructor: THREE.MTLLoader,\r\n\r\n\t/**\r\n\t * Loads and parses a MTL asset from a URL.\r\n\t *\r\n\t * @param {String} url - URL to the MTL file.\r\n\t * @param {Function} [onLoad] - Callback invoked with the loaded object.\r\n\t * @param {Function} [onProgress] - Callback for download progress.\r\n\t * @param {Function} [onError] - Callback for download errors.\r\n\t *\r\n\t * @see setPath setTexturePath\r\n\t *\r\n\t * @note In order for relative texture references to resolve correctly\r\n\t * you must call setPath and/or setTexturePath explicitly prior to load.\r\n\t */\r\n\tload: function ( url, onLoad, onProgress, onError ) {\r\n\r\n\t\tvar scope = this;\r\n\r\n\t\tvar loader = new THREE.FileLoader( this.manager );\r\n\t\tloader.setPath( this.path );\r\n\t\tloader.load( url, function ( text ) {\r\n\r\n\t\t\tonLoad( scope.parse( text ) );\r\n\r\n\t\t}, onProgress, onError );\r\n\r\n\t},\r\n\r\n\t/**\r\n\t * Set base path for resolving references.\r\n\t * If set this path will be prepended to each loaded and found reference.\r\n\t *\r\n\t * @see setTexturePath\r\n\t * @param {String} path\r\n\t *\r\n\t * @example\r\n\t *     mtlLoader.setPath( 'assets/obj/' );\r\n\t *     mtlLoader.load( 'my.mtl', ... );\r\n\t */\r\n\tsetPath: function ( path ) {\r\n\r\n\t\tthis.path = path;\r\n\r\n\t},\r\n\r\n\t/**\r\n\t * Set base path for resolving texture references.\r\n\t * If set this path will be prepended found texture reference.\r\n\t * If not set and setPath is, it will be used as texture base path.\r\n\t *\r\n\t * @see setPath\r\n\t * @param {String} path\r\n\t *\r\n\t * @example\r\n\t *     mtlLoader.setPath( 'assets/obj/' );\r\n\t *     mtlLoader.setTexturePath( 'assets/textures/' );\r\n\t *     mtlLoader.load( 'my.mtl', ... );\r\n\t */\r\n\tsetTexturePath: function ( path ) {\r\n\r\n\t\tthis.texturePath = path;\r\n\r\n\t},\r\n\r\n\tsetBaseUrl: function ( path ) {\r\n\r\n\t\tconsole.warn( 'THREE.MTLLoader: .setBaseUrl() is deprecated. Use .setTexturePath( path ) for texture path or .setPath( path ) for general base path instead.' );\r\n\r\n\t\tthis.setTexturePath( path );\r\n\r\n\t},\r\n\r\n\tsetCrossOrigin: function ( value ) {\r\n\r\n\t\tthis.crossOrigin = value;\r\n\r\n\t},\r\n\r\n\tsetMaterialOptions: function ( value ) {\r\n\r\n\t\tthis.materialOptions = value;\r\n\r\n\t},\r\n\r\n\t/**\r\n\t * Parses a MTL file.\r\n\t *\r\n\t * @param {String} text - Content of MTL file\r\n\t * @return {THREE.MTLLoader.MaterialCreator}\r\n\t *\r\n\t * @see setPath setTexturePath\r\n\t *\r\n\t * @note In order for relative texture references to resolve correctly\r\n\t * you must call setPath and/or setTexturePath explicitly prior to parse.\r\n\t */\r\n\tparse: function ( text ) {\r\n\r\n\t\tvar lines = text.split( '\\n' );\r\n\t\tvar info = {};\r\n\t\tvar delimiter_pattern = /\\s+/;\r\n\t\tvar materialsInfo = {};\r\n\r\n\t\tfor ( var i = 0; i < lines.length; i ++ ) {\r\n\r\n\t\t\tvar line = lines[ i ];\r\n\t\t\tline = line.trim();\r\n\r\n\t\t\tif ( line.length === 0 || line.charAt( 0 ) === '#' ) {\r\n\r\n\t\t\t\t// Blank line or comment ignore\r\n\t\t\t\tcontinue;\r\n\r\n\t\t\t}\r\n\r\n\t\t\tvar pos = line.indexOf( ' ' );\r\n\r\n\t\t\tvar key = ( pos >= 0 ) ? line.substring( 0, pos ) : line;\r\n\t\t\tkey = key.toLowerCase();\r\n\r\n\t\t\tvar value = ( pos >= 0 ) ? line.substring( pos + 1 ) : '';\r\n\t\t\tvalue = value.trim();\r\n\r\n\t\t\tif ( key === 'newmtl' ) {\r\n\r\n\t\t\t\t// New material\r\n\r\n\t\t\t\tinfo = { name: value };\r\n\t\t\t\tmaterialsInfo[ value ] = info;\r\n\r\n\t\t\t} else if ( info ) {\r\n\r\n\t\t\t\tif ( key === 'ka' || key === 'kd' || key === 'ks' ) {\r\n\r\n\t\t\t\t\tvar ss = value.split( delimiter_pattern, 3 );\r\n\t\t\t\t\tinfo[ key ] = [ parseFloat( ss[ 0 ] ), parseFloat( ss[ 1 ] ), parseFloat( ss[ 2 ] ) ];\r\n\r\n\t\t\t\t} else {\r\n\r\n\t\t\t\t\tinfo[ key ] = value;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\tvar materialCreator = new THREE.MTLLoader.MaterialCreator( this.texturePath || this.path, this.materialOptions );\r\n\t\tmaterialCreator.setCrossOrigin( this.crossOrigin );\r\n\t\tmaterialCreator.setManager( this.manager );\r\n\t\tmaterialCreator.setMaterials( materialsInfo );\r\n\t\treturn materialCreator;\r\n\r\n\t}\r\n\r\n};\r\n\r\n/**\r\n * Create a new THREE-MTLLoader.MaterialCreator\r\n * @param baseUrl - Url relative to which textures are loaded\r\n * @param options - Set of options on how to construct the materials\r\n *                  side: Which side to apply the material\r\n *                        THREE.FrontSide (default), THREE.BackSide, THREE.DoubleSide\r\n *                  wrap: What type of wrapping to apply for textures\r\n *                        THREE.RepeatWrapping (default), THREE.ClampToEdgeWrapping, THREE.MirroredRepeatWrapping\r\n *                  normalizeRGB: RGBs need to be normalized to 0-1 from 0-255\r\n *                                Default: false, assumed to be already normalized\r\n *                  ignoreZeroRGBs: Ignore values of RGBs (Ka,Kd,Ks) that are all 0's\r\n *                                  Default: false\r\n * @constructor\r\n */\r\n\r\nTHREE.MTLLoader.MaterialCreator = function ( baseUrl, options ) {\r\n\r\n\tthis.baseUrl = baseUrl || '';\r\n\tthis.options = options;\r\n\tthis.materialsInfo = {};\r\n\tthis.materials = {};\r\n\tthis.materialsArray = [];\r\n\tthis.nameLookup = {};\r\n\r\n\tthis.side = ( this.options && this.options.side ) ? this.options.side : THREE.FrontSide;\r\n\tthis.wrap = ( this.options && this.options.wrap ) ? this.options.wrap : THREE.RepeatWrapping;\r\n\r\n};\r\n\r\nTHREE.MTLLoader.MaterialCreator.prototype = {\r\n\r\n\tconstructor: THREE.MTLLoader.MaterialCreator,\r\n\r\n\tsetCrossOrigin: function ( value ) {\r\n\r\n\t\tthis.crossOrigin = value;\r\n\r\n\t},\r\n\r\n\tsetManager: function ( value ) {\r\n\r\n\t\tthis.manager = value;\r\n\r\n\t},\r\n\r\n\tsetMaterials: function ( materialsInfo ) {\r\n\r\n\t\tthis.materialsInfo = this.convert( materialsInfo );\r\n\t\tthis.materials = {};\r\n\t\tthis.materialsArray = [];\r\n\t\tthis.nameLookup = {};\r\n\r\n\t},\r\n\r\n\tconvert: function ( materialsInfo ) {\r\n\r\n\t\tif ( ! this.options ) return materialsInfo;\r\n\r\n\t\tvar converted = {};\r\n\r\n\t\tfor ( var mn in materialsInfo ) {\r\n\r\n\t\t\t// Convert materials info into normalized form based on options\r\n\r\n\t\t\tvar mat = materialsInfo[ mn ];\r\n\r\n\t\t\tvar covmat = {};\r\n\r\n\t\t\tconverted[ mn ] = covmat;\r\n\r\n\t\t\tfor ( var prop in mat ) {\r\n\r\n\t\t\t\tvar save = true;\r\n\t\t\t\tvar value = mat[ prop ];\r\n\t\t\t\tvar lprop = prop.toLowerCase();\r\n\r\n\t\t\t\tswitch ( lprop ) {\r\n\r\n\t\t\t\t\tcase 'kd':\r\n\t\t\t\t\tcase 'ka':\r\n\t\t\t\t\tcase 'ks':\r\n\r\n\t\t\t\t\t\t// Diffuse color (color under white light) using RGB values\r\n\r\n\t\t\t\t\t\tif ( this.options && this.options.normalizeRGB ) {\r\n\r\n\t\t\t\t\t\t\tvalue = [ value[ 0 ] / 255, value[ 1 ] / 255, value[ 2 ] / 255 ];\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\tif ( this.options && this.options.ignoreZeroRGBs ) {\r\n\r\n\t\t\t\t\t\t\tif ( value[ 0 ] === 0 && value[ 1 ] === 0 && value[ 2 ] === 0 ) {\r\n\r\n\t\t\t\t\t\t\t\t// ignore\r\n\r\n\t\t\t\t\t\t\t\tsave = false;\r\n\r\n\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\tdefault:\r\n\r\n\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif ( save ) {\r\n\r\n\t\t\t\t\tcovmat[ lprop ] = value;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\treturn converted;\r\n\r\n\t},\r\n\r\n\tpreload: function () {\r\n\r\n\t\tfor ( var mn in this.materialsInfo ) {\r\n\r\n\t\t\tthis.create( mn );\r\n\r\n\t\t}\r\n\r\n\t},\r\n\r\n\tgetIndex: function ( materialName ) {\r\n\r\n\t\treturn this.nameLookup[ materialName ];\r\n\r\n\t},\r\n\r\n\tgetAsArray: function () {\r\n\r\n\t\tvar index = 0;\r\n\r\n\t\tfor ( var mn in this.materialsInfo ) {\r\n\r\n\t\t\tthis.materialsArray[ index ] = this.create( mn );\r\n\t\t\tthis.nameLookup[ mn ] = index;\r\n\t\t\tindex ++;\r\n\r\n\t\t}\r\n\r\n\t\treturn this.materialsArray;\r\n\r\n\t},\r\n\r\n\tcreate: function ( materialName ) {\r\n\r\n\t\tif ( this.materials[ materialName ] === undefined ) {\r\n\r\n\t\t\tthis.createMaterial_( materialName );\r\n\r\n\t\t}\r\n\r\n\t\treturn this.materials[ materialName ];\r\n\r\n\t},\r\n\r\n\tcreateMaterial_: function ( materialName ) {\r\n\r\n\t\t// Create material\r\n\r\n\t\tvar scope = this;\r\n\t\tvar mat = this.materialsInfo[ materialName ];\r\n\t\tvar params = {\r\n\r\n\t\t\tname: materialName,\r\n\t\t\tside: this.side\r\n\r\n\t\t};\r\n\r\n\t\tfunction resolveURL( baseUrl, url ) {\r\n\r\n\t\t\tif ( typeof url !== 'string' || url === '' )\r\n\t\t\t\treturn '';\r\n\r\n\t\t\t// Absolute URL\r\n\t\t\tif ( /^https?:\\/\\//i.test( url ) ) return url;\r\n\r\n\t\t\treturn baseUrl + url;\r\n\r\n\t\t}\r\n\r\n\t\tfunction setMapForType( mapType, value ) {\r\n\r\n\t\t\tif ( params[ mapType ] ) return; // Keep the first encountered texture\r\n\r\n\t\t\tvar texParams = scope.getTextureParams( value, params );\r\n\t\t\tvar map = scope.loadTexture( resolveURL( scope.baseUrl, texParams.url ) );\r\n\r\n\t\t\tmap.repeat.copy( texParams.scale );\r\n\t\t\tmap.offset.copy( texParams.offset );\r\n\r\n\t\t\tmap.wrapS = scope.wrap;\r\n\t\t\tmap.wrapT = scope.wrap;\r\n\r\n\t\t\tparams[ mapType ] = map;\r\n\r\n\t\t}\r\n\r\n\t\tfor ( var prop in mat ) {\r\n\r\n\t\t\tvar value = mat[ prop ];\r\n\r\n\t\t\tif ( value === '' ) continue;\r\n\r\n\t\t\tswitch ( prop.toLowerCase() ) {\r\n\r\n\t\t\t\t// Ns is material specular exponent\r\n\r\n\t\t\t\tcase 'kd':\r\n\r\n\t\t\t\t\t// Diffuse color (color under white light) using RGB values\r\n\r\n\t\t\t\t\tparams.color = new THREE.Color().fromArray( value );\r\n\r\n\t\t\t\t\tbreak;\r\n\r\n\t\t\t\tcase 'ks':\r\n\r\n\t\t\t\t\t// Specular color (color when light is reflected from shiny surface) using RGB values\r\n\t\t\t\t\tparams.specular = new THREE.Color().fromArray( value );\r\n\r\n\t\t\t\t\tbreak;\r\n\r\n\t\t\t\tcase 'map_kd':\r\n\r\n\t\t\t\t\t// Diffuse texture map\r\n\r\n\t\t\t\t\tsetMapForType( \"map\", value );\r\n\r\n\t\t\t\t\tbreak;\r\n\r\n\t\t\t\tcase 'map_ks':\r\n\r\n\t\t\t\t\t// Specular map\r\n\r\n\t\t\t\t\tsetMapForType( \"specularMap\", value );\r\n\r\n\t\t\t\t\tbreak;\r\n\r\n\t\t\t\tcase 'map_bump':\r\n\t\t\t\tcase 'bump':\r\n\r\n\t\t\t\t\t// Bump texture map\r\n\r\n\t\t\t\t\tsetMapForType( \"bumpMap\", value );\r\n\r\n\t\t\t\t\tbreak;\r\n\r\n\t\t\t\tcase 'ns':\r\n\r\n\t\t\t\t\t// The specular exponent (defines the focus of the specular highlight)\r\n\t\t\t\t\t// A high exponent results in a tight, concentrated highlight. Ns values normally range from 0 to 1000.\r\n\r\n\t\t\t\t\tparams.shininess = parseFloat( value );\r\n\r\n\t\t\t\t\tbreak;\r\n\r\n\t\t\t\tcase 'd':\r\n\r\n\t\t\t\t\tif ( value < 1 ) {\r\n\r\n\t\t\t\t\t\tparams.opacity = value;\r\n\t\t\t\t\t\tparams.transparent = true;\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tbreak;\r\n\r\n\t\t\t\tcase 'Tr':\r\n\r\n\t\t\t\t\tif ( value > 0 ) {\r\n\r\n\t\t\t\t\t\tparams.opacity = 1 - value;\r\n\t\t\t\t\t\tparams.transparent = true;\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tbreak;\r\n\r\n\t\t\t\tdefault:\r\n\t\t\t\t\tbreak;\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\tthis.materials[ materialName ] = new THREE.MeshPhongMaterial( params );\r\n\t\treturn this.materials[ materialName ];\r\n\r\n\t},\r\n\r\n\tgetTextureParams: function ( value, matParams ) {\r\n\r\n\t\tvar texParams = {\r\n\r\n\t\t\tscale: new THREE.Vector2( 1, 1 ),\r\n\t\t\toffset: new THREE.Vector2( 0, 0 )\r\n\r\n\t\t };\r\n\r\n\t\tvar items = value.split( /\\s+/ );\r\n\t\tvar pos;\r\n\r\n\t\tpos = items.indexOf( '-bm' );\r\n\r\n\t\tif ( pos >= 0 ) {\r\n\r\n\t\t\tmatParams.bumpScale = parseFloat( items[ pos + 1 ] );\r\n\t\t\titems.splice( pos, 2 );\r\n\r\n\t\t}\r\n\r\n\t\tpos = items.indexOf( '-s' );\r\n\r\n\t\tif ( pos >= 0 ) {\r\n\r\n\t\t\ttexParams.scale.set( parseFloat( items[ pos + 1 ] ), parseFloat( items[ pos + 2 ] ) );\r\n\t\t\titems.splice( pos, 4 ); // we expect 3 parameters here!\r\n\r\n\t\t}\r\n\r\n\t\tpos = items.indexOf( '-o' );\r\n\r\n\t\tif ( pos >= 0 ) {\r\n\r\n\t\t\ttexParams.offset.set( parseFloat( items[ pos + 1 ] ), parseFloat( items[ pos + 2 ] ) );\r\n\t\t\titems.splice( pos, 4 ); // we expect 3 parameters here!\r\n\r\n\t\t}\r\n\r\n\t\ttexParams.url = items.join( ' ' ).trim();\r\n\t\treturn texParams;\r\n\r\n\t},\r\n\r\n\tloadTexture: function ( url, mapping, onLoad, onProgress, onError ) {\r\n\r\n\t\tvar texture;\r\n\t\tvar loader = THREE.Loader.Handlers.get( url );\r\n\t\tvar manager = ( this.manager !== undefined ) ? this.manager : THREE.DefaultLoadingManager;\r\n\r\n\t\tif ( loader === null ) {\r\n\r\n\t\t\tloader = new THREE.TextureLoader( manager );\r\n\r\n\t\t}\r\n\r\n\t\tif ( loader.setCrossOrigin ) loader.setCrossOrigin( this.crossOrigin );\r\n\t\ttexture = loader.load( url, onLoad, onProgress, onError );\r\n\r\n\t\tif ( mapping !== undefined ) texture.mapping = mapping;\r\n\r\n\t\treturn texture;\r\n\r\n\t}\r\n\r\n};\r\n","/**\r\n* KalmanFilter\r\n* @class\r\n* @author Wouter Bulten\r\n* @see {@link http://github.com/wouterbulten/kalmanjs}\r\n* @version Version: 1.0.0-beta\r\n* @copyright Copyright 2015 Wouter Bulten\r\n* @license GNU LESSER GENERAL PUBLIC LICENSE v3\r\n* @preserve\r\n*/\r\n\r\n\r\n\r\nfunction KalmanFilter(params) {\r\n\t/**\r\n\t* Create 1-dimensional kalman filter\r\n\t* @param  {Number} options.R Process noise\r\n\t* @param  {Number} options.Q Measurement noise\r\n\t* @param  {Number} options.A State vector\r\n\t* @param  {Number} options.B Control vector\r\n\t* @param  {Number} options.C Measurement vector\r\n\t* @return {KalmanFilter}\r\n\t*/\r\n\r\n\tthis.R = typeof params.R == \"undefined\" ? 1 : params.R; // noise power desirable\r\n\tthis.Q = typeof params.Q == \"undefined\" ? 1 : params.Q; // noise power estimated\r\n\r\n\tthis.A = typeof params.A == \"undefined\" ? 1 : params.A;\r\n\tthis.C = typeof params.C == \"undefined\" ? 1 : params.C;\r\n\tthis.B = typeof params.B == \"undefined\" ? 0 : params.B;\r\n\tthis.cov = NaN;\r\n\tthis.x = NaN; // estimated signal without noise\r\n}\r\n\r\n/**\r\n* Filter a new value\r\n* @param  {Number} z Measurement\r\n* @param  {Number} u Control\r\n* @return {Number}\r\n*/\r\nKalmanFilter.prototype.filter = function (z, u) {\r\n\tif (typeof u == \"undefined\")\r\n\t\tu = 0;\r\n\tif (isNaN(this.x)) {\r\n\t\tthis.x = (1 / this.C) * z;\r\n\t\tthis.cov = (1 / this.C) * this.Q * (1 / this.C);\r\n\t}\r\n\telse {\r\n\r\n\t\t// Compute prediction\r\n\t\tconst predX = (this.A * this.x) + (this.B * u);\r\n\t\tconst predCov = ((this.A * this.cov) * this.A) + this.R;\r\n\r\n\t\t// Kalman gain\r\n\t\tconst K = predCov * this.C * (1 / ((this.C * predCov * this.C) + this.Q));\r\n\r\n\t\t// Correction\r\n\t\tthis.x = predX + K * (z - (this.C * predX));\r\n\t\tthis.cov = predCov - (K * this.C * predCov);\r\n\t}\r\n\r\n\treturn this.x;\r\n}\r\n\r\n/**\r\n* Return the last filtered measurement\r\n* @return {Number}\r\n*/\r\nKalmanFilter.prototype.lastMeasurement = function () {\r\n\treturn this.x;\r\n}\r\n\r\n/**\r\n* Set measurement noise Q\r\n* @param {Number} noise\r\n*/\r\nKalmanFilter.prototype.setMeasurementNoise = function (noise) {\r\n\tthis.Q = noise;\r\n}\r\n\r\n/**\r\n* Set the process noise R\r\n* @param {Number} noise\r\n*/\r\nKalmanFilter.prototype.setProcessNoise = function (noise) {\r\n\tthis.R = noise;\r\n}\r\n\r\n","/*    Copyright 2017 Jocly\r\n *\r\n *    This program is free software: you can redistribute it and/or  modify\r\n *    it under the terms of the GNU Affero General Public License, version 3,\r\n *    as published by the Free Software Foundation.\r\n *\r\n *    This program is distributed in the hope that it will be useful,\r\n *    but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\r\n *    GNU Affero General Public License for more details.\r\n *\r\n *    You should have received a copy of the GNU Affero General Public License\r\n *    along with this program.  If not, see <http://www.gnu.org/licenses/>.\r\n *\r\n *    As a special exception, the copyright holders give permission to link the\r\n *    code of portions of this program with the OpenSSL library under certain\r\n *    conditions as described in each individual source file and distribute\r\n *    linked combinations including the program with the OpenSSL library. You\r\n *    must comply with the GNU Affero General Public License in all respects\r\n *    for all of the code used other than as permitted herein. If you modify\r\n *    file(s) with this exception, you may extend this exception to your\r\n *    version of the file(s), but you are not obligated to do so. If you do not\r\n *    wish to do so, delete this exception statement from your version. If you\r\n *    delete this exception statement from all source files in the program,\r\n *    then also delete it in the license file.\r\n */\r\n\r\nJoclyAR = (function($) {\r\n\r\n    var running = false;\r\n    var videoElement = null;\r\n    var canvas, context;\r\n    var width = 320, height = 240;\r\n    var modelSize = 5;\r\n    var scale = .2;\r\n    var threeCtx = null;\r\n    var processing = false;\r\n    var arWorker = null;\r\n    var oposition = new THREE.Vector3();\r\n    var oeuler = new THREE.Euler();\r\n\r\n    function AnimationFrame() {\r\n        if(!running)\r\n            return;\r\n        if(!processing && videoElement.readyState === videoElement.HAVE_ENOUGH_DATA) {\r\n            processing = true;\r\n            context.drawImage(videoElement,0,0,width,height);\r\n            var imageData = context.getImageData(0, 0, width, height);\r\n            arWorker.postMessage({\r\n                type: \"Detect\",\r\n                imageData: imageData,\r\n                vwidth: videoElement.clientWidth,\r\n                vheight: videoElement.clientHeight\r\n            });\r\n        } else\r\n            requestAnimationFrame(AnimationFrame);\r\n    }\r\n\r\n    var mouseDownY = null, scale0 = scale;\r\n    function MouseMove(event) {\r\n        var y = event.clientY;\r\n        var ratio = (y-mouseDownY) / event.target.clientHeight;\r\n        scale = scale0 * (1 - ratio);\r\n        threeCtx.animControl.trigger();\r\n    }\r\n    function Mouse(event) {\r\n        switch(event.type) {\r\n            case 'mousedown':\r\n                if(event.button==1 || event.button==2) {\r\n                    mouseDownY = event.clientY;\r\n                    scale0 = scale;\r\n                    event.target.addEventListener('mousemove',MouseMove);\r\n                }\r\n                break;\r\n            case 'mouseup':\r\n            case 'mouseout':\r\n                event.target.removeEventListener('mousemove',MouseMove);\r\n        }\r\n    }\r\n\r\n    var exports = {\r\n        start: function() {\r\n            JoclyPlazza.webrtc.startLocal(true,{\r\n                video: {\r\n                    width: { ideal: width },\r\n                    height: { ideal: height },\r\n                    facingMode: \"environment\",\r\n                    frameRate: {ideal: 24 }\r\n                }\r\n            });\r\n        },\r\n        stop: function() {\r\n            JoclyPlazza.webrtc.setChannel(null);\r\n        },\r\n        attach: function(data) {\r\n            videoElement = data.element;\r\n            JoclyPlazza.webrtc.attachMediaStream(data.element,data.stream);\r\n            canvas = document.createElement(\"canvas\");\r\n            canvas.setAttribute(\"width\",width);\r\n            canvas.setAttribute(\"height\",height);\r\n            Object.assign(canvas.style,{\r\n                width: width,\r\n                height: height,\r\n                visibility : \"hidden\",\r\n                position: \"absolute\",\r\n                \"z-index\": -2,\r\n                top: 0,\r\n            });\r\n            document.body.appendChild(canvas);\r\n            /*\r\n            $(\"<canvas/>\")\r\n                .attr(\"width\", width).attr(\"height\",height)\r\n                .width(width).height(height)\r\n                .css({\r\n                    visibility : \"hidden\",\r\n                    position: \"absolute\",\r\n                    \"z-index\": -2,\r\n                    top: 0,\r\n            }).appendTo(\"body\");\r\n            */\r\n            context = canvas.getContext(\"2d\");\r\n            threeCtx = data.threeCtx;\r\n            running = true;\r\n            processing = false;\r\n            threeCtx.renderer.domElement.addEventListener(\"mousedown\",Mouse);\r\n            threeCtx.renderer.domElement.addEventListener(\"mouseup\",Mouse);\r\n            threeCtx.renderer.domElement.addEventListener(\"mouseout\",Mouse);\r\n\r\n       \t\tarWorker = new Worker(JoclyPlazza.config.baseURL+JoclyPlazza.config.joclyPath+'/jocly.arworker.js');\r\n            arWorker.onmessage = function(e) {\r\n                processing = false;\r\n                var message = e.data;\r\n                switch(message.type) {\r\n                    case \"Pose\":\r\n                        var rotation = message.rotation;\r\n                        var translation = message.translation;\r\n\r\n                        threeCtx.body.position.set(0,0,0);\r\n                        threeCtx.camera.lookAt(new THREE.Vector3(0,-1,0));\r\n\r\n                        threeCtx.harbor.scale.set(modelSize*scale,modelSize*scale,modelSize*scale);\r\n\r\n                        threeCtx.harbor.rotation.set(\r\n                            -Math.asin(-rotation[1][2]),\r\n                            Math.atan2(rotation[1][0], rotation[1][1]),\r\n                            -Math.atan2(rotation[0][2], rotation[2][2])\r\n                        );\r\n                        threeCtx.harbor.position.set(\r\n                            translation[0],\r\n                            -translation[2],\r\n                            -translation[1]\r\n                        );\r\n                        if(!threeCtx.harbor.position.equals(oposition) ||\r\n                            !threeCtx.harbor.rotation.equals(oeuler))\r\n                            threeCtx.animControl.trigger();\r\n                        oposition.copy(threeCtx.harbor.position);\r\n                        oeuler.copy(threeCtx.harbor.rotation);\r\n                        break;\r\n                    case \"NoPose\":\r\n                        break;\r\n                }\r\n                setTimeout(AnimationFrame,20);\r\n            }\r\n            arWorker.postMessage({\r\n                type: \"Init\",\r\n                baseUrl: JoclyPlazza.config.baseURL+JoclyPlazza.config.joclyPath,\r\n                modelSize: modelSize,\r\n                width: width,\r\n                height: height\r\n            });\r\n            requestAnimationFrame(AnimationFrame);\r\n        },\r\n        detach: function(data) {\r\n            threeCtx.renderer.domElement.removeEventListener(\"mousedown\",Mouse);\r\n            threeCtx.renderer.domElement.removeEventListener(\"mouseup\",Mouse);\r\n            threeCtx.renderer.domElement.removeEventListener(\"mouseout\",Mouse);\r\n            JoclyPlazza.webrtc.detachMediaStream(data.element);\r\n            videoElement = null;\r\n            running = false;\r\n            canvas.parentNode.removeChild(canvas);\r\n            context = null;\r\n            threeCtx = null;\r\n            arWorker.terminate();\r\n            arWorker = null;\r\n        }\r\n    }\r\n\r\n    return exports;\r\n\r\n\r\n})();\r\n\r\n","/*    Copyright 2017 Jocly\r\n *\r\n *    This program is free software: you can redistribute it and/or  modify\r\n *    it under the terms of the GNU Affero General Public License, version 3,\r\n *    as published by the Free Software Foundation.\r\n *\r\n *    This program is distributed in the hope that it will be useful,\r\n *    but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\r\n *    GNU Affero General Public License for more details.\r\n *\r\n *    You should have received a copy of the GNU Affero General Public License\r\n *    along with this program.  If not, see <http://www.gnu.org/licenses/>.\r\n *\r\n *    As a special exception, the copyright holders give permission to link the\r\n *    code of portions of this program with the OpenSSL library under certain\r\n *    conditions as described in each individual source file and distribute\r\n *    linked combinations including the program with the OpenSSL library. You\r\n *    must comply with the GNU Affero General Public License in all respects\r\n *    for all of the code used other than as permitted herein. If you modify\r\n *    file(s) with this exception, you may extend this exception to your\r\n *    version of the file(s), but you are not obligated to do so. If you do not\r\n *    wish to do so, delete this exception statement from your version. If you\r\n *    delete this exception statement from all source files in the program,\r\n *    then also delete it in the license file.\r\n */\r\n\r\nfunction JHStateMachine() {\r\n\r\n}\r\n\r\nJHStateMachine.prototype={}\r\n\r\nJHStateMachine.prototype.init=function() {\r\n\tthis.smState=null;\r\n\tthis.smStates={};\r\n\tthis.smEventQueue=[];\r\n\tthis.smScheduled=false;\r\n\tthis.smPauseNotified=false;\r\n\tthis.smPaused=true;\r\n\tthis.smHistory=[];\r\n\tthis.smGroups={};\r\n}\r\n\r\nJHStateMachine.prototype.smDebug=function() {}\r\nJHStateMachine.prototype.smWarning=function() {}\r\nJHStateMachine.prototype.smError=function() {}\r\n\r\nJHStateMachine.prototype.smTransition=function(states,events,newState,methods) {\r\n\tstates=this.smSolveStates(states);\r\n\tif(typeof(events)==\"string\") {\r\n\t\tevents=[events];\r\n\t}\r\n\tif(typeof(methods)==\"string\") {\r\n\t\tmethods=[methods];\r\n\t}\r\n\tfor(var s in states) {\r\n\t\tvar stateName=states[s];\r\n\t\tif(typeof(this.smStates[stateName])==\"undefined\") {\r\n\t\t\tthis.smStates[stateName]={\r\n\t\t\t\ttransitions: {},\r\n\t\t\t\tenteringMethods: [],\r\n\t\t\t\tleavingMethods: []\r\n\t\t\t}\r\n\t\t}\r\n\t\tfor(var e in events) {\r\n\t\t\tvar eventName=events[e];\r\n\t\t\tif(typeof(this.smStates[stateName].transitions[eventName])==\"undefined\") {\r\n\t\t\t\tthis.smStates[stateName].transitions[eventName]={\r\n\t\t\t\t\tstate: (newState!=null)?newState:stateName,\r\n\t\t\t\t\tmethods: []\r\n\t\t\t\t};\r\n\t\t\t}\r\n\t\t\tfor(var m in methods) {\r\n\t\t\t\tvar methodName=methods[m];\r\n\t\t\t\tthis.smStates[stateName].transitions[eventName].methods.push(methodName);\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\tif(newState!=null && typeof(this.smStates[newState])==\"undefined\") {\r\n\t\tthis.smStates[newState]={\r\n\t\t\ttransitions: {},\r\n\t\t\tenteringMethods: [],\r\n\t\t\tleavingMethods: []\r\n\t\t}\r\n\t}\r\n}\r\n\r\nJHStateMachine.prototype.smEntering=function(states,methods) {\r\n\tif(typeof(states)==\"string\") {\r\n\t\tstates=[states];\r\n\t}\r\n\tif(typeof(methods)==\"string\") {\r\n\t\tmethods=[methods];\r\n\t}\r\n\tfor(var s in states) {\r\n\t\tvar stateName=states[s];\r\n\t\tif(typeof(this.smStates[stateName])==\"undefined\") {\r\n\t\t\tthis.smStates[stateName]={\r\n\t\t\t\ttransitions: {},\r\n\t\t\t\tenteringMethods: [],\r\n\t\t\t\tleavingMethods: []\r\n\t\t\t}\r\n\t\t}\r\n\t\tfor(var m in methods) {\r\n\t\t\tvar methodName=methods[m];\r\n\t\t\tthis.smStates[stateName].enteringMethods.push(methodName);\r\n\t\t}\r\n\t}\r\n}\r\n\r\nJHStateMachine.prototype.smLeaving=function(states,methods) {\r\n\tif(typeof(states)==\"string\") {\r\n\t\tstates=[states];\r\n\t}\r\n\tif(typeof(methods)==\"string\") {\r\n\t\tmethods=[methods];\r\n\t}\r\n\tfor(var s in states) {\r\n\t\tvar stateName=states[s];\r\n\t\tif(typeof(this.smStates[stateName])==\"undefined\") {\r\n\t\t\tthis.smStates[stateName]={\r\n\t\t\t\ttransitions: {},\r\n\t\t\t\tenteringMethods: [],\r\n\t\t\t\tleavingMethods: []\r\n\t\t\t}\r\n\t\t}\r\n\t\tfor(var m in methods) {\r\n\t\t\tvar methodName=methods[m];\r\n\t\t\tthis.smStates[stateName].leavingMethods.push(methodName);\r\n\t\t}\r\n\t}\r\n}\r\n\r\nJHStateMachine.prototype.smStateGroup=function(group,states) {\r\n\tif(typeof(states)==\"string\")\r\n\t\tstates=[states];\r\n\tif(typeof(this.smGroups[group])==\"undefined\")\r\n\t\tthis.smGroups[group]=[];\r\n\tstates=this.smSolveStates(states);\r\n\tfor(var i in states) {\r\n\t\tvar state=states[i];\r\n\t\tif(!this.smContained(state,this.smGroups[group]))\r\n\t\t\tthis.smGroups[group].push(state);\r\n\t}\r\n}\r\n\r\nJHStateMachine.prototype.smSetInitialState=function(state) {\r\n\tthis.smState=state;\r\n}\r\n\r\nJHStateMachine.prototype.smGetState=function() {\r\n\treturn this.smState;\r\n}\r\n\r\nJHStateMachine.prototype.smHandleEvent=function(event,args) {\r\n\r\n\tif(typeof(this.smStates[this.smState])==\"undefined\") {\r\n\t\tconsole.error(\"Unknown state '\",this.smState,\"'\");\r\n\t\treturn;\r\n\t}\r\n\tvar hEntry={\r\n\t\t\tdate: new Date().getTime(),\r\n\t\t\tfromState: this.smState,\r\n\t\t\tevent: event,\r\n\t\t\tmethods: []\r\n\t}\r\n\ttry {\r\n\t\thEntry.args=JSON.stringify(args);\r\n\t} catch(e) {\r\n\t\t//console.error(\"handleEvent(event,...) JSON.stringify(args): \",e);\r\n\t}\r\n\r\n\tvar transition=this.smStates[this.smState].transitions[event];\r\n\tif(typeof(transition)==\"undefined\") {\r\n\t\tconsole.warn(\"JHStateMachine: Event '\",event,\"' not handled in state '\",this.smState,\"'\");\r\n\t\treturn;\r\n\t}\r\n\r\n\tthis.smCurrentEvent=event;\r\n\r\n\tvar stateChanged=(this.smState!=transition.state);\r\n\r\n\tif(stateChanged) {\r\n\t\tvar leavingMethods=this.smStates[this.smState].leavingMethods;\r\n\t\tfor(var i in leavingMethods) {\r\n\t\t\ttry {\r\n\t\t\t\thEntry.methods.push(leavingMethods[i]);\r\n\t\t\t\tif(typeof leavingMethods[i]==\"function\")\r\n\t\t\t\t\tleavingMethods[i].call(this,args);\r\n\t\t\t\telse\r\n\t\t\t\t\tthis['$'+leavingMethods[i]](args);\r\n\t\t\t} catch(e) {\r\n\t\t\t\tconsole.error(\"Exception in leaving [\",this.smState,\"] --> \"+\r\n\t\t\t\t\t\t(typeof leavingMethods[i]==\"function\"?leavingMethods[i].name:leavingMethods[i])\r\n\t\t\t\t+\"(\",args,\"): \",e);\r\n\t\t\t\tthrow e;\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\tfor(var i in transition.methods) {\r\n\t\ttry {\r\n\t\t\thEntry.methods.push(transition.methods[i]);\r\n\t\t\tif(typeof transition.methods[i]==\"function\")\r\n\t\t\t\ttransition.methods[i].call(this,args);\r\n\t\t\telse\r\n\t\t\t\tthis['$'+transition.methods[i]](args);\r\n\t\t} catch(e) {\r\n\t\t\tconsole.error(\"Exception in [\"+this.smState+\"] -- \"+event+\" --> \"+\r\n\t\t\t\t\t(typeof transition.methods[i]==\"function\"?transition.methods[i].name:transition.methods[i])\r\n\t\t\t\t+\"(\",args,\"): \",\r\n\t\t\t\t\te);\r\n\t\t\tthrow e;\r\n\t\t}\r\n\t}\r\n\r\n\tthis.smJHStateMachineLeavingState(this.smState,event,args);\r\n\r\n\r\n\tthis.smDebug(\"{\",this.smState,\"} == [\",event,\"] ==> {\",transition.state,\"}\");\r\n\r\n\r\n\tthis.smState=transition.state;\r\n\r\n\tif(stateChanged) {\r\n\t\tvar enteringMethods=this.smStates[this.smState].enteringMethods;\r\n\t\tfor(var i in enteringMethods) {\r\n\t\t\ttry {\r\n\t\t\t\thEntry.methods.push(enteringMethods[i]);\r\n\t\t\t\tif(typeof enteringMethods[i]==\"function\")\r\n\t\t\t\t\tenteringMethods[i].call(this,args);\r\n\t\t\t\telse\r\n\t\t\t\t\tthis['$'+enteringMethods[i]](args);\r\n\t\t\t} catch(e) {\r\n\t\t\t\tconsole.error(\"Exception in entering [\"+this.smState+\"] --> \"+\r\n\t\t\t\t\t\t(typeof enteringMethods[i]==\"function\"?enteringMethods[i].name:enteringMethods[i])\r\n\t\t\t\t+\"(\",args,\"): \",e);\r\n\t\t\t\tthrow e;\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\tthis.smCurrentEvent=null;\r\n\r\n\tthis.smJHStateMachineEnteringState(this.smState,event,args);\r\n\r\n\thEntry.toState=this.smState;\r\n\tthis.smHistory.splice(0,0,hEntry);\r\n\twhile(this.smHistory.length>50)\r\n\t\tthis.smHistory.pop();\r\n}\r\n\r\nJHStateMachine.prototype.smPlay=function() {\r\n\tvar $this=this;\r\n\tif(this.smPaused) {\r\n\t\tthis.smPaused=false;\r\n\t\tsetTimeout(function() {\r\n\t\t\t$this.smRun();\r\n\t\t},0);\r\n\t}\r\n}\r\n\r\nJHStateMachine.prototype.smPause=function() {\r\n\tthis.smPaused=true;\r\n}\r\n\r\nJHStateMachine.prototype.smStep=function() {\r\n\tthis.smPauseNotified=false;\r\n\tif(this.smEventQueue.length>0) {\r\n\t\tvar eventItem=this.smEventQueue.shift();\r\n\t\tthis.smHandleEvent(eventItem.event,eventItem.args);\r\n\t}\r\n\tthis.smNotifyPause();\r\n}\r\n\r\nJHStateMachine.prototype.smRun=function() {\r\n\tthis.smScheduled=false;\r\n\r\n\tvar stepCount=0;\r\n\twhile(this.smEventQueue.length>0) {\r\n\t\tif(this.smPaused) {\r\n\t\t\tthis.smRunEnd(stepCount);\r\n\t\t\treturn;\r\n\t\t} else {\r\n\t\t\tstepCount++;\r\n\t\t\tthis.smStep();\r\n\t\t}\r\n\t}\r\n\twhile(this.smPaused==false && this.smEventQueue.length>0) {\r\n\t\tstepCount++;\r\n\t\tthis.smStep();\r\n\t}\r\n\tthis.smRunEnd(stepCount);\r\n}\r\n\r\nJHStateMachine.prototype.smRunEnd=function() {\r\n}\r\n\r\nJHStateMachine.prototype.smQueueEvent=function(event,args) {\r\n\tvar self=this;\r\n\tthis.smEventQueue.push({event: event, args: args});\r\n\tthis.smNotifyPause();\r\n\tif(!this.smScheduled) {\r\n\t\tthis.smScheduled=true;\r\n\t\tsetTimeout(function() {\r\n\t\t\tself.smRun();\r\n\t\t},0);\r\n\t}\r\n}\r\n\r\nJHStateMachine.prototype.smNotifyPause=function() {\r\n\tif(this.smEventQueue.length>0 && this.smPaused==true) {\r\n\t\tvar item=this.smEventQueue[0];\r\n\t\tthis.smJHStateMachinePaused(item.event,item.args);\r\n\t}\r\n}\r\n\r\nJHStateMachine.prototype.smJHStateMachineEnteringState=function(state,event,args) {\r\n}\r\n\r\nJHStateMachine.prototype.smJHStateMachineLeavingState=function(state,event,args) {\r\n}\r\n\r\nJHStateMachine.prototype.smJHStateMachinePaused=function(state,event,args) {\r\n}\r\n\r\nJHStateMachine.prototype.smGetTable=function() {\r\n\tvar cells={}\r\n\tfor(var s in this.smStates) {\r\n\t\tvar state=this.smStates[s];\r\n\t\tfor(var e in state.transitions) {\r\n\t\t\tvar toState=state.transitions[e].state;\r\n\t\t\tvar cellname=s+\"/\"+toState;\r\n\t\t\tif(typeof(cells[cellname])==\"undefined\") {\r\n\t\t\t\tcells[cellname]={};\r\n\t\t\t}\r\n\t\t\tcells[cellname][e]=[];\r\n\t\t\tif(s!=toState) {\r\n\t\t\t\tfor(var m in state.leavingMethods) {\r\n\t\t\t\t\tcells[cellname][e].push(state.leavingMethods[m]);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tfor(var m in state.transitions[e].methods) {\r\n\t\t\t\tcells[cellname][e].push(state.transitions[e].methods[m]);\r\n\t\t\t}\r\n\t\t\tif(s!=toState) {\r\n\t\t\t\tfor(var m in this.smStates[toState].enteringMethods) {\r\n\t\t\t\t\tcells[cellname][e].push(this.smStates[toState].enteringMethods[m]);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\tvar table=[\"<table><tr><td></td>\"];\r\n\tfor(var s in this.smStates) {\r\n\t\ttable.push(\"<td class='state'>\"+s+\"</td>\");\r\n\t}\r\n\ttable.push(\"</tr>\");\r\n\tfor(var s1 in this.smStates) {\r\n\t\ttable.push(\"<tr><td class='state'>\"+s1+\"</td>\");\r\n\t\tvar state1=this.smStates[s1];\r\n\t\tfor(var s2 in this.smStates) {\r\n\t\t\tvar state2=this.smStates[s2];\r\n\t\t\tvar cellname=s1+\"/\"+s2;\r\n\t\t\tif(typeof(cells[cellname])==\"undefined\") {\r\n\t\t\t\ttable.push(\"<td class='empty'></td>\");\r\n\t\t\t} else {\r\n\t\t\t\ttable.push(\"<td class='transition'>\");\r\n\t\t\t\tfor(var e in cells[cellname]) {\r\n\t\t\t\t\ttable.push(\"<div class='event'>\");\r\n\t\t\t\t\ttable.push(\"<div class='eventname'>\"+e+\"</div>\");\r\n\t\t\t\t\tfor(var m in cells[cellname][e]) {\r\n\t\t\t\t\t\ttable.push(\"<div class='method'>\"+cells[cellname][e][m]+\"</div>\");\r\n\t\t\t\t\t}\r\n\t\t\t\t\ttable.push(\"</div>\");\r\n\t\t\t\t}\r\n\t\t\t\ttable.push(\"</td>\");\r\n\t\t\t}\r\n\t\t}\r\n\t\ttable.push(\"</tr>\");\r\n\t}\r\n\ttable.push(\"</table>\");\r\n\treturn table.join(\"\");\r\n}\r\n\r\nJHStateMachine.prototype.smGetHistoryTable=function() {\r\n\tvar table=[\"<table><tr><th>Date</th><th>To</th><th>Event</th><th>Methods</th><th>From</th></tr>\"];\r\n\tfor(var i in this.smHistory) {\r\n\t\tvar hEntry=this.smHistory[i];\r\n\t\ttable.push(\"<tr>\");\r\n\t\tvar date=new Date(hEntry.date);\r\n\t\tvar timestamp=date.getHours()+\":\"+date.getMinutes()+\":\"+date.getSeconds()+\".\"+date.getMilliseconds();\r\n\t\ttable.push(\"<td class='timestamp'>\"+timestamp+\"</td>\");\r\n\t\ttable.push(\"<td class='to'>\"+hEntry.toState+\"</td>\");\r\n\t\ttable.push(\"<td><div class='event'>\"+hEntry.event+\"</div><div class='args'>(\"+hEntry.args+\")</div></td>\");\r\n\t\ttable.push(\"<td class='methods'>\");\r\n\t\tfor(var j in hEntry.methods) {\r\n\t\t\ttable.push(hEntry.methods[j]+\"<br/>\");\r\n\t\t}\r\n\t\ttable.push(\"</td>\");\r\n\t\ttable.push(\"<td class='from'>\"+hEntry.fromState+\"</td>\");\r\n\t\ttable.push(\"</tr>\");\r\n\t}\r\n\ttable.push(\"</table>\");\r\n\treturn table.join(\"\");\r\n}\r\n\r\nJHStateMachine.prototype.smSolveStates=function(states) {\r\n\tvar states0=[];\r\n\tif(typeof(states)==\"string\") {\r\n\t\tstates=[states];\r\n\t}\r\n\tfor(var s in states) {\r\n\t\tvar state=states[s];\r\n\t\tif(typeof(this.smGroups[state])==\"undefined\") {\r\n\t\t\tif(!this.smContained(state,states0))\r\n\t\t\t\tstates0.push(state);\r\n\t\t} else {\r\n\t\t\tfor(var s0 in this.smGroups[state])\r\n\t\t\t\tif(!this.smContained(this.smGroups[state][s0],states0))\r\n\t\t\t\t\tstates0.push(this.smGroups[state][s0]);\r\n\t\t}\r\n\t}\r\n\treturn states0;\r\n}\r\n\r\nJHStateMachine.prototype.smContained=function(state,group) {\r\n\tfor(var i in group) {\r\n\t\tif(state==group[i])\r\n\t\t\treturn true;\r\n\t}\r\n\treturn false;\r\n}\r\n\r\nJHStateMachine.prototype.smCheck=function() {\r\n\tvar result={\r\n\t\tmissing: [],\r\n\t\tunused: []\r\n\t}\r\n\tvar existingFnt=[];\r\n\tfor(var s in this.smStates) {\r\n\t\tfor(var i in this.smStates[s].enteringMethods) {\r\n\t\t\tvar fnt=this.smStates[s].enteringMethods[i];\r\n\t\t\texistingFnt[fnt]=true;\r\n\t\t}\r\n\t\tfor(var i in this.smStates[s].leavingMethods) {\r\n\t\t\tvar fnt=this.smStates[s].leavingMethods[i];\r\n\t\t\texistingFnt[fnt]=true;\r\n\t\t}\r\n\t\tfor(var e in this.smStates[s].transitions) {\r\n\t\t\tvar event=this.smStates[s].transitions[e];\r\n\t\t\tfor(var i in event.methods) {\r\n\t\t\t\tvar fnt=event.methods[i];\r\n\t\t\t\texistingFnt[fnt]=true;\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\tfor(var fnt in existingFnt) {\r\n\t\tif(typeof(this['$'+fnt])!=\"function\") {\r\n\t\t\tresult.missing.push(fnt);\r\n\t\t\tconsole.error(\"JHStateMachine: missing function $\",fnt);\r\n\t\t}\r\n\t}\r\n\tfor(var k in this) {\r\n\t\ttry {\r\n\t\t\tif(k[0]=='$' && typeof(this[k])==\"function\") {\r\n\t\t\t\tvar fnt=k.substr(1);\r\n\t\t\t\tif(typeof(existingFnt[fnt])==\"undefined\") {\r\n\t\t\t\t\t//this.warning(\"JHStateMachine.check \"+this.target.name+\": unused function \"+k);\r\n\t\t\t\t\tresult.unused.push(fnt);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t} catch(e) {}\r\n\t}\r\n\treturn result;\r\n}\r\n","/*    Copyright 2017 Jocly\r\n *\r\n *    This program is free software: you can redistribute it and/or  modify\r\n *    it under the terms of the GNU Affero General Public License, version 3,\r\n *    as published by the Free Software Foundation.\r\n *\r\n *    This program is distributed in the hope that it will be useful,\r\n *    but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\r\n *    GNU Affero General Public License for more details.\r\n *\r\n *    You should have received a copy of the GNU Affero General Public License\r\n *    along with this program.  If not, see <http://www.gnu.org/licenses/>.\r\n *\r\n *    As a special exception, the copyright holders give permission to link the\r\n *    code of portions of this program with the OpenSSL library under certain\r\n *    conditions as described in each individual source file and distribute\r\n *    linked combinations including the program with the OpenSSL library. You\r\n *    must comply with the GNU Affero General Public License in all respects\r\n *    for all of the code used other than as permitted herein. If you modify\r\n *    file(s) with this exception, you may extend this exception to your\r\n *    version of the file(s), but you are not obligated to do so. If you do not\r\n *    wish to do so, delete this exception statement from your version. If you\r\n *    delete this exception statement from all source files in the program,\r\n *    then also delete it in the license file.\r\n */\r\n\r\nexports.view = View = {\r\n\tGame: {},\r\n\tBoard: {},\r\n};\r\n\r\nif (window.JoclyXdViewCleanup)\r\n\twindow.JoclyXdViewCleanup();\r\n\r\n(function () {\r\n\r\n\twindow.JoclyXdViewCleanup = function () {\r\n\t\tvar renderer = threeCtx && threeCtx.renderer;\r\n\t\tif (renderer) {\r\n\t\t\trenderer.forceContextLoss();\r\n\t\t\trenderer.context = null;\r\n\t\t\trenderer.domElement = null;\r\n\t\t\tdelete threeCtx.renderer;\r\n\t\t}\r\n\t\tif (arStream)\r\n\t\t\tAR(null);\r\n\t}\r\n\r\n\tvar area, currentSkin, logger, xdv, VSIZE, VHALF, htStateMachine, threeCtx = null,\r\n\t\tSCALE3D = 0.001, resourcesMap = {}, resources, arStream = null;\r\n\r\n\t// hack to ensure mouse and touch events do not collide\r\n\tvar lastTouchStart = 0, lastJoclyclick = 0;\r\n\r\n\t/* ======================================== */\r\n\r\n\tvar LOADING_TEXT_RESOURCE = \"\";\r\n\r\n\tif (typeof CustomEvent == \"undefined\") {\r\n\t\tfunction CustomEvent(event, params) {\r\n\t\t\tparams = params || { bubbles: false, cancelable: false };\r\n\t\t\tvar evt = document.createEvent('Event');\r\n\t\t\tevt.initEvent(event, params.bubbles, params.cancelable);\r\n\t\t\treturn evt;\r\n\t\t};\r\n\t\tCustomEvent.prototype = window.Event.prototype;\r\n\t\twindow.CustomEvent = CustomEvent;\r\n\t}\r\n\r\n\tvar Class = function () {\r\n\t};\r\n\t(function () {\r\n\t\tvar initializing = false, fnTest = /xyz/.test(function () {\r\n\t\t}) ? /\\b_super\\b/ : /.*/;\r\n\t\tClass.extend = function (prop) {\r\n\t\t\tvar _super = this.prototype;\r\n\t\t\tinitializing = true;\r\n\t\t\tvar prototype = new this();\r\n\t\t\tinitializing = false;\r\n\t\t\tfor (var name in prop) {\r\n\t\t\t\tprototype[name] = typeof prop[name] == \"function\"\r\n\t\t\t\t\t&& typeof _super[name] == \"function\"\r\n\t\t\t\t\t&& fnTest.test(prop[name]) ? (function (name, fn) {\r\n\t\t\t\t\t\treturn function () {\r\n\t\t\t\t\t\t\tvar tmp = this._super;\r\n\t\t\t\t\t\t\tthis._super = _super[name];\r\n\t\t\t\t\t\t\tvar ret = fn.apply(this, arguments);\r\n\t\t\t\t\t\t\tthis._super = tmp;\r\n\t\t\t\t\t\t\treturn ret;\r\n\t\t\t\t\t\t};\r\n\t\t\t\t\t})(name, prop[name]) : prop[name];\r\n\t\t\t}\r\n\t\t\tfunction Class(args) {\r\n\t\t\t\tif (!initializing && this.init)\r\n\t\t\t\t\tif (arguments.length > 0 && args.jBlocksArgsList)\r\n\t\t\t\t\t\tthis.init.apply(this, args);\r\n\t\t\t\t\telse\r\n\t\t\t\t\t\tthis.init.apply(this, arguments);\r\n\t\t\t}\r\n\t\t\tClass.prototype = prototype;\r\n\t\t\tClass.prototype.constructor = Class;\r\n\t\t\tClass.extend = arguments.callee;\r\n\t\t\treturn Class;\r\n\t\t};\r\n\t})();\r\n\r\n\t/* ======================================== */\r\n\r\n\tvar WebRTC;\r\n\tvar logResourcesLoad = false;\r\n\r\n\tfunction Log() {\r\n\t\tconsole.info.apply(console, arguments);\r\n\t}\r\n\r\n\tView.Board.Log = Log;\r\n\tView.Game.Log = Log;\r\n\r\n\tfunction HTStateMachine() { }\r\n\tHTStateMachine.prototype = new JHStateMachine();\r\n\r\n\tHTStateMachine.prototype.smError = function () {\r\n\t\t//console.info(\"=>\",arguments);\r\n\t}\r\n\tHTStateMachine.prototype.smWarning = function () {\r\n\t\t//console.info(\"=>\",arguments);\r\n\t};\r\n\tHTStateMachine.prototype.smDebug = function () {\r\n\t\t//console.info(\"=>\",arguments);\r\n\t}\r\n\r\n\tfunction Diff(oOld, oNew) {\r\n\t\tvar diff = {};\r\n\t\tvar diffSet = false;\r\n\t\tfor (var i in oNew) {\r\n\t\t\tif (oNew.hasOwnProperty(i)) {\r\n\t\t\t\tif (!oOld.hasOwnProperty(i)) {\r\n\t\t\t\t\tdiff[i] = oNew[i];\r\n\t\t\t\t\tdiffSet = true;\r\n\t\t\t\t} else if (typeof oNew[i] == \"object\") {\r\n\t\t\t\t\tvar diff0 = Diff(oOld[i], oNew[i]);\r\n\t\t\t\t\tif (diff0) {\r\n\t\t\t\t\t\tdiff[i] = diff0;\r\n\t\t\t\t\t\tdiffSet = true;\r\n\t\t\t\t\t}\r\n\t\t\t\t} else if (oNew[i] != oOld[i]) {\r\n\t\t\t\t\tdiff[i] = oNew[i];\r\n\t\t\t\t\tdiffSet = true;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn diffSet ? diff : null;\r\n\t}\r\n\r\n\tvar resLoadingMask = null;\r\n\tvar resLoadingCount = 0;\r\n\tfunction IncrementResLoading() {\r\n\t\tif (resLoadingCount++ == 0) {\r\n\t\t\tresLoadingMask = $(\".jocly-res-loading-mask\");\r\n\t\t\tif (resLoadingMask.length == 0)\r\n\t\t\t\tresLoadingMask = $(\"<div/>\").addClass(\"jocly-res-loading-mask\").css({\r\n\t\t\t\t\tposition: \"absolute\",\r\n\t\t\t\t\ttop: 0,\r\n\t\t\t\t\tleft: 0,\r\n\t\t\t\t\twidth: $(\"body\").width(),\r\n\t\t\t\t\theight: $(\"body\").height(),\r\n\t\t\t\t\t\"background-color\": \"rgba(0,0,0,.8)\",\r\n\t\t\t\t\t\"background-image\": \"url(\" + LOADING_TEXT_RESOURCE + \")\",\r\n\t\t\t\t\t\"background-position\": \"center center\",\r\n\t\t\t\t\t\"background-repeat\": \"no-repeat\",\r\n\t\t\t\t\t\"z-index\": 100000,\r\n\t\t\t\t}).appendTo($(\"body\"));\r\n\t\t\telse\r\n\t\t\t\tresLoadingMask.show();\r\n\t\t}\r\n\t}\r\n\tfunction DecrementResLoading() {\r\n\t\tif (--resLoadingCount == 0) {\r\n\t\t\tif (resLoadingMask)\r\n\t\t\t\tresLoadingMask.hide();\r\n\t\t}\r\n\t}\r\n\r\n\tvar materialMaps = {};\r\n\tfunction GetMaterialMap(map, callback) {\r\n\t\tvar $this = this;\r\n\t\tif (materialMaps[map])\r\n\t\t\tcallback(materialMaps[map]);\r\n\t\telse {\r\n\t\t\tvar loader = new THREE.TextureLoader();\r\n\t\t\tloader.setCrossOrigin(\"anonymous\");\r\n\t\t\tif (logResourcesLoad)\r\n\t\t\t\tconsole.log(\"Loading map\", map);\r\n\t\t\tIncrementResLoading();\r\n\t\t\tloader.load(\r\n\t\t\t\t// ressource url\r\n\t\t\t\tmap,\r\n\t\t\t\t// Function when resource is loaded\r\n\t\t\t\tfunction (texture) {\r\n\t\t\t\t\tmaterialMaps[map] = texture;\r\n\t\t\t\t\tif (logResourcesLoad)\r\n\t\t\t\t\t\tconsole.log(\"Loaded\", map);\r\n\t\t\t\t\tDecrementResLoading();\r\n\t\t\t\t\tthreeCtx.animControl.trigger();\r\n\t\t\t\t\tcallback(materialMaps[map]);\r\n\t\t\t\t},\r\n\t\t\t\t// Function called when download progresses\r\n\t\t\t\tfunction (xhr) {\r\n\t\t\t\t\t//console.log( (xhr.loaded / xhr.total * 100) + '% loaded' );\r\n\t\t\t\t},\r\n\t\t\t\t// Function called when download errors\r\n\t\t\t\tfunction (xhr) {\r\n\t\t\t\t\tif (logResourcesLoad)\r\n\t\t\t\t\t\tconsole.log(\"(not) Loaded\", map);\r\n\t\t\t\t\tDecrementResLoading();\r\n\t\t\t\t\tthreeCtx.animControl.trigger();\r\n\t\t\t\t\tcallback(null);\r\n\t\t\t\t});\r\n\t\t}\r\n\t}\r\n\r\n\tvar pendingGetResource = [];\r\n\tfunction GetResource(res, callback) {\r\n\t\tvar resource = resources[res];\r\n\t\tif (resource === undefined) {\r\n\t\t\tresource = resources[res] = {\r\n\t\t\t\tpending: [callback],\r\n\t\t\t\tstatus: \"loading\",\r\n\t\t\t}\r\n\r\n\t\t\tvar getResFnt = null;\r\n\t\t\tvar m = /^(.*\\|)(.*?)$/.exec(res);\r\n\t\t\tif (m) {\r\n\t\t\t\tvar prefix = m[1];\r\n\t\t\t\tvar url = m[2];\r\n\t\t\t\tfor (var r in resourcesMap) {\r\n\t\t\t\t\tvar m2 = /^(.*\\|)(.*?)$/.exec(r);\r\n\t\t\t\t\tif (m2)\r\n\t\t\t\t\t\tif (prefix == m[1] && url.substr(-m2[2].length) == m2[2]) {\r\n\t\t\t\t\t\t\tgetResFnt = resourcesMap[r];\r\n\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\tif (/^image\\|/.test(res)) {\r\n\t\t\t\tvar imgSrc = /^image\\|(.*)/.exec(res)[1];\r\n\t\t\t\tif (logResourcesLoad)\r\n\t\t\t\t\tconsole.log(\"Loading resource\", res);\r\n\t\t\t\tfunction HandleImage(image) {\r\n\t\t\t\t\tresource.image = image;\r\n\t\t\t\t\tif (logResourcesLoad)\r\n\t\t\t\t\t\tconsole.log(\"Loaded\", res);\r\n\t\t\t\t\tresource.status = \"loaded\";\r\n\t\t\t\t\tresource.imgSrc = imgSrc;\r\n\t\t\t\t\tDecrementResLoading();\r\n\t\t\t\t\tfor (var i = 0; i < resource.pending.length; i++)\r\n\t\t\t\t\t\tresource.pending[i](resource.image, imgSrc);\r\n\t\t\t\t\tresource.pending = null;\r\n\t\t\t\t\tif (threeCtx)\r\n\t\t\t\t\t\tthreeCtx.animControl.trigger();\r\n\t\t\t\t}\r\n\t\t\t\tIncrementResLoading();\r\n\t\t\t\tif (getResFnt) {\r\n\t\t\t\t\tgetResFnt(function (data) {\r\n\t\t\t\t\t\tvar image = new Image();\r\n\t\t\t\t\t\timage.onload = function () {\r\n\t\t\t\t\t\t\tHandleImage(image);\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\timage.src = data;\r\n\t\t\t\t\t});\r\n\t\t\t\t} else {\r\n\t\t\t\t\tvar image = new Image();\r\n\t\t\t\t\timage.onload = function () {\r\n\t\t\t\t\t\tHandleImage(image)\r\n\t\t\t\t\t}\r\n\t\t\t\t\timage.src = imgSrc;\r\n\t\t\t\t}\r\n\t\t\t} else if (/^smoothedfilegeo\\|/.test(res)) {\r\n\t\t\t\tif (logResourcesLoad)\r\n\t\t\t\t\tconsole.log(\"Loading resource\", res);\r\n\t\t\t\tif (!threeCtx) {\r\n\t\t\t\t\tdelete resources[res];\r\n\t\t\t\t\tpendingGetResource.push([res, callback]);\r\n\t\t\t\t\treturn;\r\n\t\t\t\t}\r\n\t\t\t\tvar m = /^smoothedfilegeo\\|([^\\|]*)\\|(.*)$/.exec(res);\r\n\t\t\t\tvar smooth = parseInt(m[1]);\r\n\t\t\t\tvar file = m[2];\r\n\t\t\t\tIncrementResLoading();\r\n\t\t\t\tfunction HandleGeoMat(geometry, materials) {\r\n\t\t\t\t\tif (logResourcesLoad)\r\n\t\t\t\t\t\tconsole.log(\"Loaded\", res);\r\n\r\n\t\t\t\t\t// not sure of the side effects here but this removes the console\r\n\t\t\t\t\t// warnings \"THREE.DirectGeometry.fromGeometry(): Undefined vertexUv\"\r\n\t\t\t\t\tfor (var i = 0; i < geometry.faceVertexUvs.length; i++) {\r\n\t\t\t\t\t\tfor (var j = 0; j < geometry.faceVertexUvs[i].length; j++) {\r\n\t\t\t\t\t\t\tvar uv = geometry.faceVertexUvs[i][j];\r\n\t\t\t\t\t\t\tif (uv === undefined)\r\n\t\t\t\t\t\t\t\tgeometry.faceVertexUvs[i][j] = [{ x: 0, y: 0 }, { x: 0, y: 0 }, { x: 0, y: 0 }];\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\tfor (; j < geometry.faces.length; j++)\r\n\t\t\t\t\t\t\tgeometry.faceVertexUvs[i].push([{ x: 0, y: 0 }, { x: 0, y: 0 }, { x: 0, y: 0 }]);\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tif (smooth > 0) {\r\n\t\t\t\t\t\tvar modifier = new THREE.SubdivisionModifier(smooth);\r\n\t\t\t\t\t\tmodifier.modify(geometry);\r\n\t\t\t\t\t}\r\n\t\t\t\t\tresource.status = \"loaded\";\r\n\t\t\t\t\tDecrementResLoading();\r\n\t\t\t\t\tresource.geometry = geometry;\r\n\t\t\t\t\tresource.materials = materials;\r\n\t\t\t\t\tfor (var i = 0; i < resource.pending.length; i++)\r\n\t\t\t\t\t\tresource.pending[i](geometry, materials);\r\n\t\t\t\t\tresource.pending = null;\r\n\t\t\t\t\tthreeCtx.animControl.trigger(3000);\r\n\t\t\t\t}\r\n\t\t\t\tif (getResFnt) {\r\n\t\t\t\t\tgetResFnt(function (data) {\r\n\t\t\t\t\t\ttry {\r\n\t\t\t\t\t\t\tvar parsed = threeCtx.loader.parse(JSON.parse(data));\r\n\t\t\t\t\t\t\tHandleGeoMat(parsed.geometry, parsed.materials);\r\n\t\t\t\t\t\t} catch (e) {\r\n\t\t\t\t\t\t\tdebugger;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t});\r\n\t\t\t\t} else\r\n\t\t\t\t\tthreeCtx.loader.load(file, HandleGeoMat);\r\n\t\t\t} else if (/^json\\|/.test(res)) {\r\n\t\t\t\tif (logResourcesLoad)\r\n\t\t\t\t\tconsole.log(\"Loading resource\", res);\r\n\t\t\t\tIncrementResLoading();\r\n\t\t\t\tvar url = /^json\\|(.*)/.exec(res)[1];\r\n\t\t\t\tfunction JSONResult(event, data) {\r\n\t\t\t\t\tif (logResourcesLoad)\r\n\t\t\t\t\t\tconsole.log(\"Loaded\", res);\r\n\t\t\t\t\tvar path = /^(\\.)?(.*)$/.exec(url);\r\n\t\t\t\t\tif (data.url.substr(-path[2].length) == path[2]) {\r\n\t\t\t\t\t\t$(document).unbind(\"jocly.json-resource\", JSONResult);\r\n\t\t\t\t\t\tresource.status = \"loaded\";\r\n\t\t\t\t\t\tDecrementResLoading();\r\n\t\t\t\t\t\tresource.data = data.data;\r\n\t\t\t\t\t\tfor (var i = 0; i < resource.pending.length; i++)\r\n\t\t\t\t\t\t\tresource.pending[i](resource.data);\r\n\t\t\t\t\t\tresource.pending = null;\r\n\t\t\t\t\t\tif (threeCtx)\r\n\t\t\t\t\t\t\tthreeCtx.animControl.trigger();\r\n\t\t\t\t\t} else\r\n\t\t\t\t\t\tconsole.warn(\"Expecting\", url, \"got\", data.url)\r\n\r\n\t\t\t\t}\r\n\t\t\t\t$(document).bind(\"jocly.json-resource\", JSONResult);\r\n\t\t\t\t$(\"<script/>\").attr(\"type\", \"text/javascript\").attr(\"jocly-type\", \"json-resource\").attr(\"src\", url).appendTo($(\"head\"));\r\n\t\t\t} else if (/^json2\\|/.test(res)) {\r\n\t\t\t\tif (logResourcesLoad)\r\n\t\t\t\t\tconsole.log(\"Loading resource\", res);\r\n\t\t\t\tIncrementResLoading();\r\n\t\t\t\tvar url = /^json2\\|(.*)/.exec(res)[1];\r\n\t\t\t\tvar xhr = new XMLHttpRequest();\r\n\t\t\t\txhr.onreadystatechange = function () {\r\n\t\t\t\t\tif (xhr.readyState == XMLHttpRequest.DONE) {\r\n\t\t\t\t\t\tif (logResourcesLoad)\r\n\t\t\t\t\t\t\tconsole.log(\"Loaded\", res);\r\n\t\t\t\t\t\tvar data = JSON.parse(xhr.responseText);\r\n\t\t\t\t\t\tresource.status = \"loaded\";\r\n\t\t\t\t\t\tDecrementResLoading();\r\n\t\t\t\t\t\tresource.data = data;\r\n\t\t\t\t\t\tfor (var i = 0; i < resource.pending.length; i++)\r\n\t\t\t\t\t\t\tresource.pending[i](resource.data);\r\n\t\t\t\t\t\tresource.pending = null;\r\n\t\t\t\t\t\tif (threeCtx)\r\n\t\t\t\t\t\t\tthreeCtx.animControl.trigger();\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\txhr.open('GET', url, true);\r\n\t\t\t\txhr.send(null);\r\n\r\n\t\t\t} else if (/^font\\|/.test(res)) {\r\n\t\t\t\tif (logResourcesLoad)\r\n\t\t\t\t\tconsole.info(\"font path\", fontPath);\r\n\t\t\t\tvar fontPath = /^font\\|(.*)/.exec(res)[1];\r\n\t\t\t\tIncrementResLoading();\r\n\t\t\t\tvar fontLoader = new THREE.FontLoader();\r\n\t\t\t\tfontLoader.load(fontPath, function (font) {\r\n\t\t\t\t\tDecrementResLoading();\r\n\t\t\t\t\tresource.status = \"loaded\";\r\n\t\t\t\t\tresource.font = font;\r\n\t\t\t\t\tfor (var i = 0; i < resource.pending.length; i++)\r\n\t\t\t\t\t\tresource.pending[i](font);\r\n\t\t\t\t\tresource.pending = null;\r\n\t\t\t\t\tif (threeCtx)\r\n\t\t\t\t\t\tthreeCtx.animControl.trigger();\r\n\t\t\t\t});\r\n\t\t\t}\r\n\t\t} else if (resource.status == \"loading\") {\r\n\t\t\tresource.pending.push(callback);\r\n\t\t} else {\r\n\t\t\tif (/^image\\|/.test(res)) {\r\n\t\t\t\tcallback(resource.image, resource.imgSrc);\r\n\t\t\t} else if (/^smoothedfilegeo\\|/.test(res)) {\r\n\t\t\t\tcallback(resource.geometry, resource.materials);\r\n\t\t\t} else if (/^json\\|/.test(res)) {\r\n\t\t\t\tcallback(resource.data);\r\n\t\t\t} else if (/^json2\\|/.test(res)) {\r\n\t\t\t\tcallback(resource.data);\r\n\t\t\t} else if (/^font\\|/.test(res)) {\r\n\t\t\t\tcallback(resource.font);\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\tfunction ResumePendingResources() {\r\n\t\tif (threeCtx)\r\n\t\t\twhile (pendingGetResource.length) {\r\n\t\t\t\tvar call = pendingGetResource.shift();\r\n\t\t\t\tGetResource.call(null, call[0], call[1]);\r\n\t\t\t}\r\n\t}\r\n\r\n\r\n\t/* ======================================== */\r\n\r\n\tvar XDView = Class.extend({\r\n\t\tinit: function () {\r\n\t\t\tthis.gadgets = {};\r\n\t\t\tthis.resources = {};\r\n\t\t\tthis.game = null;\r\n\t\t\tthis.initDone = false;\r\n\t\t\tthis.ratio = 0;\r\n\t\t\tthis.center = null;\r\n\t\t\tthis.getMaterialMap = GetMaterialMap;\r\n\t\t},\r\n\t\tcreateGadget: function (id, options) {\r\n\t\t\tif (this.ratio > 0) {\r\n\t\t\t\tif (options.base === undefined)\r\n\t\t\t\t\toptions.base = {};\r\n\t\t\t\toptions.base.ratio = this.ratio;\r\n\t\t\t\toptions.base.center = this.center;\r\n\t\t\t}\r\n\t\t\tthis.gadgets[id] = new Gadget(id, options);\r\n\t\t},\r\n\t\tupdateGadget: function (id, options, delay, callback) {\r\n\t\t\tvar gadget = this.gadgets[id];\r\n\t\t\tif (gadget) {\r\n\t\t\t\tif (arguments.length < 3 || delay === undefined)\r\n\t\t\t\t\tdelay = 0;\r\n\t\t\t\tif (arguments.length < 4 || callback === undefined)\r\n\t\t\t\t\tcallback = function () { }\r\n\t\t\t\tgadget.update(options, delay, callback);\r\n\t\t\t}\r\n\t\t},\r\n\t\tremoveGadget: function (id) {\r\n\t\t\tvar gadget = this.gadgets[id];\r\n\t\t\tif (gadget) {\r\n\t\t\t\tgadget.unbuild();\r\n\t\t\t\tdelete this.gadgets[id];\r\n\t\t\t}\r\n\t\t},\r\n\t\tshowGadget: function (id) {\r\n\t\t\tthis.updateGadget(id, {\r\n\t\t\t\tbase: {\r\n\t\t\t\t\tvisible: true,\r\n\t\t\t\t},\r\n\t\t\t});\r\n\t\t},\r\n\t\thideGadget: function (id) {\r\n\t\t\tthis.updateGadget(id, {\r\n\t\t\t\tbase: {\r\n\t\t\t\t\tvisible: false,\r\n\t\t\t\t},\r\n\t\t\t});\r\n\t\t},\r\n\t\tupdateArea: function (ratio, center) {\r\n\t\t\tthis.ratio = ratio;\r\n\t\t\tthis.center = center;\r\n\t\t\tfor (var gi in this.gadgets)\r\n\t\t\t\tthis.gadgets[gi].update({\r\n\t\t\t\t\tbase: {\r\n\t\t\t\t\t\tratio: ratio,\r\n\t\t\t\t\t\tcenter: center,\r\n\t\t\t\t\t},\r\n\t\t\t\t});\r\n\t\t},\r\n\t\tredisplayGadgets: function () {\r\n\t\t\tfor (var gi in this.gadgets) {\r\n\t\t\t\tvar gadget = this.gadgets[gi];\r\n\t\t\t\tgadget.update({});\r\n\t\t\t}\r\n\t\t},\r\n\t\tunbuildGadgets: function () {\r\n\t\t\tfor (var gi in this.gadgets)\r\n\t\t\t\tthis.gadgets[gi].unbuild();\r\n\t\t},\r\n\t\tsaveGadgetProps: function (id, props, saveName) {\r\n\t\t\tvar gadget = this.gadgets[id];\r\n\t\t\tif (gadget)\r\n\t\t\t\tgadget.saveProps(props, saveName);\r\n\t\t},\r\n\t\trestoreGadgetProps: function (id, saveName, delay, callback) {\r\n\t\t\tvar gadget = this.gadgets[id];\r\n\t\t\tif (gadget)\r\n\t\t\t\tgadget.restoreProps(saveName, delay, callback);\r\n\t\t\telse if (callback)\r\n\t\t\t\tcallback();\r\n\t\t},\r\n\t\tlistScene: function () {\r\n\t\t\tconsole.log(\"listScene:\");\r\n\t\t\tvar accu = [];\r\n\t\t\taccu[\"faces\"] = 0;\r\n\t\t\t//var crlf=\"<br>\";\r\n\t\t\tvar crlf = \" :: \";\r\n\t\t\tvar output = \"========= Scene summary ===========\";\r\n\t\t\tvar nbLights = -1;\r\n\r\n\r\n\t\t\tfunction getFaces(obj, nbFaces) {\r\n\t\t\t\tif (obj.geometry) {\r\n\t\t\t\t\tvar gg = obj.geometry;\r\n\t\t\t\t\tif (gg.faces) nbFaces += gg.faces.length;\r\n\t\t\t\t}\r\n\t\t\t\tif (obj.getDescendants) {\r\n\t\t\t\t\tvar children = obj.getDescendants();\r\n\t\t\t\t\tif (children) nbFaces += getFaces(children, nbFaces);\r\n\t\t\t\t}\r\n\t\t\t\treturn nbFaces;\r\n\t\t\t}\r\n\t\t\tif (threeCtx) if (threeCtx.scene) {\r\n\t\t\t\tvar threeScene = threeCtx.scene;\r\n\t\t\t\tnbLights = threeScene.__lights.length;\r\n\t\t\t\tconsole.log(threeScene);\r\n\t\t\t\tvar obj = threeScene.getDescendants();\r\n\t\t\t\tfor (var o in obj) {\r\n\t\t\t\t\tvar nbf = getFaces(obj[o], 0);\r\n\t\t\t\t\taccu[\"faces\"] += nbf;\r\n\t\t\t\t\t//console.log(obj[o].name+\" has \"+nbf+\" faces\");\r\n\t\t\t\t\t/*if(obj[o].geometry){\r\n\t\t\t\t\t\tvar gg=obj[o].geometry;\r\n\t\t\t\t\t\tif (gg.faces) accu[\"faces\"]+=gg.faces.length;\r\n\t\t\t\t\t\tconsole.log(obj[o].name+\" has \"+gg.faces.length+\" faces\");\r\n\t\t\t\t\t}*/\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\toutput += crlf + \"nb lights: \" + nbLights;\r\n\t\t\toutput += crlf + \"Nb faces: \" + accu[\"faces\"];\r\n\t\t\tconsole.log(output);\r\n\t\t},\r\n\t})\r\n\r\n\t/* ======================================== */\r\n\r\n\tfunction InitGlobals() {\r\n\t\txdv = new XDView();\r\n\t\tVSIZE = 12600;\r\n\t\tVHALF = VSIZE / 2;\r\n\t\thtStateMachine = null;\r\n\t\tthreeCtx = null;\r\n\t\tSCALE3D = 0.001;\r\n\t\tresourcesMap = {};\r\n\t\tresources = {};\r\n\t\tarea = null;\r\n\t\tcurrentSkin = null;\r\n\t\tlogger = null;\r\n\t}\r\n\tInitGlobals();\r\n\r\n\t/* ======================================== */\r\n\r\n\tvar Gadget = Class.extend({\r\n\t\tinit: function (id, options) {\r\n\t\t\tthis.id = id;\r\n\t\t\tthis.options = $.extend(true, {\r\n\t\t\t\tbase: {\r\n\t\t\t\t\tvisible: false,\r\n\t\t\t\t}\r\n\t\t\t}, options);\r\n\t\t\tthis.avatar = null;\r\n\t\t\tthis.savedProps = {};\r\n\t\t},\r\n\t\tmergeOptions: function () {\r\n\t\t\treturn $.extend(true,\r\n\t\t\t\t{\r\n\t\t\t\t\tx: 0,\r\n\t\t\t\t\ty: 0,\r\n\t\t\t\t\tz: 0,\r\n\t\t\t\t},\r\n\t\t\t\tthis.options.base,\r\n\t\t\t\tcurrentSkin[\"3d\"] ? this.options[\"3d\"] : this.options[\"2d\"],\r\n\t\t\t\tthis.options[currentSkin.name]);\r\n\t\t},\r\n\t\tbuild: function (options) {\r\n\t\t\tif (this.avatar)\r\n\t\t\t\treturn;\r\n\t\t\tif (arguments.length == 0)\r\n\t\t\t\toptions = this.mergeOptions();\r\n\t\t},\r\n\t\tunbuild: function () {\r\n\t\t\tif (this.avatar) {\r\n\t\t\t\tthis.avatar.remove();\r\n\t\t\t\tthis.avatar = null;\r\n\t\t\t}\r\n\t\t},\r\n\t\tcanDisplay: function (options) {\r\n\t\t\tif (currentSkin === undefined || currentSkin === null)\r\n\t\t\t\treturn false;\r\n\t\t\tif (arguments.length == 0)\r\n\t\t\t\toptions = this.mergeOptions();\r\n\t\t\treturn options.visible &&\r\n\t\t\t\t((!currentSkin[\"3d\"] && options.ratio !== undefined && options.center !== undefined) ||\r\n\t\t\t\t\t(currentSkin[\"3d\"] /* && 3D requirements */));\r\n\t\t},\r\n\t\tupdate: function (options, delay, callback) {\r\n\t\t\tif (arguments.length < 2 || delay === undefined)\r\n\t\t\t\tdelay = 0;\r\n\t\t\tif (arguments.length < 3 || callback === undefined)\r\n\t\t\t\tcallback = function () { };\r\n\t\t\tif (currentSkin !== undefined && currentSkin !== null) {\r\n\t\t\t\tvar xdMap = currentSkin[\"3d\"] ? \"3d\" : \"2d\";\r\n\t\t\t\tif (options.base)\r\n\t\t\t\t\tfor (var i in options.base) {\r\n\t\t\t\t\t\tif (this.options[xdMap])\r\n\t\t\t\t\t\t\tdelete this.options[xdMap][i];\r\n\t\t\t\t\t\tif (this.options[currentSkin.name])\r\n\t\t\t\t\t\t\tdelete this.options[currentSkin.name][i];\r\n\t\t\t\t\t}\r\n\t\t\t\tif (options[xdMap])\r\n\t\t\t\t\tfor (var i in options[xdMap])\r\n\t\t\t\t\t\tif (this.options[currentSkin.name])\r\n\t\t\t\t\t\t\tdelete this.options[currentSkin.name][i];\r\n\t\t\t\t$.extend(true, this.options, options);\r\n\t\t\t\tvar aOptions = this.mergeOptions();\r\n\t\t\t\tif (!this.avatar && this.canDisplay(aOptions)) {\r\n\t\t\t\t\tvar avatarType = avatarTypes[aOptions.type];\r\n\t\t\t\t\tif (avatarType !== undefined)\r\n\t\t\t\t\t\tthis.avatar = new avatarType(this, aOptions);\r\n\t\t\t\t}\r\n\t\t\t\tif (typeof delay == \"object\") {\r\n\t\t\t\t\tif (delay[currentSkin.name] !== undefined)\r\n\t\t\t\t\t\tdelay = delay[currentSkin.name];\r\n\t\t\t\t\telse if (delay[xdMap] !== undefined)\r\n\t\t\t\t\t\tdelay = delay[xdMap];\r\n\t\t\t\t\telse if (delay.base !== undefined)\r\n\t\t\t\t\t\tdelay = delay.base;\r\n\t\t\t\t\telse\r\n\t\t\t\t\t\tdelay = 0;\r\n\t\t\t\t}\r\n\t\t\t\tif (this.avatar)\r\n\t\t\t\t\tthis.avatar.update(aOptions, delay, callback);\r\n\t\t\t} else\r\n\t\t\t\t$.extend(true, this.options, options);\r\n\t\t},\r\n\t\tsaveProps: function (props, saveName) {\r\n\t\t\tvar save = {};\r\n\t\t\tfor (var oi in this.options) {\r\n\t\t\t\tvar optCat = this.options[oi];\r\n\t\t\t\tfor (var i in props) {\r\n\t\t\t\t\tvar prop = props[i];\r\n\t\t\t\t\tif (optCat[prop] !== undefined) {\r\n\t\t\t\t\t\tsave[oi] = save[oi] || {};\r\n\t\t\t\t\t\tsave[oi][prop] = optCat[prop];\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tthis.savedProps[saveName] = save;\r\n\t\t},\r\n\t\trestoreProps: function (saveName, delay, callback) {\r\n\t\t\tif (this.savedProps[saveName] !== undefined)\r\n\t\t\t\tthis.update(this.savedProps[saveName], delay, callback);\r\n\t\t\telse if (callback)\r\n\t\t\t\tcallback();\r\n\t\t},\r\n\t});\r\n\r\n\t/* ======================================== */\r\n\r\n\tvar updateOp = 1;\r\n\r\n\tvar GadgetAvatar = Class.extend({\r\n\t\tinit: function (gadget, options) {\r\n\t\t\tthis.gadget = gadget;\r\n\t\t\tthis.options = options;\r\n\t\t\tthis.SCALE3D = SCALE3D;\r\n\t\t\tthis.animCounts = {};\r\n\t\t},\r\n\t\tremove: function () {\r\n\t\t},\r\n\t\tdisplay: function (options) {\r\n\t\t},\r\n\t\tupdate: function (options, delay, callback) {\r\n\t\t\tvar aOptions = $.extend(true, {}, this.options, options);\r\n\t\t\taOptions.updateOp = updateOp++;\r\n\t\t\taOptions.updateCallback = callback;\r\n\t\t\tthis.display(aOptions, delay, callback);\r\n\t\t\tif (aOptions.visible)\r\n\t\t\t\tthis.show();\r\n\t\t\telse\r\n\t\t\t\tthis.hide();\r\n\t\t\tthis.options = aOptions;\r\n\t\t},\r\n\t\tshow: function () {\r\n\t\t},\r\n\t\thide: function () {\r\n\t\t},\r\n\t\tanimStart: function (options) {\r\n\t\t\tif (options === undefined) {\r\n\t\t\t\tconsole.error(\"animStart without options\");\r\n\t\t\t\tdebugger;\r\n\t\t\t\treturn;\r\n\t\t\t}\r\n\t\t\tif (options.updateOp === undefined) {\r\n\t\t\t\tconsole.error(\"animStart without options\");\r\n\t\t\t\tdebugger;\r\n\t\t\t\treturn;\r\n\t\t\t}\r\n\t\t\tif (this.object3d)\r\n\t\t\t\tthis.object3d.matrixAutoUpdate = true;\r\n\t\t\tif (this.animCounts[options.updateOp] === undefined)\r\n\t\t\t\tthis.animCounts[options.updateOp] = 1;\r\n\t\t\telse\r\n\t\t\t\tthis.animCounts[options.updateOp]++;\r\n\t\t},\r\n\t\tanimEnd: function (options) {\r\n\t\t\tif (options === undefined) {\r\n\t\t\t\tconsole.error(\"animEnd without options\");\r\n\t\t\t\tdebugger;\r\n\t\t\t\treturn;\r\n\t\t\t}\r\n\t\t\tif (options.updateOp === undefined) {\r\n\t\t\t\tconsole.error(\"animEnd without options\");\r\n\t\t\t\tdebugger;\r\n\t\t\t\treturn;\r\n\t\t\t}\r\n\t\t\tif (this.animCounts[options.updateOp] === undefined) {\r\n\t\t\t\tconsole.error(\"animEnd without animCount\");\r\n\t\t\t\tdebugger;\r\n\t\t\t\treturn;\r\n\t\t\t}\r\n\t\t\tif (--this.animCounts[options.updateOp] == 0) {\r\n\t\t\t\tif (this.object3d)\r\n\t\t\t\t\tthis.object3d.matrixAutoUpdate = false;\r\n\t\t\t\toptions.updateCallback();\r\n\t\t\t\tdelete this.animCounts[options.updateOp];\r\n\t\t\t}\r\n\t\t},\r\n\t\tgetResource: GetResource,\r\n\t});\r\n\r\n\tvar GadgetElement = GadgetAvatar.extend({\r\n\t\tinit: function (gadget, options) {\r\n\t\t\toptions = $.extend(true, {\r\n\t\t\t\tdisplay: function () { },\r\n\t\t\t}, options);\r\n\t\t\tthis._super.apply(this, arguments);\r\n\t\t\tthis.options = $.extend(true, {\r\n\t\t\t\tx: 0,\r\n\t\t\t\ty: 0,\r\n\t\t\t\tz: 0,\r\n\t\t\t\twidth: 1000,\r\n\t\t\t\theight: 1000,\r\n\t\t\t\ttag: \"div\",\r\n\t\t\t\topacity: 1,\r\n\t\t\t\trotate: 0,\r\n\t\t\t\tcss: {},\r\n\t\t\t}, options);\r\n\t\t\tthis.element = $(\"<\" + this.options.tag + \"/>\").css({\r\n\t\t\t\t\"position\": \"absolute\",\r\n\t\t\t\t\"z-index\": this.options.z,\r\n\t\t\t}).hide().addClass(\"jocly-gadget\").appendTo(area);\r\n\t\t\tif (this.options.initialClasses)\r\n\t\t\t\tthis.element.addClass(this.options.initialClasses);\r\n\t\t},\r\n\t\tdisplay: function (options, delay) {\r\n\t\t\tvar $this = this;\r\n\t\t\tif (this.element) {\r\n\t\t\t\tthis.displayElement.call(this, !this.displayCalled, options, delay);\r\n\t\t\t\tthis.displayCalled = true;\r\n\t\t\t} else if (delay) {\r\n\t\t\t\tthis.animStart(options);\r\n\t\t\t\tsetTimeout(function () { $this.animEnd(options); }, delay);\r\n\t\t\t}\r\n\t\t},\r\n\t\tdisplayElement: function (force, options, delay) {\r\n\t\t\tvar $this = this;\r\n\t\t\tthis.element.css($.extend(true, this.options.css, options.css));\r\n\t\t\tif (\r\n\t\t\t\tforce ||\r\n\t\t\t\tthis.aWidth === undefined || this.aHeight === undefined ||\r\n\t\t\t\toptions.ratio != this.options.ratio ||\r\n\t\t\t\toptions.center.x != this.options.center.x ||\r\n\t\t\t\toptions.center.y != this.options.center.y ||\r\n\t\t\t\toptions.width != this.options.width ||\r\n\t\t\t\toptions.height != this.options.height ||\r\n\t\t\t\toptions.x != this.options.x ||\r\n\t\t\t\toptions.y != this.options.y ||\r\n\t\t\t\toptions.z != this.options.z\r\n\t\t\t) {\r\n\t\t\t\tthis.aWidth = options.width * options.ratio;\r\n\t\t\t\tthis.aHeight = options.height * options.ratio;\r\n\t\t\t\tvar left = options.x * options.ratio + options.center.x - this.aWidth / 2;\r\n\t\t\t\tvar top = options.y * options.ratio + options.center.y - this.aHeight / 2;\r\n\t\t\t\tif (delay) {\r\n\t\t\t\t\tthis.animStart(options);\r\n\t\t\t\t\tthis.element.css({\r\n\t\t\t\t\t\t\"z-index\": options.z,\r\n\t\t\t\t\t}).animate({\r\n\t\t\t\t\t\twidth: this.aWidth,\r\n\t\t\t\t\t\theight: this.aHeight,\r\n\t\t\t\t\t\tleft: left,\r\n\t\t\t\t\t\ttop: top,\r\n\t\t\t\t\t}, delay, function () { $this.animEnd(options); });\r\n\t\t\t\t} else {\r\n\t\t\t\t\tthis.element.css({\r\n\t\t\t\t\t\twidth: this.aWidth,\r\n\t\t\t\t\t\theight: this.aHeight,\r\n\t\t\t\t\t\tleft: left,\r\n\t\t\t\t\t\ttop: top,\r\n\t\t\t\t\t\t\"z-index\": options.z,\r\n\t\t\t\t\t});\r\n\t\t\t\t}\r\n\t\t\t\tthis.options.display(this.element, this.aWidth, this.aHeight);\r\n\t\t\t}\r\n\t\t\tif (force ||\r\n\t\t\t\toptions.classes != this.options.classes) {\r\n\t\t\t\tif (this.options.classes)\r\n\t\t\t\t\tthis.element.removeClass(this.options.classes);\r\n\t\t\t\tthis.element.addClass(options.classes);\r\n\t\t\t}\r\n\t\t\tif (force ||\r\n\t\t\t\toptions.click != this.options.click) {\r\n\t\t\t\t//this.element.unbind(JocGame.CLICK);\r\n\t\t\t\tthis.element.unbind(JocGame.MOUSEMOVE_EVENT);\r\n\t\t\t\tthis.element.unbind(JocGame.MOUSEDOWN_EVENT);\r\n\t\t\t\tthis.element.unbind(JocGame.MOUSEUP_EVENT);\r\n\t\t\t\tif (options.click) {\r\n\t\t\t\t\tvar iOS = (navigator.userAgent.match(/(iPad|iPhone|iPod)/g) ? true : false);\r\n\t\t\t\t\t(function () {\r\n\t\t\t\t\t\tvar mouseDown = false;\r\n\t\t\t\t\t\tvar notified = false;\r\n\t\t\t\t\t\tvar downPosition = [0, 0];\r\n\t\t\t\t\t\t$this.element.bind(JocGame.MOUSEDOWN_EVENT, function (event) {\r\n\t\t\t\t\t\t\tevent.preventDefault();\r\n\t\t\t\t\t\t\tif (iOS && event.type == \"mousedown\")\r\n\t\t\t\t\t\t\t\treturn;\r\n\t\t\t\t\t\t\tif (event.type == \"touchstart\")\r\n\t\t\t\t\t\t\t\tlastTouchStart = Date.now();\r\n\t\t\t\t\t\t\tif (event.type == \"mousedown\" && Date.now() - lastTouchStart < 500)\r\n\t\t\t\t\t\t\t\treturn;\r\n\t\t\t\t\t\t\tmouseDown = true;\r\n\t\t\t\t\t\t\tdownPosition = GetEventPosition(event);\r\n\t\t\t\t\t\t});\r\n\t\t\t\t\t\t$this.element.bind(JocGame.MOUSEUP_EVENT, function (event) {\r\n\t\t\t\t\t\t\tevent.preventDefault();\r\n\t\t\t\t\t\t\tif (iOS && event.type == \"mouseup\")\r\n\t\t\t\t\t\t\t\treturn;\r\n\t\t\t\t\t\t\tmouseDown = false;\r\n\t\t\t\t\t\t\tif (event.type == \"joclyclick\")\r\n\t\t\t\t\t\t\t\tlastJoclyclick = Date.now();\r\n\t\t\t\t\t\t\tif (event.type == \"mouseup\" && Date.now() - lastJoclyclick < 500)\r\n\t\t\t\t\t\t\t\treturn;\r\n\t\t\t\t\t\t\tif (event.type == 'mouseup' || event.type == 'joclyclick') {\r\n\t\t\t\t\t\t\t\toptions.click.call($this);\r\n\t\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\t\tevent.stopPropagation();\r\n\t\t\t\t\t\t\t\tvar newevent = new CustomEvent(\"joclyclick\", {});\r\n\t\t\t\t\t\t\t\tvar x, y;\r\n\t\t\t\t\t\t\t\tif (event.originalEvent.changedTouches && event.originalEvent.changedTouches.length > 0) {\r\n\t\t\t\t\t\t\t\t\tx = event.originalEvent.changedTouches[0].pageX;\r\n\t\t\t\t\t\t\t\t\ty = event.originalEvent.changedTouches[0].pageY;\r\n\t\t\t\t\t\t\t\t} else if (event.originalEvent.touches && event.originalEvent.touches.length > 0) {\r\n\t\t\t\t\t\t\t\t\tx = event.originalEvent.touches[0].pageX;\r\n\t\t\t\t\t\t\t\t\ty = event.originalEvent.touches[0].pageY;\r\n\t\t\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\t\t\tconsole.warn(\"Invalid touch event\");\r\n\t\t\t\t\t\t\t\t\treturn;\r\n\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\tvar target = document.elementFromPoint(x, y);\r\n\t\t\t\t\t\t\t\ttarget.dispatchEvent(newevent);\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t});\r\n\t\t\t\t\t\t$this.element.bind(JocGame.MOUSEMOVE_EVENT, function (event) {\r\n\t\t\t\t\t\t\tevent.preventDefault();\r\n\t\t\t\t\t\t\tif (iOS && event.type == \"mousemove\")\r\n\t\t\t\t\t\t\t\treturn;\r\n\t\t\t\t\t\t\tif (mouseDown && !notified) {\r\n\t\t\t\t\t\t\t\tvar position = GetEventPosition(event);\r\n\t\t\t\t\t\t\t\tvar dx = position[0] - downPosition[0];\r\n\t\t\t\t\t\t\t\tvar dy = position[1] - downPosition[1];\r\n\t\t\t\t\t\t\t\tif (dx * dx + dy * dy > 100) {\r\n\t\t\t\t\t\t\t\t\tnotified = true;\r\n\t\t\t\t\t\t\t\t\toptions.click.call($this);\r\n\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t});\r\n\t\t\t\t\t})();\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\t/*\r\n\t\t\tif(force ||\r\n\t\t\t\t\toptions.holdClick != this.options.holdClick) {\r\n\t\t\t\tthis.element.unbind(\"holdclick\");\r\n\t\t\t\tif(options.holdClick)\r\n\t\t\t\t\tthis.element.bind(\"holdclick\",options.holdClick);\r\n\t\t\t}\r\n\t\t\t*/\r\n\t\t\tif (force ||\r\n\t\t\t\toptions.rotate != this.options.rotate) {\r\n\t\t\t\twhile (options.rotate < 0)\r\n\t\t\t\t\toptions.rotate += 360;\r\n\t\t\t\toptions.rotate %= 360;\r\n\t\t\t\tvar rotate = options.rotate;\r\n\t\t\t\tvar rotate0 = this.options.rotate;\r\n\t\t\t\tif (rotate - this.options.rotate > 180)\r\n\t\t\t\t\trotate0 = 360;\r\n\t\t\t\telse if (this.options.rotate - rotate > 180)\r\n\t\t\t\t\trotate += 360;\r\n\t\t\t\tif (delay) {\r\n\t\t\t\t\tthis.animStart(options);\r\n\t\t\t\t\t$({ deg: rotate0 }).animate({ deg: rotate }, {\r\n\t\t\t\t\t\tstep: function (now) {\r\n\t\t\t\t\t\t\t$this.element.css('transform', 'rotate(' + now + 'deg)');\r\n\t\t\t\t\t\t},\r\n\t\t\t\t\t\tduration: delay,\r\n\t\t\t\t\t\tcomplete: function () {\r\n\t\t\t\t\t\t\t$this.animEnd(options);\r\n\t\t\t\t\t\t},\r\n\t\t\t\t\t});\r\n\t\t\t\t} else\r\n\t\t\t\t\tthis.element.css({\r\n\t\t\t\t\t\t\"transform\": \"rotate(\" + options.rotate + \"deg)\",\r\n\t\t\t\t\t});\r\n\t\t\t} else if (delay) {\r\n\t\t\t\tthis.animStart(options);\r\n\t\t\t\tsetTimeout(function () {\r\n\t\t\t\t\t$this.animEnd(options);\r\n\t\t\t\t}, 0);\r\n\t\t\t}\r\n\t\t\tif (force ||\r\n\t\t\t\toptions.opacity != this.options.opacity) {\r\n\t\t\t\tif (delay) {\r\n\t\t\t\t\tthis.animStart(options);\r\n\t\t\t\t\tthis.element.stop().animate({\r\n\t\t\t\t\t\t\"opacity\": options.opacity,\r\n\t\t\t\t\t}, delay, function () { $this.animEnd(options); });\r\n\t\t\t\t} else\r\n\t\t\t\t\tthis.element.css({\r\n\t\t\t\t\t\t\"opacity\": options.opacity,\r\n\t\t\t\t\t});\r\n\t\t\t}\r\n\t\t},\r\n\t\tshow: function () {\r\n\t\t\tthis.element.show();\r\n\t\t},\r\n\t\thide: function () {\r\n\t\t\tthis.element.hide();\r\n\t\t},\r\n\t\tremove: function () {\r\n\t\t\tthis._super.apply(this, arguments);\r\n\t\t\tthis.element.unbind(JocGame.CLICK);\r\n\t\t\t//this.element.unbind(\"holdclick\");\r\n\t\t\tthis.element.remove();\r\n\t\t},\r\n\t});\r\n\r\n\tvar GadgetImage = GadgetElement.extend({\r\n\t\tdisplayElement: function (force, options) {\r\n\t\t\tvar $this = this;\r\n\t\t\tthis._super.apply(this, arguments);\r\n\t\t\tif (force || this.options.file != options.file) {\r\n\t\t\t\tthis.options.file = options.file;\r\n\t\t\t\tGetResource(\"image|\" + options.file, function (image, imgSrc) {\r\n\t\t\t\t\tif (imgSrc == $this.options.file)\r\n\t\t\t\t\t\t$this.element.css({\r\n\t\t\t\t\t\t\t\"background-image\": \"url(\" + image.src + \")\",\r\n\t\t\t\t\t\t\t\"background-size\": \"100% 100%\",\r\n\t\t\t\t\t\t\t\"background-repeat\": \"no-repeat\",\r\n\t\t\t\t\t\t});\r\n\t\t\t\t\telse\r\n\t\t\t\t\t\tconsole.log(\"file has changed to\", $this.options.file, \"(\", imgSrc, \")\");\r\n\t\t\t\t});\r\n\t\t\t}\r\n\t\t},\r\n\t});\r\n\r\n\tvar GadgetCanvas = GadgetElement.extend({\r\n\t\tinit: function (gadget, options) {\r\n\t\t\toptions = $.extend({\r\n\t\t\t\ttag: \"canvas\",\r\n\t\t\t\tdraw: function () { },\r\n\t\t\t}, options);\r\n\t\t\tthis._super.call(this, gadget, options);\r\n\t\t\tthis.canvasContext = this.element[0].getContext(\"2d\");\r\n\t\t},\r\n\t\tdisplayElement: function (force, options) {\r\n\t\t\tthis._super.apply(this, arguments);\r\n\t\t\tthis.element.attr(\"width\", this.aWidth).attr(\"height\", this.aHeight);\r\n\t\t\t//this.canvasContext.save();\r\n\t\t\tthis.canvasContext.clearRect(0, 0, options.width, options.height);\r\n\t\t\tthis.canvasContext.translate(this.aWidth / 2, this.aHeight / 2);\r\n\t\t\tthis.canvasContext.scale(options.ratio, options.ratio);\r\n\t\t\tthis.options.draw.call(this, this.canvasContext, 1 / options.ratio);\r\n\t\t\t//this.canvasContext.restore();\r\n\t\t}\r\n\t});\r\n\r\n\tvar GadgetHexagon = GadgetCanvas.extend({\r\n\t\tinit: function (gadget, options) {\r\n\t\t\tvar $this = this;\r\n\t\t\tvar R = options.radius;\r\n\t\t\tvar L = R * Math.sqrt(3) / 2;\r\n\t\t\toptions = $.extend({\r\n\t\t\t\tlineWidthFactor: 1,\r\n\t\t\t}, options, {\r\n\t\t\t\t\tdraw: function (ctx, pixSize) {\r\n\t\t\t\t\t\tctx.lineWidth = pixSize * $this.options.lineWidthFactor;\r\n\t\t\t\t\t\tctx.beginPath();\r\n\t\t\t\t\t\tctx.moveTo(-L, L / 2);\r\n\t\t\t\t\t\tctx.lineTo(0, R);\r\n\t\t\t\t\t\tctx.lineTo(L, L / 2);\r\n\t\t\t\t\t\tctx.lineTo(L, -L / 2);\r\n\t\t\t\t\t\tctx.lineTo(0, -R);\r\n\t\t\t\t\t\tctx.lineTo(-L, -L / 2);\r\n\t\t\t\t\t\tctx.closePath();\r\n\t\t\t\t\t\tif ($this.options.strokeStyle) {\r\n\t\t\t\t\t\t\tctx.strokeStyle = $this.options.strokeStyle;\r\n\t\t\t\t\t\t\tctx.stroke();\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\tif ($this.options.fillStyle) {\r\n\t\t\t\t\t\t\tctx.fillStyle = $this.options.fillStyle;\r\n\t\t\t\t\t\t\tctx.fill();\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t},\r\n\t\t\t\t});\r\n\t\t\tthis._super.call(this, gadget, options);\r\n\t\t\tthis.element.attr(\"width\", options.width).attr(\"height\", options.height);\r\n\t\t\tthis.canvasContext = this.element[0].getContext(\"2d\");\r\n\t\t},\r\n\t});\r\n\r\n\t/*\r\n\tvar GadgetSprite=GadgetCanvas.extend({\r\n\t\tinit: function(gadget,options) {\r\n\t\t\tthis._super.apply(this,arguments);\r\n\t\t\tthis.displayArgs=null;\r\n\t\t},\r\n\t\tdisplayElement: function(force,options) {\r\n\t\t\tvar $this=this;\r\n\t\t\tthis._super.apply(this,arguments);\r\n\t\t\tif(force || this.options.file!=options.file) {\r\n\t\t\t\tGetResource(\"image|\"+options.file, function(image) {\r\n\t\t\t\t\t$this.image=image;\r\n\t\t\t\t\tif($this.displayArgs && $this.options.clipx!==undefined && $this.options.clipy!==undefined &&\r\n\t\t\t\t\t\t\t$this.options.clipwidth!==undefined && $this.options.clipheight!==undefined)\r\n\t\t\t\t\t\t$this.drawImage.apply($this,$this.displayArgs);\r\n\t\t\t\t});\r\n\t\t\t}\r\n\t\t\tif(force || this.options.clipx!=options.clipx\r\n\t\t\t\t\t|| this.options.clipy!=options.clipy\r\n\t\t\t\t\t|| this.options.clipwidth!=options.clipwidth\r\n\t\t\t\t\t|| this.options.clipheight!=options.clipheight\r\n\t\t\t\t\t) {\r\n\t\t\t\tif(this.image && options.clipx!==undefined && options.clipy!==undefined &&\r\n\t\t\t\t\t\toptions.clipwidth!==undefined && options.clipheight!==undefined) {\r\n\t\t\t\t\tthis.drawImage.call(this,force,options);\r\n\t\t\t\t} else\r\n\t\t\t\t\tthis.displayArgs=arguments;\r\n\t\t\t}\r\n\t\t\tif(this.image && options.clipx!==undefined && options.clipy!==undefined &&\r\n\t\t\t\t\toptions.clipwidth!==undefined && options.clipheight!==undefined)\r\n\t\t\t\tthis.drawImage.apply(this,arguments);\r\n\t\t\telse\r\n\t\t\t\tthis.displayArgs=arguments;\r\n\t\t},\r\n\t\tdrawImage: function(force,options) {\r\n\t\t\tthis.canvasContext.save();\r\n\t\t\tvar x0=parseInt(options.clipx+.5);\r\n\t\t\tvar y0=parseInt(options.clipy+.5);\r\n\t\t\tvar cx0=parseInt(options.clipwidth+.5);\r\n\t\t\tvar cy0=parseInt(options.clipheight+.5);\r\n\t\t\tvar x1=0;\r\n\t\t\tvar y1=0;\r\n\t\t\tvar cx1=parseInt(this.aWidth+.5);\r\n\t\t\tvar cy1=parseInt(this.aHeight+.5);\r\n\r\n\t\t\tthis.canvasContext.scale(cx1,cy1);\r\n\t\t\tthis.canvasContext.imageSmoothingEnabled=true;\r\n\r\n\t\t\tthis.canvasContext.drawImage(this.image,x0,y0,cx0,cy0,x1,y1,1,1);\r\n\t\t\t//this.canvasContext.drawImage(this.image,x0,y0,cx0,cy0,x1,y1,cx1,cy1);\r\n\t\t\tthis.canvasContext.restore();\r\n\t\t\tthis.displayArgs=null;\r\n\t\t},\r\n\t});\r\n\t*/\r\n\r\n\tvar GadgetSprite = GadgetCanvas.extend({\r\n\t\tinit: function (gadget, options) {\r\n\t\t\tthis._super.apply(this, arguments);\r\n\t\t\tthis.displayArgs = null;\r\n\t\t},\r\n\t\tdisplayElement: function (force, options) {\r\n\t\t\tvar $this = this;\r\n\t\t\tthis._super.apply(this, arguments);\r\n\t\t\tif (force || this.options.file != options.file) {\r\n\t\t\t\tGetResource(\"image|\" + options.file, function (image, imgSrc) {\r\n\t\t\t\t\tif (imgSrc == $this.options.file) {\r\n\t\t\t\t\t\t$this.image = image;\r\n\t\t\t\t\t\t$this.element.css({\r\n\t\t\t\t\t\t\t\"background-image\": \"url(\" + image.src + \")\",\r\n\t\t\t\t\t\t\t\"background-size\": \"100% 100%\",\r\n\t\t\t\t\t\t\t\"background-repeat\": \"no-repeat\",\r\n\t\t\t\t\t\t});\r\n\t\t\t\t\t}\r\n\t\t\t\t\tif ($this.displayArgs && $this.options.clipx !== undefined && $this.options.clipy !== undefined &&\r\n\t\t\t\t\t\t$this.options.clipwidth !== undefined && $this.options.clipheight !== undefined)\r\n\t\t\t\t\t\t$this.drawImage.apply($this, $this.displayArgs);\r\n\t\t\t\t});\r\n\t\t\t}\r\n\t\t\tif (force || this.options.clipx != options.clipx\r\n\t\t\t\t|| this.options.clipy != options.clipy\r\n\t\t\t\t|| this.options.clipwidth != options.clipwidth\r\n\t\t\t\t|| this.options.clipheight != options.clipheight\r\n\t\t\t) {\r\n\t\t\t\tif (this.image && options.clipx !== undefined && options.clipy !== undefined &&\r\n\t\t\t\t\toptions.clipwidth !== undefined && options.clipheight !== undefined) {\r\n\t\t\t\t\tthis.drawImage.call(this, force, options);\r\n\t\t\t\t} else\r\n\t\t\t\t\tthis.displayArgs = arguments;\r\n\t\t\t}\r\n\t\t\tif (this.image && options.clipx !== undefined && options.clipy !== undefined &&\r\n\t\t\t\toptions.clipwidth !== undefined && options.clipheight !== undefined)\r\n\t\t\t\tthis.drawImage.apply(this, arguments);\r\n\t\t\telse\r\n\t\t\t\tthis.displayArgs = arguments;\r\n\t\t},\r\n\t\tdrawImage: function (force, options) {\r\n\t\t\tvar rx = (options.clipwidth / this.aWidth);\r\n\t\t\tvar ry = (options.clipheight / this.aHeight);\r\n\t\t\tvar bcx = parseInt(this.image.width / rx + .5);\r\n\t\t\tvar bcy = parseInt(this.image.height / ry + .5);\r\n\t\t\tvar bs = \"\" + bcx + \"px \" + bcy + \"px\";\r\n\t\t\tthis.element.css({\r\n\t\t\t\t\"width\": parseInt(this.aWidth + .5),\r\n\t\t\t\t\"height\": parseInt(this.aHeight + .5),\r\n\t\t\t\t\"background-image\": options.file,\r\n\t\t\t\t\"background-size\": bs,\r\n\t\t\t\t\"background-position\": \"-\" + (parseInt(options.clipx / rx + .5)) + \"px -\" + (parseInt(options.clipy / ry + .5)) + \"px\",\r\n\t\t\t});\r\n\t\t},\r\n\t});\r\n\r\n\tvar GadgetDisk = GadgetElement.extend({\r\n\t\tinit: function (gadget, options) {\r\n\t\t\tthis._super.apply(this, arguments);\r\n\t\t},\r\n\t\tdisplayElement: function (force, options) {\r\n\t\t\tthis._super.apply(this, arguments);\r\n\t\t\tthis.element.css({\r\n\t\t\t\t\"border-radius\": \"50%\",\r\n\t\t\t});\r\n\t\t},\r\n\t});\r\n\r\n\tvar GadgetObject3D = GadgetAvatar.extend({\r\n\t\tinit: function (gadget, options) {\r\n\t\t\tvar $this = this;\r\n\t\t\tthis._super.apply(this, arguments);\r\n\t\t\tthis.displayCalled = false;\r\n\t\t\tthis.options = $.extend(true, {\r\n\t\t\t\tx: 0.0,\r\n\t\t\t\ty: 0.0,\r\n\t\t\t\tz: 0.0,\r\n\t\t\t\tcolor: null,\r\n\t\t\t\tcastShadow: true,\r\n\t\t\t\treceiveShadow: false,\r\n\t\t\t\tharbor: true,\r\n\t\t\t}, options);\r\n\t\t\tthis.createObject();\r\n\t\t},\r\n\t\tcreateObject: function () {\r\n\t\t},\r\n\t\tobjectReady: function (object3d) {\r\n\t\t\tvar $this = this;\r\n\t\t\tthis.object3d = object3d;\r\n\t\t\tobject3d.castShadow = this.options.castShadow;\r\n\t\t\tobject3d.receiveShadow = this.options.receiveShadow;\r\n\t\t\tobject3d.name = this.gadget.id;\r\n\t\t\tobject3d.matrixAutoUpdate = false;\r\n\t\t\tthis.shouldUpdate = true;\r\n\t\t\tthis.update(this.options);\r\n\t\t\t//object3d.visible=this.options.visible;\r\n\t\t\tif (this.options.harbor)\r\n\t\t\t\tthreeCtx.harbor.add(object3d);\r\n\t\t\telse\r\n\t\t\t\tthreeCtx.scene.add(object3d);\r\n\t\t},\r\n\t\tdisplay: function (options, delay) {\r\n\t\t\tvar $this = this;\r\n\t\t\tif (this.object3d) {\r\n\t\t\t\tthis.shouldUpdate = false;\r\n\t\t\t\tthis.displayObject3D.call(this, !this.displayCalled, options, delay);\r\n\t\t\t\tthis.displayCalled = true;\r\n\t\t\t\tif (this.shouldUpdate)\r\n\t\t\t\t\tthis.object3d.updateMatrix();\r\n\t\t\t}\r\n\t\t\tif (delay) {\r\n\t\t\t\t$this.animStart(options);\r\n\t\t\t\tsetTimeout(function () { $this.animEnd(options); }, delay);\r\n\t\t\t}\r\n\t\t},\r\n\t\tdisplayObject3D: function (force, options, delay) {\r\n\t\t\tvar $this = this;\r\n\t\t\tthreeCtx.animControl.trigger((isNaN(delay) ? 0 : delay) + 200);\r\n\t\t\tif (force ||\r\n\t\t\t\toptions.x != this.options.x ||\r\n\t\t\t\toptions.y != this.options.y ||\r\n\t\t\t\toptions.z != this.options.z\r\n\t\t\t) {\r\n\t\t\t\tthis.shouldUpdate = true;\r\n\t\t\t\tif (delay) {\r\n\t\t\t\t\tthis.animStart(options);\r\n\t\t\t\t\tnew TWEEN.Tween(this.object3d.position).to({\r\n\t\t\t\t\t\tx: options.x * SCALE3D,\r\n\t\t\t\t\t\ty: options.z * SCALE3D,\r\n\t\t\t\t\t\tz: options.y * SCALE3D,\r\n\t\t\t\t\t}, delay).easing(options.positionEasing ? options.positionEasing : TWEEN.Easing.Cubic.EaseInOut).onComplete(function () {\r\n\t\t\t\t\t\t$this.animEnd(options);\r\n\t\t\t\t\t}).onUpdate(function (ratio) {\r\n\t\t\t\t\t\tif (options.positionEasingUpdate)\r\n\t\t\t\t\t\t\toptions.positionEasingUpdate.call($this, ratio);\r\n\t\t\t\t\t}).start();\r\n\t\t\t\t} else {\r\n\t\t\t\t\tthis.object3d.position.x = options.x * SCALE3D;\r\n\t\t\t\t\tthis.object3d.position.y = options.z * SCALE3D;\r\n\t\t\t\t\tthis.object3d.position.z = options.y * SCALE3D;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tif (force ||\r\n\t\t\t\toptions.click != this.options.click) {\r\n\t\t\t\tif (this.options.click)\r\n\t\t\t\t\tthis.object3d.off(\"mouseup\");\r\n\t\t\t\tif (options.click) {\r\n\t\t\t\t\t//if(!threeCtx.cameraControls.hasBeenDragged())\r\n\t\t\t\t\tthis.object3d.on(\"mouseup\", function () {\r\n\t\t\t\t\t\t//if(!threeCtx.cameraControls.hasBeenDragged())\r\n\t\t\t\t\t\toptions.click.call();\r\n\t\t\t\t\t});\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\t/*\r\n\t\t\tif(force ||\r\n\t\t\t\t\toptions.holdClick != this.options.holdClick) {\r\n\t\t\t\tif(this.options.holdClick)\r\n\t\t\t\t\tthis.object3d.off(\"holdclick\");\r\n\t\t\t\tif(options.holdClick) {\r\n\t\t\t\t\t//if(!threeCtx.cameraControls.hasBeenDragged())\r\n\t\t\t\t\t\tthis.object3d.on(\"holdclick\",function(eventData){\r\n\t\t\t\t\t\t\tif(!threeCtx.cameraControls.hasBeenDragged())\r\n\t\t\t\t\t\t\t\toptions.holdClick.call($this,eventData);\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\t*/\r\n\t\t\tif (force ||\r\n\t\t\t\toptions.castShadow != this.options.castShadow) {\r\n\t\t\t\tthis.object3d.castShadow = options.castShadow\r\n\t\t\t}\r\n\t\t\tif (force ||\r\n\t\t\t\toptions.receiveShadow != this.options.receiveShadow) {\r\n\t\t\t\tthis.object3d.receiveShadow = options.receiveShadow\r\n\t\t\t}\r\n\t\t},\r\n\t\tshow: function () {\r\n\t\t\tif (arStream && !this.options.harbor)\r\n\t\t\t\treturn this.hide();\r\n\t\t\tif (this.object3d) {\r\n\t\t\t\tthis.object3d.visible = true;\r\n\t\t\t\tif (this.object3d.children) {\r\n\t\t\t\t\tfor (var c = 0; c < this.object3d.children.length; c++) {\r\n\t\t\t\t\t\tvar part = this.object3d.children[c];\r\n\t\t\t\t\t\tif (part.joclyVisible === undefined || part.joclyVisible)\r\n\t\t\t\t\t\t\tpart.visible = true;\r\n\t\t\t\t\t\telse\r\n\t\t\t\t\t\t\tpart.visible = false;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t},\r\n\t\thide: function () {\r\n\t\t\tif (this.object3d) {\r\n\t\t\t\tthis.object3d.visible = false;\r\n\t\t\t\tif (this.object3d.children) {\r\n\t\t\t\t\tfor (var c = 0; c < this.object3d.children.length; c++)\r\n\t\t\t\t\t\tthis.object3d.children[c].visible = false;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t},\r\n\t\tremove: function () {\r\n\t\t\tthis._super.apply(this, arguments);\r\n\t\t\tif (this.object3d) {\r\n\t\t\t\tif (this.options.click)\r\n\t\t\t\t\tthis.object3d.off(\"mouseup\");\r\n\t\t\t\t/*\r\n\t\t\t\tif(this.options.holdClick)\r\n\t\t\t\t\tthis.object3d.off(\"holdclick\");\r\n\t\t\t\t*/\r\n\t\t\t\tif (this.object3d.parent)\r\n\t\t\t\t\tthis.object3d.parent.remove(this.object3d);\r\n\t\t\t\tthis.object3d = null;\r\n\t\t\t}\r\n\t\t},\r\n\t\tgetMaterialMap: GetMaterialMap,\r\n\t});\r\n\r\n\tvar GadgetMesh = GadgetObject3D.extend({\r\n\t\tinit: function (gadget, options) {\r\n\t\t\toptions = $.extend(true, {\r\n\t\t\t\trotate: 0,\r\n\t\t\t\trotateX: 0,\r\n\t\t\t\trotateY: 0,\r\n\t\t\t\tscale: [1, 1, 1],\r\n\t\t\t\tmaterials: {},\r\n\t\t\t\tsmooth: 0,\r\n\t\t\t\topacity: 1,\r\n\t\t\t\tflatShading: false,\r\n\t\t\t\tmorphing: [],\r\n\t\t\t}, options, {\r\n\t\t\t\t});\r\n\t\t\tthis._super.call(this, gadget, options);\r\n\t\t},\r\n\t\tdisplayObject3D: function (force, options, delay) {\r\n\t\t\tvar $this = this;\r\n\t\t\tthis._super.apply(this, arguments);\r\n\t\t\tif (force ||\r\n\t\t\t\toptions.rotate != this.options.rotate ||\r\n\t\t\t\toptions.rotateX != this.options.rotateX ||\r\n\t\t\t\toptions.rotateY != this.options.rotateY\r\n\t\t\t) {\r\n\t\t\t\tthis.shouldUpdate = true;\r\n\t\t\t\tvar delta = options.rotate - this.options.rotate;\r\n\t\t\t\tif (delta > 180)\r\n\t\t\t\t\toptions.rotate -= 360;\r\n\t\t\t\telse if (delta < -180)\r\n\t\t\t\t\toptions.rotate += 360;\r\n\t\t\t\tdelta = options.rotateX - this.options.rotateX;\r\n\t\t\t\tif (delta > 180)\r\n\t\t\t\t\toptions.rotateX -= 360;\r\n\t\t\t\telse if (delta < -180)\r\n\t\t\t\t\toptions.rotateX += 360;\r\n\t\t\t\tdelta = options.rotateY - this.options.rotateY;\r\n\t\t\t\tif (delta > 180)\r\n\t\t\t\t\toptions.rotateY -= 360;\r\n\t\t\t\telse if (delta < -180)\r\n\t\t\t\t\toptions.rotateY += 360;\r\n\t\t\t\tif (delay) {\r\n\t\t\t\t\tthis.animStart(options);\r\n\t\t\t\t\tnew TWEEN.Tween(this.object3d.rotation).to({\r\n\t\t\t\t\t\tx: options.rotateX * (Math.PI / 180),\r\n\t\t\t\t\t\ty: options.rotate * (Math.PI / 180),\r\n\t\t\t\t\t\tz: options.rotateY * (Math.PI / 180),\r\n\t\t\t\t\t}, delay).easing(options.rotateEasing ? options.rotateEasing : TWEEN.Easing.Cubic.EaseInOut).onComplete(function () {\r\n\t\t\t\t\t\t$this.animEnd(options);\r\n\t\t\t\t\t}).start();\r\n\t\t\t\t} else {\r\n\t\t\t\t\tthis.object3d.rotation.x = options.rotateX * (Math.PI / 180);\r\n\t\t\t\t\tthis.object3d.rotation.y = options.rotate * (Math.PI / 180);\r\n\t\t\t\t\tthis.object3d.rotation.z = options.rotateY * (Math.PI / 180);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tif (force ||\r\n\t\t\t\toptions.scale[0] != this.options.scale[0] ||\r\n\t\t\t\toptions.scale[1] != this.options.scale[1] ||\r\n\t\t\t\toptions.scale[2] != this.options.scale[2]\r\n\t\t\t) {\r\n\t\t\t\tthis.shouldUpdate = true;\r\n\t\t\t\tif (delay) {\r\n\t\t\t\t\tthis.animStart(options);\r\n\t\t\t\t\tnew TWEEN.Tween(this.object3d.scale).to({\r\n\t\t\t\t\t\tx: options.scale[0],\r\n\t\t\t\t\t\ty: options.scale[2],\r\n\t\t\t\t\t\tz: options.scale[1],\r\n\t\t\t\t\t}, delay).easing(options.scaleEasing ? options.scaleEasing : TWEEN.Easing.Cubic.EaseInOut).onComplete(function () {\r\n\t\t\t\t\t\t$this.animEnd(options);\r\n\t\t\t\t\t}).start();\r\n\t\t\t\t} else {\r\n\t\t\t\t\tthis.object3d.scale.set(options.scale[0], options.scale[2], options.scale[1]);\r\n\t\t\t\t\t/*if ((options.scale[0] > 0) &&\r\n\t\t\t\t\t\t(options.scale[1] > 0) &&\r\n\t\t\t\t\t\t(options.scale[2] > 0)\r\n\t\t\t\t\t)\r\n\t\t\t\t\t\tthis.object3d.scale.set(options.scale[0],options.scale[2],options.scale[1]);\r\n\t\t\t\t\telse{\r\n\t\t\t\t\t\tvar g=this.object3d.geometry;\r\n\t\t\t\t\t\tg.dynamic = true;\r\n\t\t\t\t\t\tfor(var i = 0; i<g.faces.length; i++) {\r\n\t\t\t\t\t\t    g.faces[i].normal.x = -1*g.faces[i].normal.x;\r\n\t\t\t\t\t\t    g.faces[i].normal.y = -1*g.faces[i].normal.y;\r\n\t\t\t\t\t\t    g.faces[i].normal.z = -1*g.faces[i].normal.z;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\tg.computeVertexNormals();\r\n\t\t\t\t\t\tg.computeFaceNormals();\r\n\t\t\t\t\t\tg.applyMatrix(new THREE.Matrix4().makeScale( options.scale[0], options.scale[2], options.scale[1] ) );\r\n\t\t\t\t\t}*/\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tif (force ||\r\n\t\t\t\toptions.color != this.options.color\r\n\t\t\t) {\r\n\t\t\t\tif (this.object3d.material && this.object3d.material.color !== undefined)\r\n\t\t\t\t\tif (options.color !== null)\r\n\t\t\t\t\t\tthis.object3d.material.color.setHex(options.color);\r\n\r\n\t\t\t\t/*\r\n\t\t\t\t\t\t\t\t\tif(options.color===null)\r\n\t\t\t\t\t\t\t\t\t\tthis.object3d.material.color.setHex(0xffffff);\r\n\t\t\t\t\t\t\t\t\telse\r\n\t\t\t\t\t\t\t\t\t\tthis.object3d.material.color.setHex(options.color);\r\n\t\t\t\t*/\r\n\t\t\t}\r\n\t\t\tif (force ||\r\n\t\t\t\toptions.opacity != this.options.opacity\r\n\t\t\t) {\r\n\t\t\t\tif (this.object3d.material && this.object3d.material.opacity !== undefined) {\r\n\t\t\t\t\tif (options.opacity === null)\r\n\t\t\t\t\t\toptions.opacity = 1;\r\n\t\t\t\t\tif (delay) {\r\n\t\t\t\t\t\tthis.animStart(options);\r\n\t\t\t\t\t\tnew TWEEN.Tween(this.object3d.material).to({\r\n\t\t\t\t\t\t\topacity: options.opacity,\r\n\t\t\t\t\t\t}, delay).easing(options.opacityEasing ? options.opacityEasing : TWEEN.Easing.Cubic.EaseInOut).onComplete(function () {\r\n\t\t\t\t\t\t\t$this.animEnd(options);\r\n\t\t\t\t\t\t}).start();\r\n\t\t\t\t\t} else\r\n\t\t\t\t\t\tthis.object3d.material.opacity = options.opacity;\r\n\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tif (force ||\r\n\t\t\t\toptions.morphing.toString() != this.options.morphing.toString()\r\n\t\t\t) {\r\n\t\t\t\tthis.shouldUpdate = true;\r\n\t\t\t\tif (options.morphing.length > 0) {\r\n\t\t\t\t\tif (this.object3d.material && Array.isArray(this.object3d.material) &&\r\n\t\t\t\t\t\tthis.object3d.material.length > 0 && !this.object3d.material[0].morphTargets) {\r\n\t\t\t\t\t\tfor (var i = 0; i < this.object3d.material.length; i++)\r\n\t\t\t\t\t\t\tthis.object3d.material[i].morphTargets = true;\r\n\t\t\t\t\t}\r\n\t\t\t\t\tif (delay) {\r\n\t\t\t\t\t\tthis.animStart(options);\r\n\t\t\t\t\t\tnew TWEEN.Tween(this.object3d.morphTargetInfluences).to(options.morphing,\r\n\t\t\t\t\t\t\tdelay).easing(options.morphingEasing ? options.morphingEasing : TWEEN.Easing.Cubic.EaseInOut).onComplete(function () {\r\n\t\t\t\t\t\t\t\t$this.animEnd(options);\r\n\t\t\t\t\t\t\t}).start();\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\tfor (var i = 0; i < options.morphing.length && i < this.object3d.morphTargetInfluences.length; i++)\r\n\t\t\t\t\t\t\tthis.object3d.morphTargetInfluences[i] = options.morphing[i];\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tif (this.object3d.material && options.materials) {\r\n\t\t\t\tif (force) {\r\n\t\t\t\t\tif (Array.isArray(this.object3d.material)) {\r\n\t\t\t\t\t\tfor (var m in this.object3d.material) {\r\n\t\t\t\t\t\t\tvar mat = $this.object3d.material[m];\r\n\t\t\t\t\t\t\tif (options.materials[mat.name]) {\r\n\t\t\t\t\t\t\t\tfor (var mpi in options.materials[mat.name]) {\r\n\t\t\t\t\t\t\t\t\tvar newMatProp = options.materials[mat.name][mpi];\r\n\t\t\t\t\t\t\t\t\t(function (mat, mpi) {\r\n\t\t\t\t\t\t\t\t\t\tif (mpi == \"map\") {\r\n\t\t\t\t\t\t\t\t\t\t\tGetMaterialMap(newMatProp, function (matMpi) {\r\n\t\t\t\t\t\t\t\t\t\t\t\tmat[mpi] = matMpi;\r\n\t\t\t\t\t\t\t\t\t\t\t\tmat.needsUpdate = true;\r\n\t\t\t\t\t\t\t\t\t\t\t});\r\n\t\t\t\t\t\t\t\t\t\t} else if (mpi == \"color\") {\r\n\t\t\t\t\t\t\t\t\t\t\tif (typeof mat[\"ambient\"] != \"undefined\")\r\n\t\t\t\t\t\t\t\t\t\t\t\tmat[\"ambient\"].setHex(newMatProp);\r\n\t\t\t\t\t\t\t\t\t\t\tmat[mpi].setHex(newMatProp);\r\n\t\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t\t\telse\r\n\t\t\t\t\t\t\t\t\t\t\tmat[mpi] = newMatProp;\r\n\t\t\t\t\t\t\t\t\t})(mat, mpi, m);\r\n\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t} else {\r\n\t\t\t\t\tvar diffMat = Diff(this.options.materials, options.materials);\r\n\t\t\t\t\tif (diffMat) {\r\n\t\t\t\t\t\tfor (var mi in diffMat) {\r\n\t\t\t\t\t\t\tvar newMat = diffMat[mi];\r\n\t\t\t\t\t\t\tif (Array.isArray(this.object3d.material)) {\r\n\t\t\t\t\t\t\t\tfor (var m in this.object3d.material) {\r\n\t\t\t\t\t\t\t\t\tvar mat = $this.object3d.material[m];\r\n\t\t\t\t\t\t\t\t\tif (mat.name == mi) {\r\n\t\t\t\t\t\t\t\t\t\tif (newMat) {\r\n\t\t\t\t\t\t\t\t\t\t\tfor (var mpi in newMat) {\r\n\t\t\t\t\t\t\t\t\t\t\t\tvar newMatProp = newMat[mpi];\r\n\t\t\t\t\t\t\t\t\t\t\t\tif (newMatProp !== null) {\r\n\t\t\t\t\t\t\t\t\t\t\t\t\t(function (mat, mpi) {\r\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tif (mpi == \"map\")\r\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tGetMaterialMap(newMatProp, function (matMpi) {\r\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tmat[mpi] = matMpi;\r\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tmat.needsUpdate = true;\r\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t});\r\n\t\t\t\t\t\t\t\t\t\t\t\t\t\telse if (mpi == \"color\") {\r\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tif (typeof mat[\"ambient\"] != \"undefined\")\r\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tmat[\"ambient\"].setHex(newMatProp);\r\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tmat[mpi].setHex(newMatProp);\r\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tif (delay) {\r\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t$this.animStart(options);\r\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tif (mat[mpi] === undefined || isNaN(newMatProp)) {\r\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tmat[mpi] = newMatProp;\r\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tsetTimeout(function () {\r\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t$this.animEnd(options);\r\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t});\r\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tvar change = {};\r\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tchange[mpi] = newMatProp;\r\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tnew TWEEN.Tween(mat).to(change, delay).easing(options.materialEasing ? options.materialEasing :\r\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tTWEEN.Easing.Cubic.EaseInOut).onComplete(function () {\r\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t$this.animEnd(options);\r\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t}).start();\r\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t} else\r\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tmat[mpi] = newMatProp;\r\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t\t\t\t\t\t})(mat, mpi);\r\n\t\t\t\t\t\t\t\t\t\t\t\t} else\r\n\t\t\t\t\t\t\t\t\t\t\t\t\tdelete mat[mpi];\r\n\t\t\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\t\t\t\t\tdelete mat.map;\r\n\t\t\t\t\t\t\t\t\t\t\tdelete mat.opacity;\r\n\t\t\t\t\t\t\t\t\t\t\tdelete mat.color;\r\n\t\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t},\r\n\t});\r\n\r\n\tvar GadgetCustomMesh3D = GadgetMesh.extend({\r\n\t\tinit: function (gadget, options) {\r\n\t\t\toptions = $.extend(true, {\r\n\t\t\t\tcreate: function () { return null },\r\n\t\t\t\tdisplay: function () { },\r\n\t\t\t}, options, {\r\n\t\t\t\t});\r\n\t\t\tthis._super.call(this, gadget, options);\r\n\t\t},\r\n\t\tcreateObject: function () {\r\n\t\t\tvar $this = this;\r\n\t\t\tfunction Callback(object3d) {\r\n\t\t\t\t$this.objectReady(object3d);\r\n\t\t\t}\r\n\t\t\tvar object3d = this.options.create.call(this, Callback);\r\n\t\t\tif (object3d)\r\n\t\t\t\tthis.objectReady(object3d);\r\n\t\t},\r\n\t\tdisplayObject3D: function (force, options, delay) {\r\n\t\t\tthis._super.apply(this, arguments);\r\n\t\t\tthis.options.display.call(this, force, options, delay);\r\n\t\t},\r\n\t\treplaceMesh: function (mesh, options, delay) {\r\n\t\t\tif (this.object3d) {\r\n\t\t\t\tif (this.options.click)\r\n\t\t\t\t\tthis.object3d.off(\"mouseup\");\r\n\t\t\t\t/*\r\n\t\t\t\tif(this.options.holdClick)\r\n\t\t\t\t\tthis.object3d.off(\"holdclick\");\r\n\t\t\t\t*/\r\n\t\t\t\tif (this.object3d.parent)\r\n\t\t\t\t\tthis.object3d.parent.remove(this.object3d);\r\n\t\t\t}\r\n\t\t\tthis.object3d = mesh;\r\n\t\t\tif (this.options.visible)\r\n\t\t\t\tthis.show();\r\n\t\t\telse\r\n\t\t\t\tthis.hide();\r\n\t\t\tif (this.options.harbor)\r\n\t\t\t\tthreeCtx.harbor.add(this.object3d);\r\n\t\t\telse\r\n\t\t\t\tthreeCtx.scene.add(this.object3d);\r\n\t\t\tif (delay) {\r\n\t\t\t\tthis.displayObject3D(true, this.options);\r\n\t\t\t\tthis.displayObject3D(true, options, delay);\r\n\t\t\t} else\r\n\t\t\t\tthis.displayObject3D(true, options);\r\n\t\t},\r\n\t});\r\n\r\n\tvar GadgetPlane3D = GadgetMesh.extend({\r\n\t\tinit: function (gadget, options) {\r\n\t\t\toptions = $.extend(true, {\r\n\t\t\t\tdisplay: function () { },\r\n\t\t\t\tsx: 1000,\r\n\t\t\t\tsy: 1000,\r\n\t\t\t\tcolor: 0xffffff,\r\n\t\t\t\thorizontal: true,\r\n\t\t\t\ttexture: null,\r\n\t\t\t\tmaterial: \"basic\",\r\n\t\t\t\tside: null,\r\n\r\n\t\t\t}, options, {\r\n\t\t\t\t});\r\n\t\t\tthis._super.call(this, gadget, options);\r\n\t\t},\r\n\t\tcreateObject: function () {\r\n\t\t\tvar gg = new THREE.PlaneGeometry(this.options.sx * SCALE3D, this.options.sy * SCALE3D, 1, 1);\r\n\t\t\tvar matData = {\r\n\t\t\t\tcolor: this.options.data,\r\n\t\t\t\topacity: 0,\r\n\t\t\t}\r\n\t\t\tif (this.options.side !== undefined)\r\n\t\t\t\tmatData.side = this.options.side;\r\n\t\t\tif (this.options.transparent !== undefined)\r\n\t\t\t\tmatData.transparent = this.options.transparent;\r\n\r\n\t\t\tif (this.options.texture) {\r\n\t\t\t\tvar $this = this;\r\n\r\n\t\t\t\tvar tOptions = this.options.texture;\r\n\t\t\t\tif (tOptions.file) {\r\n\t\t\t\t\tGetMaterialMap(tOptions.file, function (texture) {\r\n\t\t\t\t\t\tif (tOptions.wrapS !== undefined)\r\n\t\t\t\t\t\t\ttexture.wrapS = tOptions.wrapS;\r\n\t\t\t\t\t\tif (tOptions.wrapT !== undefined)\r\n\t\t\t\t\t\t\ttexture.wrapT = tOptions.wrapT;\r\n\t\t\t\t\t\tif (tOptions.repeat)\r\n\t\t\t\t\t\t\ttexture.repeat.set.apply(texture.repeat, tOptions.repeat);\r\n\t\t\t\t\t\tmatData.map = texture;\r\n\r\n\t\t\t\t\t\tvar gm;\r\n\t\t\t\t\t\tswitch ($this.options.material) {\r\n\t\t\t\t\t\t\tcase \"phong\":\r\n\t\t\t\t\t\t\t\tgm = new THREE.MeshPhongMaterial(matData);\r\n\t\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\t\tdefault:\r\n\t\t\t\t\t\t\t\tgm = new THREE.MeshBasicMaterial(matData);\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\tvar mesh = new THREE.Mesh(gg, gm);\r\n\t\t\t\t\t\t$this.objectReady(mesh);\r\n\t\t\t\t\t});\r\n\r\n\t\t\t\t\treturn;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tvar gm;\r\n\t\t\tswitch (this.options.material) {\r\n\t\t\t\tcase \"phong\":\r\n\t\t\t\t\tgm = new THREE.MeshPhongMaterial(matData);\r\n\t\t\t\t\tbreak;\r\n\t\t\t\tdefault:\r\n\t\t\t\t\tgm = new THREE.MeshBasicMaterial(matData);\r\n\t\t\t}\r\n\t\t\tvar mesh = new THREE.Mesh(gg, gm);\r\n\t\t\tthis.objectReady(mesh);\r\n\t\t},\r\n\t});\r\n\r\n\t// should this class be obsoleted in favor of GadgetCustomMesh3D\r\n\tvar GadgetCustom3D = GadgetObject3D.extend({\r\n\t\tinit: function (gadget, options) {\r\n\t\t\toptions = $.extend(true, {\r\n\t\t\t\tcreate: function () { return null },\r\n\t\t\t\tdisplay: function () { },\r\n\t\t\t}, options, {\r\n\t\t\t\t});\r\n\t\t\tthis._super.call(this, gadget, options);\r\n\t\t},\r\n\t\tcreateObject: function () {\r\n\t\t\tvar $this = this;\r\n\t\t\tfunction Callback(object3d) {\r\n\t\t\t\t$this.objectReady(object3d);\r\n\t\t\t}\r\n\t\t\tvar object3d = this.options.create.call(this, Callback);\r\n\t\t\tif (object3d)\r\n\t\t\t\tthis.objectReady(object3d);\r\n\t\t},\r\n\t\tdisplayObject3D: function (force, options, delay) {\r\n\t\t\tthis._super.apply(this, arguments);\r\n\t\t\tthis.options.display.call(this, force, options, delay);\r\n\t\t},\r\n\t});\r\n\r\n\tvar GadgetMeshFile = GadgetMesh.extend({\r\n\t\tinit: function (gadget, options) {\r\n\t\t\tthis._super.apply(this, arguments);\r\n\t\t\tthis.meshFileForceDisplay = false;\r\n\t\t},\r\n\t\tcreateObject: function () {\r\n\t\t\tvar $this = this;\r\n\t\t\tvar file = this.options.file;\r\n\t\t\tvar smooth = this.options.smooth;\r\n\t\t\tGetResource(\"smoothedfilegeo|\" + this.options.smooth + \"|\" + file, function (geometry, materials) {\r\n\t\t\t\tif (file != $this.options.file)\r\n\t\t\t\t\treturn;\r\n\t\t\t\tvar materials0 = []\r\n\t\t\t\tfor (var i = 0; i < materials.length; i++)\r\n\t\t\t\t\tmaterials0.push(materials[i].clone());\r\n\t\t\t\tmaterials = materials0;\r\n\t\t\t\tif ($this.options.flatShading)\r\n\t\t\t\t\tfor (var m = 0; m < materials.length; m++) {\r\n\t\t\t\t\t\tmaterials[m].flatShading = THREE.FlatShading;\r\n\t\t\t\t\t}\r\n\t\t\t\tvar mesh = new THREE.Mesh(geometry, materials);\r\n\t\t\t\t$this.objectReady(mesh);\r\n\t\t\t\tif ($this.meshFileForceDisplay) {\r\n\t\t\t\t\t$this.displayObject3D(true, $this.meshFileForceDisplay);\r\n\t\t\t\t\t$this.meshFileForceDisplay = false;\r\n\t\t\t\t}\r\n\t\t\t});\r\n\t\t},\r\n\t\tdisplayObject3D: function (force, options, delay) {\r\n\t\t\tvar fileChange = (options.file != this.options.file);\r\n\t\t\tif (fileChange) {\r\n\t\t\t\toptions.click = null;\r\n\t\t\t\t//options.holdClick=null;\r\n\t\t\t}\r\n\t\t\tthis._super.apply(this, arguments);\r\n\t\t\tif (fileChange) {\r\n\t\t\t\tif (this.object3d) {\r\n\t\t\t\t\tif (this.options.click)\r\n\t\t\t\t\t\tthis.object3d.off(\"mouseup\");\r\n\t\t\t\t\t/*\r\n\t\t\t\t\tif(this.options.holdClick)\r\n\t\t\t\t\t\tthis.object3d.off(\"holdclick\");\r\n\t\t\t\t\t*/\r\n\t\t\t\t\tif (this.object3d.parent)\r\n\t\t\t\t\t\tthis.object3d.parent.remove(this.object3d);\r\n\t\t\t\t\tthis.object3d = null;\r\n\t\t\t\t}\r\n\t\t\t\tthis.options.file = options.file;\r\n\t\t\t\tthis.meshFileForceDisplay = options;\r\n\t\t\t\tthis.createObject();\r\n\t\t\t}\r\n\t\t},\r\n\t});\r\n\r\n\tvar Gadget3DVideo = GadgetMesh.extend({\r\n\t\tinit: function (gadget, options) {\r\n\t\t\toptions = $.extend(true, {\r\n\t\t\t\tscale: [1, 1, 1],\r\n\t\t\t\tplayerSide: 1,\r\n\t\t\t\tmakeMesh: function (videoTexture, ccvVideoTexture) {\r\n\t\t\t\t\tvar material = new THREE.MeshBasicMaterial({\r\n\t\t\t\t\t\tmap: videoTexture,\r\n\t\t\t\t\t\t// side:THREE.DoubleSide\r\n\t\t\t\t\t});\r\n\t\t\t\t\tvar geometry = new THREE.PlaneGeometry(12, 9, 1, 1);\r\n\t\t\t\t\tvar mesh = new THREE.Mesh(geometry, material);\r\n\r\n\t\t\t\t\treturn mesh;\r\n\t\t\t\t},\r\n\t\t\t\tvideoPlaying: function (on) {\r\n\t\t\t\t},\r\n\t\t\t\tccvLocked: function (on) {\r\n\t\t\t\t},\r\n\t\t\t\tccv: false,\r\n\t\t\t\tccvMargin: [.10, .10, .30, .10],\r\n\t\t\t\tccvWidth: 80,\r\n\t\t\t\tccvHeight: 60,\r\n\t\t\t\thideBeforeFirstLock: true,\r\n\t\t\t}, options);\r\n\t\t\tthis._super.call(this, gadget, options);\r\n\t\t\tthis.videoConnected = false;\r\n\t\t\tthis.videoErrorCount = 0;\r\n\t\t\tthis.videoSkipError = false;\r\n\t\t\tthis.shouldBeVisible = false;\r\n\t\t\tthis.gotFirstLock = false;\r\n\t\t},\r\n\t\tobjectReady: function (mesh) {\r\n\t\t\tmesh.visible = false;\r\n\t\t\tfor (var i = 0; i < mesh.children.length; i++)\r\n\t\t\t\tmesh.children[i].visible = false;\r\n\t\t\tthis.streamReady(Gadget3DVideo.isStreamReady(this.options.playerSide));\r\n\t\t\tthis._super.apply(this, arguments);\r\n\t\t},\r\n\t\tcreateObject: function () {\r\n\t\t\tGadget3DVideo.addAvatar(this, this.options.playerSide);\r\n\t\t\tvar ccvTexture = null;\r\n\t\t\tif (this.ccvContextKey)\r\n\t\t\t\tccvTexture = Gadget3DVideo.getCCVVideoTexture(this.options.playerSide, this.ccvContextKey)\r\n\t\t\tvar mesh = this.options.makeMesh.call(this,\r\n\t\t\t\tGadget3DVideo.getVideoTexture(this.options.playerSide), ccvTexture);\r\n\t\t\tif (mesh)\r\n\t\t\t\tthis.objectReady(mesh);\r\n\t\t},\r\n\t\tremove: function () {\r\n\t\t\tGadget3DVideo.removeAvatar(this, this.options.playerSide);\r\n\t\t\tthis._super.apply(this, arguments);\r\n\t\t},\r\n\t\tshow: function () {\r\n\t\t\tthis.shouldBeVisible = true;\r\n\t\t\tif (this.videoConnected && (this.options.ccv == false || this.gotFirstLock || !this.options.hideBeforeFirstLock))\r\n\t\t\t\tthis._super();\r\n\t\t},\r\n\t\thide: function () {\r\n\t\t\tthis.shouldBeVisible = false;\r\n\t\t\tthis._super();\r\n\t\t},\r\n\t\tstreamReady: function (on) {\r\n\t\t\tthis.videoConnected = on;\r\n\t\t\tif (on)\r\n\t\t\t\tthis.show();\r\n\t\t\telse\r\n\t\t\t\tthis.hide();\r\n\t\t},\r\n\t\tccvLocked: function (locked) {\r\n\t\t\tif (locked && this.shouldBeVisible) {\r\n\t\t\t\tthis.gotFirstLock = true;\r\n\t\t\t\tthis.show();\r\n\t\t\t}\r\n\t\t\tthis.options.ccvLocked(locked);\r\n\t\t},\r\n\t});\r\n\r\n\tGadget3DVideo.streams = {};\r\n\tGadget3DVideo.avatars = { \"1\": [], \"-1\": [] };\r\n\tGadget3DVideo.textures = { \"1\": null, \"-1\": null };\r\n\tGadget3DVideo.renderLoopHooked = false;\r\n\tGadget3DVideo.ccvLibRequested = false;\r\n\tGadget3DVideo.getStream = function (playerSide) {\r\n\t\tif (!this.streams[playerSide]) {\r\n\t\t\tvar vStream = {\r\n\t\t\t\tstream: null,\r\n\t\t\t\tavatars: this.avatars[playerSide],\r\n\t\t\t\tvideo: null,\r\n\t\t\t\tvideoImage: null,\r\n\t\t\t\tvideoContext: null,\r\n\t\t\t\tvideoTexture: null,\r\n\t\t\t\tstreamReady: false,\r\n\t\t\t\townVideoElement: false,\r\n\t\t\t\terrorCount: 0,\r\n\t\t\t\tloopCount: 0,\r\n\t\t\t\tlocal: false,\r\n\t\t\t\tccvVideoImage: null,\r\n\t\t\t\tccvInProgress: false,\r\n\t\t\t\tccvLock: null,\r\n\t\t\t\tccvContexts: {},\r\n\t\t\t\tccvLastAnalyzed: null,\r\n\t\t\t\tccvLastSuccess: null,\r\n\t\t\t}\r\n\t\t\tvar video = $(\"video[joclyhub-video='\" + playerSide + \"']\");\r\n\t\t\tif (video.length > 0) {\r\n\t\t\t\tvStream.video = video;\r\n\t\t\t} else {\r\n\t\t\t\tvStream.ownVideoElement = true;\r\n\t\t\t\tvStream.video = $(\"<video/>\").attr(\"autoplay\", \"autoplay\").width(\r\n\t\t\t\t\t160).height(120).css({\r\n\t\t\t\t\t\tvisibility: \"hidden\",\r\n\t\t\t\t\t\tposition: \"absolute\",\r\n\t\t\t\t\t\t\"z-index\": -1,\r\n\t\t\t\t\t\ttop: 0,\r\n\t\t\t\t\t}).attr(\"joclyhub-video\", playerSide).appendTo(\"body\");\r\n\t\t\t}\r\n\t\t\tvar canvas = $(\"canvas[joclyhub-video-canvas='\" + playerSide + \"']\");\r\n\t\t\tif (canvas.length > 0) {\r\n\t\t\t\tvStream.videoImage = canvas;\r\n\t\t\t\tif (this.textures[playerSide])\r\n\t\t\t\t\tvStream.videoTexture = this.textures[playerSide];\r\n\t\t\t\telse {\r\n\t\t\t\t\tvStream.videoTexture = new THREE.Texture(vStream.videoImage[0]);\r\n\t\t\t\t\tthis.textures[playerSide] = vStream.videoTexture;\r\n\t\t\t\t}\r\n\t\t\t} else {\r\n\t\t\t\tvStream.videoImage = this.makeCanvas(160, 120).attr(\"joclyhub-video-canvas\", playerSide);\r\n\t\t\t\tvStream.videoTexture = new THREE.Texture(vStream.videoImage[0]);\r\n\t\t\t\tthis.textures[playerSide] = vStream.videoTexture;\r\n\t\t\t}\r\n\t\t\tvStream.videoTexture.minFilter = THREE.LinearFilter;\r\n\t\t\tvStream.videoTexture.magFilter = THREE.LinearFilter;\r\n\t\t\tvStream.videoImageContext = vStream.videoImage[0].getContext('2d');\r\n\t\t\tthis.streams[playerSide] = vStream;\r\n\t\t}\r\n\t\treturn this.streams[playerSide];\r\n\t}\r\n\tGadget3DVideo.addStream = function (playerSide, stream, local) {\r\n\t\tvar $this = this;\r\n\t\tvar vStream = this.getStream(playerSide);\r\n\t\tvStream.stream = stream;\r\n\t\tvStream.local = local;\r\n\t\tif (threeCtx)\r\n\t\t\tthreeCtx.animControl.trigger(3000);\r\n\t\tif (!this.renderLoopHooked) {\r\n\t\t\tthis.renderLoopHooked = true;\r\n\t\t\tif (threeCtx)\r\n\t\t\t\tthreeCtx.animateCallbacks[\"Gadget3DVideo\"] = {\r\n\t\t\t\t\t_this: $this,\r\n\t\t\t\t\tcallback: $this.animate,\r\n\t\t\t\t}\r\n\t\t}\r\n\t}\r\n\tGadget3DVideo.removeStream = function (playerSide) {\r\n\t\tvar vStream = this.streams[playerSide];\r\n\t\tif (vStream) {\r\n\t\t\tif (vStream.streamReady)\r\n\t\t\t\tfor (var i = 0; i < vStream.avatars.length; i++)\r\n\t\t\t\t\tvStream.avatars[i].streamReady(false);\r\n\t\t\tif (vStream.ccvLastSuccess)\r\n\t\t\t\tvStream.ccvLastSuccess.videoImage.remove();\r\n\t\t\tif (vStream.ccvLastAnalyzed)\r\n\t\t\t\tvStream.ccvLastAnalyzed.remove();\r\n\t\t\tdelete this.streams[playerSide];\r\n\t\t\tif (this.renderLoopHooked) {\r\n\t\t\t\tvar streamCount = 0;\r\n\t\t\t\tfor (var s in this.streams)\r\n\t\t\t\t\tstreamCount++;\r\n\t\t\t\tif (streamCount == 0) {\r\n\t\t\t\t\tif (threeCtx)\r\n\t\t\t\t\t\tdelete threeCtx.animateCallbacks[\"Gadget3DVideo\"];\r\n\t\t\t\t\tthis.renderLoopHooked = false;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\tGadget3DVideo.addAvatar = function (avatar, playerSide) {\r\n\t\tthis.avatars[playerSide].push(avatar);\r\n\t\tvar vStream = this.getStream(playerSide);\r\n\t\tif (!avatar.ccvContextKey)\r\n\t\t\tavatar.ccvContextKey = \"\" + avatar.options.ccvWidth + \",\" + avatar.options.ccvHeight + \",\" + JSON.stringify(avatar.options.ccvMargin);\r\n\t\tif (!vStream.ccvContexts[avatar.ccvContextKey]) {\r\n\t\t\tvar ccvContext = {\r\n\t\t\t\twidth: avatar.options.ccvWidth,\r\n\t\t\t\theight: avatar.options.ccvHeight,\r\n\t\t\t\tmargin: avatar.options.ccvMargin,\r\n\t\t\t}\r\n\t\t\tccvContext.videoImage = this.makeCanvas(ccvContext.width, ccvContext.height);\r\n\t\t\tccvContext.videoImageContext = ccvContext.videoImage[0].getContext('2d');\r\n\t\t\tccvContext.videoImageContext.fillStyle = \"rgb(0,255,0)\";\r\n\t\t\tccvContext.videoImageContext.fillRect(0, 0, ccvContext.width, ccvContext.height);\r\n\t\t\tccvContext.videoTexture = new THREE.Texture(ccvContext.videoImage[0]);\r\n\t\t\tccvContext.videoTexture.minFilter = THREE.LinearFilter;\r\n\t\t\tccvContext.videoTexture.magFilter = THREE.LinearFilter;\r\n\t\t\tccvContext.videoTexture.needsUpdate = true;\r\n\t\t\tvStream.ccvContexts[avatar.ccvContextKey] = ccvContext;\r\n\t\t\t//debugger;\r\n\t\t}\r\n\t\treturn vStream.streamReady;\r\n\t}\r\n\tGadget3DVideo.getVideoTexture = function (playerSide) {\r\n\t\tvar vStream = this.streams[playerSide];\r\n\t\tif (vStream)\r\n\t\t\treturn vStream.videoTexture;\r\n\t\telse\r\n\t\t\treturn null;\r\n\t}\r\n\tGadget3DVideo.getCCVVideoTexture = function (playerSide, contextKey) {\r\n\t\tvar vStream = this.streams[playerSide];\r\n\t\tif (vStream) {\r\n\t\t\tvar ccvContext = vStream.ccvContexts[contextKey];\r\n\t\t\tif (ccvContext)\r\n\t\t\t\treturn ccvContext.videoTexture;\r\n\t\t}\r\n\t\treturn null;\r\n\t}\r\n\tGadget3DVideo.isStreamReady = function (playerSide) {\r\n\t\treturn this.streams[playerSide] && this.streams[playerSide].streamReady;\r\n\t}\r\n\tGadget3DVideo.isCCVLocked = function (playerSide) {\r\n\t\treturn this.streams[playerSide] && this.streams[playerSide].ccvLock;\r\n\t}\r\n\tGadget3DVideo.removeAvatar = function (avatar, playerSide) {\r\n\t\tvar vStream = this.streams[playerSide];\r\n\t\tif (vStream)\r\n\t\t\tfor (var i = 0; i < vStream.avatars.length; i++)\r\n\t\t\t\tif (avatar == vStream.avatars[i]) {\r\n\t\t\t\t\tvStream.avatars.splice(i, 1);\r\n\t\t\t\t\tbreak;\r\n\t\t\t\t}\r\n\t}\r\n\tGadget3DVideo.animate = function () {\r\n\t\tfor (var side in this.streams) {\r\n\t\t\tvar vStream = this.streams[side];\r\n\t\t\ttry {\r\n\t\t\t\tvStream.loopCount++;\r\n\t\t\t\tif (vStream.video[0].getAttribute(\"webrtc-attached\") === \"1\" &&\r\n\t\t\t\t\tvStream.video[0].readyState === vStream.video[0].HAVE_ENOUGH_DATA) {\r\n\t\t\t\t\tvStream.videoImageContext.drawImage(vStream.video[0], 0, 0,\r\n\t\t\t\t\t\tvStream.videoImage[0].width, vStream.videoImage[0].height);\r\n\t\t\t\t\tif (vStream.videoTexture) {\r\n\t\t\t\t\t\tvStream.videoTexture.needsUpdate = true;\r\n\t\t\t\t\t\tif (!vStream.streamReady) {\r\n\t\t\t\t\t\t\tvStream.streamReady = true;\r\n\t\t\t\t\t\t\tfor (var i = 0; i < vStream.avatars.length; i++)\r\n\t\t\t\t\t\t\t\tvStream.avatars[i].streamReady(true);\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t\tvar ccvLocalRequested = false;\r\n\t\t\t\t\tvar ccvRequested = false;\r\n\t\t\t\t\tfor (var i = 0; i < vStream.avatars.length; i++)\r\n\t\t\t\t\t\tif (vStream.avatars[i].options.ccv) {\r\n\t\t\t\t\t\t\tccvRequested = true;\r\n\t\t\t\t\t\t\tif (vStream.local) {\r\n\t\t\t\t\t\t\t\tccvLocalRequested = true;\r\n\t\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\tif (ccvLocalRequested) {\r\n\t\t\t\t\t\tif (typeof (ccv) == \"undefined\") { // ccv library not loaded\r\n\t\t\t\t\t\t\tif (!this.ccvLibRequested) {\r\n\t\t\t\t\t\t\t\tvar path = null;\r\n\t\t\t\t\t\t\t\tconsole.error(\"No CCV path available\");\r\n\t\t\t\t\t\t\t\tthis.ccvLibRequested = true;\r\n\t\t\t\t\t\t\t\tif (path) {\r\n\t\t\t\t\t\t\t\t\t$(\"<script/>\").attr(\"src\", path + \"/face.js\").attr(\"type\", \"text/javascript\")\r\n\t\t\t\t\t\t\t\t\t\t.appendTo($(\"head\"));\r\n\t\t\t\t\t\t\t\t\t$(\"<script/>\").attr(\"src\", path + \"/ccv.js\").attr(\"type\", \"text/javascript\")\r\n\t\t\t\t\t\t\t\t\t\t.appendTo($(\"head\"));\r\n\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\tif (!vStream.ccvInProgress)\r\n\t\t\t\t\t\t\t\tthis.ccvPoll(vStream);\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t\tif (ccvRequested)\r\n\t\t\t\t\t\tthis.ccvAnimate(vStream);\r\n\t\t\t\t\tthreeCtx.animControl.trigger();\r\n\t\t\t\t}\r\n\t\t\t} catch (e) {\r\n\t\t\t\tif (vStream.errorCount % 1000000 == 0)\r\n\t\t\t\t\tconsole.warn(\"Gadget3DVideo.animate error\", vStream.errorCount, side, e);\r\n\t\t\t\tvStream.errorCount++;\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\tGadget3DVideo.ccvLocked = function (vStream, locking) {\r\n\t\tfor (var i = 0; i < vStream.avatars.length; i++)\r\n\t\t\tvStream.avatars[i].ccvLocked(locking);\r\n\t}\r\n\tGadget3DVideo.ccvPoll = function (vStream) {\r\n\t\tvStream.ccvInProgress = true;\r\n\t\tvar width = vStream.videoImage[0].width;\r\n\t\tvar height = vStream.videoImage[0].height;\r\n\t\tvar now = Date.now();\r\n\t\tfunction CCVResult(comp) {\r\n\t\t\tif (comp.length == 0) {\r\n\t\t\t\tif (vStream.ccvLock) {\r\n\t\t\t\t\tvStream.ccvLock = null;\r\n\t\t\t\t\tGadget3DVideo.ccvLocked(vStream, false);\r\n\t\t\t\t\tWebRTC.sendCCVMessage({\r\n\t\t\t\t\t\tlocked: false,\r\n\t\t\t\t\t});\r\n\t\t\t\t}\r\n\t\t\t} else {\r\n\t\t\t\tvar face = comp[0];\r\n\t\t\t\tvar lock = vStream.ccvLock;\r\n\t\t\t\tvStream.ccvLock = {\r\n\t\t\t\t\tx: face.x,\r\n\t\t\t\t\ty: face.y,\r\n\t\t\t\t\twidth: face.width,\r\n\t\t\t\t\theight: face.height,\r\n\t\t\t\t}\r\n\t\t\t\tif (vStream.ccvLastSuccess)\r\n\t\t\t\t\tvStream.ccvLastSuccess.videoImage.remove();\r\n\t\t\t\tvStream.ccvLastSuccess = $.extend({\r\n\t\t\t\t\tvideoImage: vStream.ccvLastAnalyzed,\r\n\t\t\t\t\tcopied: false,\r\n\t\t\t\t}, vStream.ccvLock);\r\n\t\t\t\tvStream.ccvLastAnalyzed = null;\r\n\t\t\t\tvStream.ccvLastAnalyzedContext = null;\r\n\r\n\t\t\t\tif (!lock)\r\n\t\t\t\t\tGadget3DVideo.ccvLocked(vStream, true);\r\n\t\t\t\tWebRTC.sendCCVMessage({\r\n\t\t\t\t\tlocked: true,\r\n\t\t\t\t\tx: face.x,\r\n\t\t\t\t\ty: face.y,\r\n\t\t\t\t\twidth: face.width,\r\n\t\t\t\t\theight: face.height,\r\n\t\t\t\t});\r\n\t\t\t}\r\n\t\t\tReschedulePoll();\r\n\t\t}\r\n\t\tfunction ReschedulePoll() {\r\n\t\t\tsetTimeout(function () {\r\n\t\t\t\tvStream.ccvInProgress = false;\r\n\t\t\t}, 200);\r\n\t\t}\r\n\t\tif (!vStream.ccvLastAnalyzed) {\r\n\t\t\tvStream.ccvLastAnalyzed = this.makeCanvas(vStream.videoImage[0].width, vStream.videoImage[0].height);\r\n\t\t\tvStream.ccvLastAnalyzedContext = vStream.ccvLastAnalyzed[0].getContext(\"2d\");\r\n\t\t}\r\n\t\tvStream.ccvLastAnalyzedContext.drawImage(vStream.videoImage[0], 0, 0, vStream.videoImage[0].width, vStream.videoImage[0].height);\r\n\r\n\t\t/*\r\n\t\tif(WebRTC.webrtcDetectedBrowser==\"firefox\")\r\n\t\t\tccv.detect_objects({\r\n\t\t\t\t//\"canvas\" : ccv.grayscale(vStream.ccvLastAnalyzed[0]),\r\n\t\t\t\t\"canvas\" : ccv.grayscale(vStream.videoImage[0]),\r\n\t\t\t\t\"cascade\" : cascade,\r\n\t\t\t\t\"interval\" : 5,\r\n\t\t\t\t\"min_neighbors\" : 1,\r\n\t\t\t\t\"async\" : false,\r\n\t\t\t\t\"async\" : true,\r\n\t\t\t\t\"worker\" : 1\r\n\t\t\t})(CCVResult);\r\n\t\telse\r\n\t\t*/\r\n\t\tCCVResult(ccv.detect_objects({\r\n\t\t\t//\"canvas\" : ccv.grayscale(vStream.ccvLastAnalyzed[0]),\r\n\t\t\t\"canvas\": ccv.grayscale(vStream.videoImage[0]),\r\n\t\t\t\"cascade\": cascade,\r\n\t\t\t\"interval\": 5,\r\n\t\t\t\"min_neighbors\": 1,\r\n\t\t\t\"async\": false,\r\n\t\t\t\"worker\": 1\r\n\t\t}));\r\n\t}\r\n\tGadget3DVideo.makeCanvas = function (width, height) {\r\n\t\treturn $(\"<canvas/>\").attr(\"width\", width).attr(\"height\", height).width(width).height(height)\r\n\t\t\t.css({\r\n\t\t\t\tvisibility: \"hidden\",\r\n\t\t\t\tposition: \"absolute\",\r\n\t\t\t\t\"z-index\": -1,\r\n\t\t\t\ttop: 0,\r\n\t\t\t}).appendTo(\"body\");\r\n\t}\r\n\tGadget3DVideo.ccvAnimate = function (vStream) {\r\n\t\tfunction DrawImage(ccvContext, ccvLock, source) {\r\n\t\t\tvar width = ccvLock.width * (1 + ccvContext.margin[1] + ccvContext.margin[3]);\r\n\t\t\tvar height = ccvLock.height * (1 + ccvContext.margin[0] + ccvContext.margin[2]);\r\n\t\t\tvar x = ccvLock.x - ccvLock.width * ccvContext.margin[3];\r\n\t\t\tvar y = ccvLock.y - ccvLock.height * ccvContext.margin[0];\r\n\t\t\tif (x < 0) {\r\n\t\t\t\twidth += x;\r\n\t\t\t\tx = 0;\r\n\t\t\t}\r\n\t\t\tif (y < 0) {\r\n\t\t\t\theight += y;\r\n\t\t\t\ty = 0;\r\n\t\t\t}\r\n\t\t\tif (x + width > source.width)\r\n\t\t\t\twidth = source.width - x;\r\n\t\t\tif (y + height > source.height)\r\n\t\t\t\theight = source.height - y;\r\n\t\t\tccvContext.videoImageContext.drawImage(source,\r\n\t\t\t\tx, y, width, height,\r\n\t\t\t\t0, 0,\r\n\t\t\t\tccvContext.width, ccvContext.height);\r\n\t\t\tccvContext.videoTexture.needsUpdate = true;\r\n\t\t}\r\n\r\n\t\tfor (var contextKey in vStream.ccvContexts) {\r\n\t\t\tvar ccvContext = vStream.ccvContexts[contextKey];\r\n\t\t\tif (vStream.ccvLock)\r\n\t\t\t\tDrawImage(ccvContext, vStream.ccvLock, vStream.videoImage[0]);\r\n\t\t\telse if (vStream.ccvLastSuccess && !vStream.ccvLastSuccess.copied) {\r\n\t\t\t\tvStream.ccvLastSuccess.copied = true;\r\n\t\t\t\tDrawImage(ccvContext, vStream.ccvLastSuccess, vStream.ccvLastSuccess.videoImage[0]);\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\tGadget3DVideo.receiveRemoteLock = function (message) {\r\n\t\tfor (var side in this.streams) {\r\n\t\t\tvar vStream = this.streams[side];\r\n\t\t\tif (vStream.local)\r\n\t\t\t\tcontinue;\r\n\t\t\tvar lock = vStream.ccvLock;\r\n\t\t\tif (message.locked) {\r\n\t\t\t\tvStream.ccvLock = {\r\n\t\t\t\t\tx: message.x,\r\n\t\t\t\t\ty: message.y,\r\n\t\t\t\t\twidth: message.width,\r\n\t\t\t\t\theight: message.height,\r\n\t\t\t\t};\r\n\t\t\t\tif (vStream.ccvLastSuccess)\r\n\t\t\t\t\tvStream.ccvLastSuccess.videoImage.remove();\r\n\t\t\t\tvar videoImage = this.makeCanvas(vStream.videoImage[0].width, vStream.videoImage[0].height);\r\n\t\t\t\tvar videoImageContext = videoImage[0].getContext(\"2d\");\r\n\t\t\t\tvideoImageContext.drawImage(vStream.videoImage[0], 0, 0, vStream.videoImage[0].width, vStream.videoImage[0].height);\r\n\t\t\t\tvStream.ccvLastSuccess = $.extend({\r\n\t\t\t\t\tvideoImage: videoImage,\r\n\t\t\t\t\tcopied: false,\r\n\t\t\t\t}, vStream.ccvLock);\r\n\t\t\t\tif (!lock)\r\n\t\t\t\t\tGadget3DVideo.ccvLocked(vStream, true);\r\n\t\t\t} else {\r\n\t\t\t\tif (lock) {\r\n\t\t\t\t\tvStream.ccvLock = null;\r\n\t\t\t\t\tGadget3DVideo.ccvLocked(vStream, false);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\tfunction WebRTCHandler(event, data) {\r\n\t\ttry {\r\n\t\t\tif (data.webrtcType == \"mediaOn\") {\r\n\t\t\t\tif (data.ar)\r\n\t\t\t\t\tAR(data.stream);\r\n\t\t\t\telse\r\n\t\t\t\t\tGadget3DVideo.addStream(data.side, data.stream, data.local);\r\n\t\t\t} if (data.webrtcType == \"mediaOff\") {\r\n\t\t\t\tif (arStream)\r\n\t\t\t\t\tAR(null);\r\n\t\t\t\telse\r\n\t\t\t\t\tGadget3DVideo.removeStream(data.side);\r\n\t\t\t} if (data.webrtcType == \"ccv\")\r\n\t\t\t\tGadget3DVideo.receiveRemoteLock(data.message);\r\n\t\t} catch (e) {\r\n\t\t\tconsole.error(\"xd-view webrtc error\", e);\r\n\t\t}\r\n\t}\r\n\t$(document).bind(\"joclyhub.webrtc\", WebRTCHandler);\r\n\r\n\tvar Gadget3DVideoFile = GadgetCustomMesh3D.extend({\r\n\t\tinit: function (gadget, options) {\r\n\t\t\toptions = $.extend(true, {\r\n\t\t\t\tscale: [1, 1, 1],\r\n\t\t\t\tmakeMesh: function (videoTexture) {\r\n\t\t\t\t\tvar material = new THREE.MeshBasicMaterial({\r\n\t\t\t\t\t\tmap: videoTexture\r\n\t\t\t\t\t});\r\n\t\t\t\t\tvar geometry = new THREE.PlaneGeometry(this.options.width * this.SCALE3D, this.options.height * this.SCALE3D, 1, 1);\r\n\t\t\t\t\tvar mesh = new THREE.Mesh(geometry, material);\r\n\r\n\t\t\t\t\treturn mesh;\r\n\t\t\t\t},\r\n\t\t\t\twidth: 12,\r\n\t\t\t\theight: 9,\r\n\t\t\t}, options);\r\n\t\t\tthis.videoPlayer = Gadget3DVideoFile.GetVideoPlayer(options.src);\r\n\t\t\tthis._super.call(this, gadget, options);\r\n\t\t},\r\n\t\tcreateObject: function () {\r\n\t\t\tvar mesh = this.options.makeMesh.call(this, this.videoPlayer.texture);\r\n\t\t\tif (mesh)\r\n\t\t\t\tthis.objectReady(mesh);\r\n\t\t},\r\n\t\tremove: function () {\r\n\t\t\tvar videoPlayer = videoPlayers[this.options.src];\r\n\t\t\tif (videoPlayer) {\r\n\t\t\t\tvideoPlayer.count--;\r\n\t\t\t\tif (videoPlayer.count == 0) {\r\n\t\t\t\t\tdelete threeCtx.animateCallbacks[\"Gadget3DVideoFile.\" + this.options.src];\r\n\t\t\t\t\tvideoPlayer.tag.remove();\r\n\t\t\t\t\tvideoPlayer.canvas.remove();\r\n\t\t\t\t\tdelete videoPlayers[this.options.src];\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tthis._super.apply(this, arguments);\r\n\t\t},\r\n\t});\r\n\r\n\tvar videoPlayers = {};\r\n\tGadget3DVideoFile.GetVideoPlayer = function (url) {\r\n\t\tvar videoPlayer = videoPlayers[url];\r\n\t\tif (!videoPlayer) {\r\n\t\t\tvar width = 638;\r\n\t\t\tvar height = 360;\r\n\t\t\tvar videoTag = $(\"<video/>\").attr(\"autoplay\", \"autoplay\")./*attr(\"muted\",\"muted\").*/attr(\"loop\", \"loop\").css({\r\n\t\t\t\twidth: width,\r\n\t\t\t\theight: height,\r\n\t\t\t\tposition: \"absolute\",\r\n\t\t\t}).append($(\"<source/>\").attr(\"src\", url).attr(\"type\", \"video/webm\")).appendTo(\"body\");\r\n\t\t\tvideoPlayer = {\r\n\t\t\t\tcount: 1,\r\n\t\t\t\ttag: videoTag,\r\n\t\t\t\tcanvas: Gadget3DVideo.makeCanvas(width, height),\r\n\t\t\t}\r\n\t\t\tvideoPlayer.context = videoPlayer.canvas[0].getContext('2d');\r\n\t\t\tvideoPlayer.context.fillStyle = \"rgb(0,255,0)\";\r\n\t\t\tvideoPlayer.context.fillRect(0, 0, width, height);\r\n\r\n\t\t\tvideoPlayer.texture = new THREE.Texture(videoPlayer.canvas[0]);\r\n\t\t\tvideoPlayer.texture.minFilter = THREE.LinearFilter;\r\n\t\t\tvideoPlayer.texture.magFilter = THREE.LinearFilter;\r\n\t\t\tvideoPlayer.texture.needsUpdate = true;\r\n\r\n\t\t\tfunction Animate() {\r\n\t\t\t\tvar ctx = videoPlayer.context;\r\n\t\t\t\tctx.drawImage(videoPlayer.tag[0], 0, 0,\r\n\t\t\t\t\twidth, height);\r\n\t\t\t\tvideoPlayer.texture.needsUpdate = true;\r\n\t\t\t}\r\n\t\t\tthreeCtx.animateCallbacks[\"Gadget3DVideoFile.\" + url] = {\r\n\t\t\t\t_this: null,\r\n\t\t\t\tcallback: Animate,\r\n\t\t\t}\r\n\r\n\t\t\tvideoPlayers[url] = videoPlayer;\r\n\t\t} else\r\n\t\t\tvideoPlayer.count++;\r\n\r\n\t\treturn videoPlayer;\r\n\t}\r\n\r\n\r\n\tvar GadgetCamera = GadgetObject3D.extend({\r\n\t\tinit: function (gadget, options) {\r\n\t\t\tthis._super.call(this, gadget, options);\r\n\t\t\t//this.object3d=threeCtx.camera;\r\n\t\t\tthis.object3d = threeCtx.body;\r\n\t\t\tthis.cameraObject = this.object3d.children[0];\r\n\t\t\tthis.targetAnim = null;\r\n\t\t\tthis.camTarget = threeCtx.camTarget;\r\n\t\t},\r\n\t\tdisplayObject3D: function (force, options, delay) {\r\n\t\t\tvar $this = this;\r\n\t\t\tthis.options.x = this.object3d.position.x / SCALE3D;\r\n\t\t\tthis.options.y = this.object3d.position.z / SCALE3D;\r\n\t\t\tthis.options.z = this.object3d.position.y / SCALE3D;\r\n\t\t\tthis._super.apply(this, arguments);\r\n\t\t\tif (force ||\r\n\t\t\t\toptions.targetX * SCALE3D != threeCtx.cameraControls.camTarget.x ||\r\n\t\t\t\toptions.targetY * SCALE3D != threeCtx.cameraControls.camTarget.z ||\r\n\t\t\t\toptions.targetZ * SCALE3D != threeCtx.cameraControls.camTarget.y\r\n\t\t\t) {\r\n\t\t\t\tif (delay) {\r\n\t\t\t\t\tvar traveling = options.traveling;\r\n\t\t\t\t\tvar x0 = threeCtx.cameraControls.camTarget.x;\r\n\t\t\t\t\tvar y0 = threeCtx.cameraControls.camTarget.y;\r\n\t\t\t\t\tvar z0 = threeCtx.cameraControls.camTarget.z;\r\n\r\n\t\t\t\t\toptions.traveling = false;\r\n\t\t\t\t\tif (this.targetAnim) {\r\n\t\t\t\t\t\tthis.targetAnim.stop();\r\n\t\t\t\t\t\t//this.animEnd(this.targetCallback);\r\n\t\t\t\t\t\tthis.animEnd(options);\r\n\t\t\t\t\t}\r\n\t\t\t\t\t//this.targetCallback=callback;\r\n\t\t\t\t\tthis.animStart(options);\r\n\t\t\t\t\tthis.targetAnim = new TWEEN.Tween(threeCtx.cameraControls.camTarget).to({\r\n\t\t\t\t\t\tx: options.targetX * SCALE3D,\r\n\t\t\t\t\t\ty: options.targetZ * SCALE3D,\r\n\t\t\t\t\t\tz: options.targetY * SCALE3D,\r\n\t\t\t\t\t}, delay).easing(options.targetEasing ? options.targetEasing : TWEEN.Easing.Cubic.EaseInOut).onComplete(function () {\r\n\t\t\t\t\t\t$this.targetAnim = null;\r\n\t\t\t\t\t\t$this.animEnd(options);\r\n\t\t\t\t\t}).onUpdate(function (ratio) {\r\n\t\t\t\t\t\tif (options.targetEasingUpdate)\r\n\t\t\t\t\t\t\toptions.targetEasingUpdate.call($this, ratio);\r\n\t\t\t\t\t\tif (traveling) {\r\n\t\t\t\t\t\t\tvar dx = threeCtx.cameraControls.camTarget.x - x0;\r\n\t\t\t\t\t\t\tvar dy = threeCtx.cameraControls.camTarget.y - y0;\r\n\t\t\t\t\t\t\tvar dz = threeCtx.cameraControls.camTarget.z - z0;\r\n\t\t\t\t\t\t\tx0 = threeCtx.cameraControls.camTarget.x;\r\n\t\t\t\t\t\t\ty0 = threeCtx.cameraControls.camTarget.y;\r\n\t\t\t\t\t\t\tz0 = threeCtx.cameraControls.camTarget.z;\r\n\t\t\t\t\t\t\t//$this.object3d.position.add(new THREE.Vector3(dx,dy,dz));\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\t//$this.object3d.lookAt(threeCtx.cameraControls.camTarget);\r\n\t\t\t\t\t\t$this.cameraObject.lookAt(threeCtx.cameraControls.camTarget);\r\n\t\t\t\t\t}).start();\r\n\t\t\t\t} else {\r\n\t\t\t\t\tthreeCtx.cameraControls.camTarget.x = options.targetX * SCALE3D;\r\n\t\t\t\t\tthreeCtx.cameraControls.camTarget.y = options.targetZ * SCALE3D;\r\n\t\t\t\t\tthreeCtx.cameraControls.camTarget.z = options.targetY * SCALE3D;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t},\r\n\t});\r\n\r\n\tfunction CreateCameraGadget() {\r\n\t\txdv.createGadget(\"camera\", {\r\n\t\t\t\"3d\": {\r\n\t\t\t\ttype: \"camera3d\",\r\n\t\t\t\tx: threeCtx.camera.position.x / SCALE3D,\r\n\t\t\t\ty: threeCtx.camera.position.z / SCALE3D,\r\n\t\t\t\tz: threeCtx.camera.position.y / SCALE3D,\r\n\t\t\t\ttargetX: threeCtx.cameraControls.camTarget.x / SCALE3D,\r\n\t\t\t\ttargetY: threeCtx.cameraControls.camTarget.z / SCALE3D,\r\n\t\t\t\ttargetZ: threeCtx.cameraControls.camTarget.y / SCALE3D,\r\n\t\t\t},\r\n\t\t});\r\n\t\txdv.saveGadgetProps(\"camera\", [\"targetX\", \"targetY\", \"targetZ\"], \"initial\");\r\n\t\txdv.updateGadget(\"camera\", {\r\n\t\t\t\"3d\": {\r\n\t\t\t\tvisible: true,\r\n\t\t\t},\r\n\t\t});\r\n\t}\r\n\r\n\t/* ======================================== */\r\n\r\n\tvar avatarTypes = {\r\n\t\t\"image\": GadgetImage,\r\n\t\t\"element\": GadgetElement,\r\n\t\t\"canvas\": GadgetCanvas,\r\n\t\t\"hexagon\": GadgetHexagon,\r\n\t\t\"sprite\": GadgetSprite,\r\n\t\t\"disk\": GadgetDisk,\r\n\t\t\"meshfile\": GadgetMeshFile,\r\n\t\t\"custom3d\": GadgetCustom3D,\r\n\t\t\"plane3d\": GadgetPlane3D,\r\n\t\t\"custommesh3d\": GadgetCustomMesh3D,\r\n\t\t\"video3d\": Gadget3DVideo,\r\n\t\t\"camera3d\": GadgetCamera,\r\n\t\t\"videofile3d\": Gadget3DVideoFile,\r\n\t}\r\n\r\n\r\n\t/* ======================================== */\r\n\r\n\tvar areaElements = null;\r\n\r\n\tView.Game.CamAnim = {\r\n\t\tisSupported: function () {\r\n\t\t\treturn !!threeCtx;\r\n\t\t},\r\n\t\tisRunning: function () {\r\n\t\t\treturn threeCtx && threeCtx.camAnim;\r\n\t\t},\r\n\t\tset: function (on) {\r\n\t\t\tif (threeCtx)\r\n\t\t\t\tthreeCtx.setCamAnim(on);\r\n\t\t},\r\n\t}\r\n\r\n\tView.Game.InitView = function () {\r\n\r\n\t\tresourcesMap = this.resources || {};\r\n\r\n\t\tif (this != xdv.game) {\r\n\t\t\txdv.game = this;\r\n\t\t\tif (this.mWidget.find(\".jocly-xdv-area\").length == 0) {\r\n\t\t\t\tarea = $(\"<div/>\").css({\r\n\t\t\t\t\t\"position\": \"absolute\",\r\n\t\t\t\t\t\"z-index\": 0,\r\n\t\t\t\t\t\"overflow\": \"hidden\",\r\n\t\t\t\t}).addClass(\"jocly-xdv-area\").appendTo(this.mWidget);\r\n\t\t\t}\r\n\t\t}\r\n\t\tif (areaElements) {\r\n\t\t\tareaElements.appendTo(area);\r\n\t\t\tareaElements = null;\r\n\t\t}\r\n\r\n\t\tif (!xdv.initDone) {\r\n\t\t\tthis.xdInit(xdv);\r\n\t\t\txdv.initDone = true;\r\n\t\t}\r\n\r\n\t\tvar needs3DUpdate = false;\r\n\t\tif (!currentSkin || this.mSkin != currentSkin.name) {\r\n\t\t\tcurrentSkin = null;\r\n\t\t\tfor (var i = 0; i < this.mViewOptions.skins.length; i++) {\r\n\t\t\t\tvar skin = this.mViewOptions.skins[i];\r\n\t\t\t\tif (skin.name == this.mSkin) {\r\n\t\t\t\t\tcurrentSkin = skin;\r\n\t\t\t\t\tbreak;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tif (currentSkin == null) {\r\n\t\t\t\tLog(\"!!! InitView\", \"skin\", this.mSkin, \"not found\");\r\n\t\t\t\treturn;\r\n\t\t\t}\r\n\t\t\txdv.unbuildGadgets();\r\n\t\t\tareaElements = null;\r\n\t\t\tif (currentSkin[\"3d\"])\r\n\t\t\t\tneeds3DUpdate = true;\r\n\t\t}\r\n\r\n\t\tvar areaWidth = Math.min(this.mGeometry.width, this.mGeometry.height\r\n\t\t\t* (this.mViewOptions.preferredRatio || 1));\r\n\t\tvar areaHeight = Math.min(this.mGeometry.width / (this.mViewOptions.preferredRatio || 1), this.mGeometry.height);\r\n\t\tvar areaCenter;\r\n\t\tif (currentSkin[\"3d\"]) {\r\n\t\t\tarea.css({\r\n\t\t\t\tleft: 0,\r\n\t\t\t\ttop: 0,\r\n\t\t\t\twidth: this.mGeometry.width,\r\n\t\t\t\theight: this.mGeometry.height,\r\n\t\t\t});\r\n\t\t\tareaCenter = {\r\n\t\t\t\tx: this.mGeometry.width / 2,\r\n\t\t\t\ty: this.mGeometry.height / 2,\r\n\t\t\t};\r\n\t\t\tif (!threeCtx) {\r\n\t\t\t\tif (!THREE.Object3D._threexDomEvent) {\r\n\t\t\t\t\tTHREE.Object3D._threexDomEvent = new THREEx.DomEvent();\r\n\t\t\t\t}\r\n\t\t\t\tthreeCtx = BuildThree(this, areaWidth, areaHeight);\r\n\t\t\t\tCreateCameraGadget();\r\n\t\t\t\tthreeCtx.camera.updateProjectionMatrix();\r\n\t\t\t} else {\r\n\t\t\t\tthreeCtx.renderer.setSize(this.mGeometry.width, this.mGeometry.height);\r\n\t\t\t\tthreeCtx.anaglyphEffect.setSize(this.mGeometry.width, this.mGeometry.height);\r\n\t\t\t\tthreeCtx.camera.aspect = this.mGeometry.width / this.mGeometry.height;\r\n\t\t\t\tthreeCtx.camera.updateProjectionMatrix();\r\n\t\t\t}\r\n\r\n\t\t\tTHREE.Object3D._threexDomEvent.setDOMElement(threeCtx.renderer.domElement);\r\n\t\t\tTHREE.Object3D._threexDomEvent.setBoundContext(THREEx_boundContext);\r\n\t\t\tTHREE.Object3D._threexDomEvent.camera(threeCtx.camera);\r\n\r\n\t\t\tResumePendingResources();\r\n\r\n\t\t\tthreeCtx.animControl.trigger();\r\n\t\t\tif (needs3DUpdate) {\r\n\r\n\t\t\t\tvar cameraData = $.extend(true, {\r\n\t\t\t\t\tradius: 12,\r\n\t\t\t\t\televationAngle: 60,\r\n\t\t\t\t\trotationAngle: 90,\r\n\t\t\t\t\tdistMax: 20,\r\n\t\t\t\t\tdistMin: 0,\r\n\t\t\t\t\televationMax: 89,\r\n\t\t\t\t\televationMin: 10,\r\n\t\t\t\t\tstartAngle: 90,\r\n\t\t\t\t\tcamAnim: false,\r\n\t\t\t\t\tlimitCamMoves: true,\r\n\t\t\t\t\tenableDrag: true,\r\n\t\t\t\t\ttargetBounds: [3000, 3000, 3000],\r\n\t\t\t\t\ttarget: [0, 0, 800],\r\n\t\t\t\t\tfov: 55,\r\n\t\t\t\t\tnear: .01\r\n\t\t\t\t}, currentSkin.camera);\r\n\r\n\t\t\t\t// update FOV\r\n\t\t\t\tthreeCtx.camera.fov = cameraData.fov;\r\n\t\t\t\tthreeCtx.camera.near = cameraData.near;\r\n\t\t\t\tthreeCtx.camera.updateProjectionMatrix();\r\n\r\n\t\t\t\t$.extend(threeCtx.cameraControls, {\r\n\t\t\t\t\tminDistance: cameraData.distMin,\r\n\t\t\t\t\tmaxDistance: cameraData.distMax,\r\n\t\t\t\t\tminPolarAngle: (90 - cameraData.elevationMax) * Math.PI / 180,\r\n\t\t\t\t\tmaxPolarAngle: (90 - cameraData.elevationMin) * Math.PI / 180,\r\n\t\t\t\t\tenableDrag: cameraData.enableDrag,\r\n\t\t\t\t\ttargetBounds: [cameraData.targetBounds[0] * SCALE3D, cameraData.targetBounds[2] * SCALE3D, cameraData.targetBounds[1] * SCALE3D],\r\n\t\t\t\t});\r\n\r\n\t\t\t\tvar camPosition = {\r\n\t\t\t\t\tx: cameraData.radius * Math.cos(cameraData.elevationAngle * Math.PI / 180) * Math.cos(cameraData.rotationAngle * Math.PI / 180),\r\n\t\t\t\t\tz: cameraData.radius * Math.cos(cameraData.elevationAngle * Math.PI / 180) * Math.sin(cameraData.rotationAngle * Math.PI / 180),\r\n\t\t\t\t\ty: cameraData.radius * Math.sin(cameraData.elevationAngle * Math.PI / 180),\r\n\t\t\t\t}\r\n\r\n\t\t\t\tvar camTarget = {\r\n\t\t\t\t\tx: cameraData.target[0],\r\n\t\t\t\t\ty: cameraData.target[1],\r\n\t\t\t\t\tz: cameraData.target[2],\r\n\t\t\t\t}\r\n\t\t\t\txdv.updateGadget(\"camera\", {\r\n\t\t\t\t\t\"3d\": {\r\n\t\t\t\t\t\tx: camPosition.x / SCALE3D,\r\n\t\t\t\t\t\ty: camPosition.z / SCALE3D,\r\n\t\t\t\t\t\tz: camPosition.y / SCALE3D,\r\n\t\t\t\t\t\ttargetX: camTarget.x,\r\n\t\t\t\t\t\ttargetY: camTarget.y,\r\n\t\t\t\t\t\ttargetZ: camTarget.z,\r\n\t\t\t\t\t},\r\n\t\t\t\t});\r\n\t\t\t\tthreeCtx.cameraControls.camTarget.copy(camTarget);\r\n\t\t\t\t//threeCtx.cameraControls.camera.position.copy(camPosition);\r\n\t\t\t\tthreeCtx.cameraControls.update();\r\n\r\n\t\t\t\tvar world = {\r\n\t\t\t\t\tcolor: 0x205D7C,\r\n\t\t\t\t\tfog: true,\r\n\t\t\t\t\tfogNear: 10,\r\n\t\t\t\t\tfogFar: 100,\r\n\t\t\t\t\tlightCastShadow: true,\r\n\t\t\t\t\tlightIntensity: 1.75,\r\n\t\t\t\t\tlightPosition: { x: -12, y: 12, z: 12 },\r\n\t\t\t\t\t//lightShadowDarkness: 0.75,\r\n\t\t\t\t\tambientLightColor: 0xbbbbbb,\r\n\t\t\t\t\tskyLightPosition: { x: -45, y: 45, z: 45 },\r\n\t\t\t\t\tskyLightIntensity: 2,\r\n\t\t\t\t}\r\n\t\t\t\t$.extend(true, world, currentSkin.world);\r\n\t\t\t\tif (threeCtx.scene.fog) {\r\n\t\t\t\t\tthreeCtx.scene.remove(threeCtx.scene.fog);\r\n\t\t\t\t\tdelete threeCtx.scene.fog;\r\n\t\t\t\t}\r\n\t\t\t\tif (world.fog) {\r\n\t\t\t\t\tvar fogColor = world.color;\r\n\t\t\t\t\tif (world.fogColor) fogColor = world.fogColor;\r\n\t\t\t\t\tthreeCtx.scene.fog = new THREE.Fog(fogColor, world.fogNear, world.fogFar);\r\n\t\t\t\t}\r\n\r\n\t\t\t\tthreeCtx.world = world;\r\n\t\t\t\tthreeCtx.renderer.setClearColor(new THREE.Color(world.color), 1);\r\n\t\t\t\tthreeCtx.light.castShadow = world.lightCastShadow;\r\n\t\t\t\tthreeCtx.light.intensity = world.lightIntensity;\r\n\t\t\t\tthreeCtx.light.position.set(world.lightPosition.x, world.lightPosition.y, world.lightPosition.z);\r\n\t\t\t\t//threeCtx.light.shadowDarkness=world.lightShadowDarkness;\r\n\t\t\t\tthreeCtx.ambientLight.color.setHex(world.ambientLightColor);\r\n\t\t\t\tthreeCtx.skyLight.intensity = world.skyLightIntensity;\r\n\t\t\t\tthreeCtx.skyLight.position.set(world.skyLightPosition.x, world.skyLightPosition.y, world.skyLightPosition.z);\r\n\t\t\t}\r\n\t\t\tthreeCtx.renderer.domElement.style.display = \"block\";\r\n\t\t} else {\r\n\t\t\tarea.css({\r\n\t\t\t\tleft: (this.mGeometry.width - areaWidth) / 2,\r\n\t\t\t\ttop: (this.mGeometry.height - areaHeight) / 2,\r\n\t\t\t\twidth: areaWidth,\r\n\t\t\t\theight: areaHeight,\r\n\t\t\t});\r\n\t\t\tareaCenter = {\r\n\t\t\t\tx: areaWidth / 2,\r\n\t\t\t\ty: areaHeight / 2,\r\n\t\t\t}\r\n\t\t\tif (threeCtx)\r\n\t\t\t\tthreeCtx.renderer.domElement.style.display = \"none\";\r\n\t\t}\r\n\r\n\t\tthis.xdBuildScene(xdv);\r\n\t\t//xdv.updateArea(Math.min(areaWidth,areaHeight)/VSIZE,areaCenter);\r\n\t\txdv.updateArea(Math.max(areaWidth, areaHeight) / VSIZE, areaCenter);\r\n\t}\r\n\r\n\tView.Game.DestroyView = function () {\r\n\t\tif (!xdv.game) {\r\n\t\t\tLog(\"!!! DestroyView\", \"game already unset\");\r\n\t\t\treturn;\r\n\t\t}\r\n\t\tif (resLoadingMask)\r\n\t\t\tresLoadingMask.hide();\r\n\t\txdv.game = null;\r\n\t\tareaElements = area.children().detach();\r\n\t\tif (threeCtx) {\r\n\t\t\tif (threeCtx.cameraControls.autoRotate)\r\n\t\t\t\tthreeCtx.cameraControls.autoRotate = false;\r\n\t\t}\r\n\t\t//threeCtx.animControl.stop();\r\n\t}\r\n\r\n\tView.Game.CloseView = function () {\r\n\t\txdv.unbuildGadgets();\r\n\r\n\t\tif (threeCtx) {\r\n\t\t\tTHREE.Object3D._threexDomEvent.unsetBoundContext(THREEx_boundContext);\r\n\t\t\tthreeCtx.cameraControls.destroy();\r\n\t\t\tthreeCtx = null;\r\n\t\t}\r\n\t\tInitGlobals();\r\n\t}\r\n\r\n\tView.Game.xdResourceLoaded = function (res) {\r\n\t\tif (/^map\\|/.test(res))\r\n\t\t\treturn false;\r\n\t\tif (resources[res] && resources[res].status == \"loaded\")\r\n\t\t\treturn true;\r\n\t\telse\r\n\t\t\treturn false;\r\n\t}\r\n\r\n\tView.Game.xdLoadResources = function (ress, callback) {\r\n\t\tvar resCount = 0;\r\n\t\tfunction ResLoaded() {\r\n\t\t\tif (--resCount == 0)\r\n\t\t\t\tcallback();\r\n\t\t}\r\n\t\tfor (var i = 0; i < ress.length; i++) {\r\n\t\t\tresCount++;\r\n\t\t\tvar m = /^map\\|(.*)$/.exec(ress[i]);\r\n\t\t\tif (m)\r\n\t\t\t\tGetMaterialMap(m[1], function () {\r\n\t\t\t\t\tsetTimeout(ResLoaded, 0);\r\n\t\t\t\t});\r\n\t\t\telse\r\n\t\t\t\tGetResource(ress[i], function () {\r\n\t\t\t\t\tsetTimeout(ResLoaded, 0);\r\n\t\t\t\t});\r\n\t\t}\r\n\t}\r\n\r\n\tView.Game.xdExternalCommand = function (cmd, scope) {\r\n\t\tswitch (cmd.type) {\r\n\t\t\tcase 'updateCamera':\r\n\t\t\t\txdv.updateGadget(\"camera\", {\r\n\t\t\t\t\t\"3d\": cmd.camera,\r\n\t\t\t\t}, cmd.delay || 0);\r\n\t\t\t\tbreak;\r\n\t\t\tcase 'getCamera':\r\n\t\t\t\tvar resp = {\r\n\t\t\t\t\ttype: \"camera\",\r\n\t\t\t\t\tcameraId: cmd.cameraId,\r\n\t\t\t\t}\r\n\t\t\t\tif (threeCtx) {\r\n\t\t\t\t\tresp.camera = {\r\n\t\t\t\t\t\tx: threeCtx.camera.position.x / SCALE3D,\r\n\t\t\t\t\t\ty: threeCtx.camera.position.z / SCALE3D,\r\n\t\t\t\t\t\tz: threeCtx.camera.position.y / SCALE3D,\r\n\t\t\t\t\t\ttargetX: threeCtx.cameraControls.camTarget.x / SCALE3D,\r\n\t\t\t\t\t\ttargetY: threeCtx.cameraControls.camTarget.z / SCALE3D,\r\n\t\t\t\t\t\ttargetZ: threeCtx.cameraControls.camTarget.y / SCALE3D,\r\n\t\t\t\t\t}\r\n\t\t\t\t} else {\r\n\t\t\t\t\tconsole.warn(\"cannot get camera without 3D context\");\r\n\t\t\t\t\tresp.camera = null;\r\n\t\t\t\t}\r\n\t\t\t\tscope.sendEmbed(resp);\r\n\t\t\t\tbreak;\r\n\t\t\tcase 'snapshot':\r\n\t\t\t\tvar resp = {\r\n\t\t\t\t\ttype: \"snapshot\",\r\n\t\t\t\t\tsnapshotId: cmd.snapshotId,\r\n\t\t\t\t}\r\n\t\t\t\tif (threeCtx) {\r\n\t\t\t\t\tvar renderer = threeCtx.renderer;\r\n\t\t\t\t\tvar canvas = renderer.domElement;\r\n\t\t\t\t\trenderer.render(threeCtx.scene, threeCtx.camera);\r\n\t\t\t\t\tresp.image = canvas.toDataURL(\"image/png\");\r\n\t\t\t\t} else {\r\n\t\t\t\t\tconsole.warn(\"cannot get snapshot without 3D context\");\r\n\t\t\t\t\tresp.image = null;\r\n\t\t\t\t}\r\n\t\t\t\tscope.sendEmbed(resp);\r\n\t\t\t\tbreak;\r\n\t\t}\r\n\t}\r\n\r\n\tView.Game.ViewControl = function (cmd, options) {\r\n\t\toptions = options || {};\r\n\t\tvar promise = new Promise(function (resolve, reject) {\r\n\t\t\tswitch (cmd) {\r\n\t\t\t\tcase \"enterAnaglyph\":\r\n\t\t\t\t\tif (threeCtx) {\r\n\t\t\t\t\t\tthreeCtx.anaglyph = true;\r\n\t\t\t\t\t\tvar factor = 2.5;\r\n\t\t\t\t\t\tthreeCtx.scene.scale.set(1 / factor, 1 / factor, 1 / factor);\r\n\t\t\t\t\t\tthreeCtx.camera.scale.set(factor, factor, factor);\r\n\t\t\t\t\t\tthreeCtx.animControl.trigger();\r\n\t\t\t\t\t};\r\n\t\t\t\t\tresolve();\r\n\t\t\t\t\tbreak;\r\n\r\n\t\t\t\tcase \"exitAnaglyph\":\r\n\t\t\t\t\tif (threeCtx) {\r\n\t\t\t\t\t\tthreeCtx.anaglyph = false;\r\n\t\t\t\t\t\tthreeCtx.scene.scale.set(1, 1, 1);\r\n\t\t\t\t\t\tthreeCtx.camera.scale.set(1, 1, 1);\r\n\t\t\t\t\t\tthreeCtx.animControl.trigger();\r\n\t\t\t\t\t};\r\n\t\t\t\t\tresolve();\r\n\t\t\t\t\tbreak;\r\n\r\n\t\t\t\tcase \"stopAnimations\":\r\n\t\t\t\t\tvar animCount = 0;\r\n\t\t\t\t\tvar toBeDeleted = [];\r\n\t\t\t\t\tTWEEN.getAll().forEach(function(tween) {\r\n\t\t\t\t\t\tanimCount++;\r\n\t\t\t\t\t\tif(tween !== threeCtx.dolly)\r\n\t\t\t\t\t\t\ttoBeDeleted.push(tween);\r\n\t\t\t\t\t});\r\n\t\t\t\t\ttoBeDeleted.forEach(function(tween) {\r\n\t\t\t\t\t\tTWEEN.remove(tween);\r\n\t\t\t\t\t});\r\n\t\t\t\t\tresolve(animCount > 0);\r\n\t\t\t\t\tbreak;\r\n\r\n\t\t\t\tcase \"setPanorama\":\r\n\t\t\t\t\tif (options.pictureUrl || options.pictureData) {\r\n\t\t\t\t\t\txdv.removeGadget(\"panorama\");\r\n\t\t\t\t\t\txdv.createGadget(\"panorama\", {\r\n\t\t\t\t\t\t\t\"3d\": {\r\n\t\t\t\t\t\t\t\ttype: \"custommesh3d\",\r\n\t\t\t\t\t\t\t\tharbor: false,\r\n\t\t\t\t\t\t\t\trotate: options.rotate || 0,\r\n\t\t\t\t\t\t\t\tcreate: function (callback) {\r\n\t\t\t\t\t\t\t\t\tvar geometry = new THREE.SphereGeometry(500, 60, 40);\r\n\t\t\t\t\t\t\t\t\tgeometry.scale(- 1, 1, 1);\r\n\t\t\t\t\t\t\t\t\tnew Promise(function (resolve, reject) {\r\n\t\t\t\t\t\t\t\t\t\tif (options.pictureData) {\r\n\t\t\t\t\t\t\t\t\t\t\tvar image = new Image;\r\n\t\t\t\t\t\t\t\t\t\t\timage.src = options.pictureData;\r\n\t\t\t\t\t\t\t\t\t\t\tvar texture = new THREE.Texture(image);\r\n\t\t\t\t\t\t\t\t\t\t\timage.onload = function () {\r\n\t\t\t\t\t\t\t\t\t\t\t\ttexture.needsUpdate = true;\r\n\t\t\t\t\t\t\t\t\t\t\t\tresolve(texture);\r\n\t\t\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t\t\t} else\r\n\t\t\t\t\t\t\t\t\t\t\tresolve(new THREE.TextureLoader().load(options.pictureUrl))\r\n\t\t\t\t\t\t\t\t\t}).then(function (texture) {\r\n\t\t\t\t\t\t\t\t\t\tvar material = new THREE.MeshBasicMaterial({\r\n\t\t\t\t\t\t\t\t\t\t\tmap: texture\r\n\t\t\t\t\t\t\t\t\t\t});\r\n\t\t\t\t\t\t\t\t\t\tmesh = new THREE.Mesh(geometry, material);\r\n\t\t\t\t\t\t\t\t\t\tcallback(mesh);\r\n\t\t\t\t\t\t\t\t\t})\r\n\t\t\t\t\t\t\t\t},\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t});\r\n\t\t\t\t\t\txdv.updateGadget(\"panorama\", {\r\n\t\t\t\t\t\t\t\"3d\": {\r\n\t\t\t\t\t\t\t\tvisible: true\r\n\t\t\t\t\t\t\t},\r\n\t\t\t\t\t\t});\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\txdv.updateGadget(\"panorama\", {\r\n\t\t\t\t\t\t\t\"3d\": {\r\n\t\t\t\t\t\t\t\tvisible: false\r\n\t\t\t\t\t\t\t},\r\n\t\t\t\t\t\t});\r\n\t\t\t\t\t\txdv.removeGadget(\"panorama\");\r\n\t\t\t\t\t}\r\n\t\t\t\t\tresolve();\r\n\t\t\t\t\tbreak;\r\n\r\n\t\t\t\tcase \"takeSnapshot\":\r\n\t\t\t\t\tif (threeCtx) {\r\n\t\t\t\t\t\tvar canvas = threeCtx.renderer.domElement;\r\n\t\t\t\t\t\tthreeCtx.renderer.render(threeCtx.scene, threeCtx.camera);\r\n\t\t\t\t\t\tresolve(canvas.toDataURL(\"image/\" + (options.format || \"png\"), options.quality || undefined));\r\n\t\t\t\t\t} else\r\n\t\t\t\t\t\treject(new Error(\"Snapshot only available on 3D views\"));\r\n\t\t\t\t\tbreak;\r\n\r\n\t\t\t\tcase \"getCamera\":\r\n\t\t\t\t\tif (threeCtx)\r\n\t\t\t\t\t\tresolve({\r\n\t\t\t\t\t\t\tx: threeCtx.body.position.x / SCALE3D,\r\n\t\t\t\t\t\t\ty: threeCtx.body.position.z / SCALE3D,\r\n\t\t\t\t\t\t\tz: threeCtx.body.position.y / SCALE3D,\r\n\t\t\t\t\t\t\ttargetX: threeCtx.cameraControls.camTarget.x / SCALE3D,\r\n\t\t\t\t\t\t\ttargetY: threeCtx.cameraControls.camTarget.z / SCALE3D,\r\n\t\t\t\t\t\t\ttargetZ: threeCtx.cameraControls.camTarget.y / SCALE3D\r\n\t\t\t\t\t\t});\r\n\t\t\t\t\telse\r\n\t\t\t\t\t\treject(new Error(\"Camera only available on 3D views\"));\r\n\t\t\t\t\tbreak;\r\n\r\n\t\t\t\tcase 'setCamera':\r\n\t\t\t\t\tif(!threeCtx)\r\n\t\t\t\t\t\treturn reject(new Error(\"Camera only available on 3D views\"));\r\n\r\n\t\t\t\t\tswitch(options.type) {\r\n\t\t\t\t\t\tcase \"spin\":\r\n\t\t\t\t\t\t\tresolve(SpinCamera(options));\r\n\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\tcase \"stop\":\r\n\t\t\t\t\t\t\tif(threeCtx.dolly) {\r\n\t\t\t\t\t\t\t\tdelete threeCtx.animateCallbacks[\"dolly\"];\r\n\t\t\t\t\t\t\t\tTWEEN.remove(threeCtx.dolly);\r\n\t\t\t\t\t\t\t\tdelete threeCtx.dolly;\r\n\t\t\t\t\t\t\t\tthreeCtx.animControl.stop(0);\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\tcase \"move\":\r\n\t\t\t\t\t\tdefault:\r\n\t\t\t\t\t\t\tresolve(MoveCamera(options));\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tbreak;\r\n\r\n\r\n\t\t\t\tdefault:\r\n\t\t\t\t\treject(new Error(\"ViewControl: unsupported command \" + cmd));\r\n\t\t\t}\r\n\t\t});\r\n\t\treturn promise;\r\n\t}\r\n\r\n\tfunction SpinCamera(options) {\r\n\t\tfunction GetKalman() {\r\n\t\t\tvar R = .001;\r\n\t\t\tif(typeof options.smooth!=\"undefined\")\r\n\t\t\t\tR = options.smooth;\r\n\t\t\treturn new KalmanFilter({R: R});\r\n\t\t}\r\n\t\tvar kalman = {\r\n\t\t\tx: GetKalman(),\r\n\t\t\ty: GetKalman(),\r\n\t\t}\r\n\t\tvar x0 = threeCtx.cameraControls.camTarget.x;\r\n\t\tvar y0 = threeCtx.cameraControls.camTarget.z;\r\n\t\tvar x1 = threeCtx.body.position.x;\r\n\t\tvar y1 = threeCtx.body.position.z;\r\n\t\tvar angle0 = Math.atan2(y1-y0,x1-x0);\r\n\t\tvar angle1 = angle0 - 2 * Math.PI;\r\n\t\tif(options.direction==\"ccw\")\r\n\t\t\tangle1 = angle0 + 2 * Math.PI;\r\n\t\tvar radius = Math.sqrt((x1-x0)*(x1-x0)+(y1-y0)*(y1-y0));\r\n\t\tif(threeCtx.dolly)\r\n\t\t\tTWEEN.remove(threeCtx.dolly);\r\n\t\tvar state = {};\r\n\t\tfunction StartSpinning() {\r\n\t\t\tstate.angle = angle0;\r\n\t\t\tthreeCtx.dolly = new TWEEN.Tween(state).to({ angle: angle1 }, (options.speed || 30) * 1000)\r\n\t\t\t\t\t.onComplete( function() {\r\n\t\t\t\t\t\tStartSpinning();\r\n\t\t\t\t\t})\r\n\t\t\t\t\t.onUpdate( function() {\r\n\t\t\t\t\t\tthreeCtx.animControl.trigger();\r\n\t\t\t\t\t}).start();\r\n\t\t}\r\n\t\tthreeCtx.animateCallbacks[\"dolly\"] = {\r\n\t\t\t_this: null,\r\n\t\t\tcallback: function() {\r\n\t\t\t\tthreeCtx.body.position.x = kalman.x.filter(x0 + radius * Math.cos(state.angle));\r\n\t\t\t\tthreeCtx.body.position.z = kalman.y.filter(y0 + radius * Math.sin(state.angle));\r\n\t\t\t}\r\n\t\t};\r\n\t\tStartSpinning();\r\n\t\tthreeCtx.animControl.trigger();\r\n\r\n\t}\r\n\r\n\tfunction MoveCamera(options) {\r\n\t\tfunction GetKalman() {\r\n\t\t\tvar R = .001;\r\n\t\t\tif(typeof options.smooth!=\"undefined\")\r\n\t\t\t\tR = options.smooth;\r\n\t\t\treturn new KalmanFilter({R: R});\r\n\t\t}\r\n\t\tvar kalman = {\r\n\t\t\tx: GetKalman(),\r\n\t\t\ty: GetKalman(),\r\n\t\t\tz: GetKalman(),\r\n\t\t\ttargetX: GetKalman(),\r\n\t\t\ttargetY: GetKalman(),\r\n\t\t\ttargetZ: GetKalman()\r\n\t\t}\r\n\t\tvar state = {\r\n\t\t\tx: threeCtx.body.position.x,\r\n\t\t\ty: threeCtx.body.position.y,\r\n\t\t\tz: threeCtx.body.position.z,\r\n\t\t\ttargetX: threeCtx.cameraControls.camTarget.x,\r\n\t\t\ttargetY: threeCtx.cameraControls.camTarget.y,\r\n\t\t\ttargetZ: threeCtx.cameraControls.camTarget.z\r\n\t\t}\r\n\t\tvar state1 = {\r\n\t\t\tx: options.camera.x * SCALE3D,\r\n\t\t\tz: options.camera.y * SCALE3D,\r\n\t\t\ty: options.camera.z * SCALE3D,\r\n\t\t\ttargetX: options.camera.targetX * SCALE3D,\r\n\t\t\ttargetZ: options.camera.targetY * SCALE3D,\r\n\t\t\ttargetY: options.camera.targetZ * SCALE3D\r\n\t\t}\r\n\t\tvar finalCamera = new THREE.Vector3(state1.x, state1.y, state1.z);\r\n\t\tvar finalTarget = new THREE.Vector3(state1.targetX, state1.targetY, state1.targetZ);\r\n\t\tif(threeCtx.dolly)\r\n\t\t\tTWEEN.remove(threeCtx.dolly);\r\n\t\tthreeCtx.dolly = new TWEEN.Tween(state).to(state1, options.speed * 1000)\r\n\t\t\t\t.onUpdate( function() {\r\n\t\t\t\t\tthreeCtx.animControl.trigger();\r\n\t\t\t\t}).start();\r\n\t\tthreeCtx.animateCallbacks[\"dolly\"] = {\r\n\t\t\t_this: null,\r\n\t\t\tcallback: function() {\r\n\t\t\t\tthreeCtx.body.position.x = kalman.x.filter(state.x);\r\n\t\t\t\tthreeCtx.body.position.y = kalman.y.filter(state.y);\r\n\t\t\t\tthreeCtx.body.position.z = kalman.z.filter(state.z);\r\n\t\t\t\tthreeCtx.cameraControls.camTarget.x = kalman.targetX.filter(state.targetX);\r\n\t\t\t\tthreeCtx.cameraControls.camTarget.y = kalman.targetY.filter(state.targetY);\r\n\t\t\t\tthreeCtx.cameraControls.camTarget.z = kalman.targetZ.filter(state.targetZ);\r\n\t\t\t\tvar cameraVec = new THREE.Vector3(\r\n\t\t\t\t\tthreeCtx.body.position.x,\r\n\t\t\t\t\tthreeCtx.body.position.y,\r\n\t\t\t\t\tthreeCtx.body.position.z);\r\n\t\t\t\tif(cameraVec.distanceTo(finalCamera)<.1) {\r\n\t\t\t\t\tvar targetVec = new THREE.Vector3(\r\n\t\t\t\t\t\tthreeCtx.cameraControls.camTarget.x,\r\n\t\t\t\t\t\tthreeCtx.cameraControls.camTarget.y,\r\n\t\t\t\t\t\tthreeCtx.cameraControls.camTarget.z);\r\n\t\t\t\t\tif(targetVec.distanceTo(finalTarget)<.1) {\r\n\t\t\t\t\t\tdelete threeCtx.animateCallbacks[\"dolly\"];\r\n\t\t\t\t\t\tTWEEN.remove(threeCtx.dolly);\r\n\t\t\t\t\t\tdelete threeCtx.dolly;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t\tthreeCtx.animControl.trigger();\r\n\t}\r\n\r\n\tView.Board.Display = function (aGame) {\r\n\t\t//Log(\"### View.Board.Display\");\r\n\t\tthis.xdDisplay(xdv, aGame);\r\n\t\t//xdv.listScene();\r\n\t}\r\n\r\n\tView.Board.xdInput = function (xdv, aGame) {\r\n\t\tconsole.error(\"View.Board.xdInput must be overriden\");\r\n\t\treturn {\r\n\t\t\tinitial: {},\r\n\t\t\tgetActions: function (moves, currentInput) {\r\n\t\t\t\treturn {};\r\n\t\t\t},\r\n\t\t}\r\n\t}\r\n\r\n\tView.Board.xdBuildHTStateMachine = function (xdv, htsm, aGame) {\r\n\t\tvar $this = this;\r\n\t\tvar inputSpec;\r\n\t\tvar clickGadgets = {}, viewGadgets = {}, highlightGadgets = [];\r\n\t\tvar inputStack, movesStack, actionStack;\r\n\t\tfunction Click(action, mode) {\r\n\t\t\tif (mode == \"select\")\r\n\t\t\t\thtsm.smQueueEvent(\"E_ACTION\", { action: action });\r\n\t\t\telse if (mode == \"cancel\")\r\n\t\t\t\thtsm.smQueueEvent(\"E_CANCEL\", { action: action });\r\n\t\t}\r\n\t\tfunction Init(args) {\r\n\t\t\tinputSpec = $this.xdInput(xdv, aGame);\r\n\t\t\tinputStack = [inputSpec.initial];\r\n\t\t\t// ensures moves are not duplicated\r\n\t\t\tvar movesMap = {};\r\n\t\t\t$this.mMoves.forEach(function (move) {\r\n\t\t\t\tmovesMap[JSON.stringify(move)] = move;\r\n\t\t\t});\r\n\t\t\tvar moves = [];\r\n\t\t\tfor (var m in movesMap)\r\n\t\t\t\tmoves.push(movesMap[m]);\r\n\t\t\tmovesStack = [moves];\r\n\t\t\tactionStack = [];\r\n\t\t}\r\n\t\tfunction ShowFurnitures(args) {\r\n\t\t\tif (inputSpec.furnitures)\r\n\t\t\t\tinputSpec.furnitures.forEach(function (gadget) {\r\n\t\t\t\t\txdv.updateGadget(gadget, {\r\n\t\t\t\t\t\tbase: {\r\n\t\t\t\t\t\t\tvisible: true,\r\n\t\t\t\t\t\t},\r\n\t\t\t\t\t});\r\n\t\t\t\t});\r\n\t\t}\r\n\t\tfunction HideFurnitures(args) {\r\n\t\t\tif (inputSpec.furnitures)\r\n\t\t\t\tinputSpec.furnitures.forEach(function (gadget) {\r\n\t\t\t\t\txdv.updateGadget(gadget, {\r\n\t\t\t\t\t\tbase: {\r\n\t\t\t\t\t\t\tvisible: false,\r\n\t\t\t\t\t\t},\r\n\t\t\t\t\t});\r\n\t\t\t\t});\r\n\t\t}\r\n\t\tfunction SetAction(action, mode) {\r\n\t\t\tif (mode == \"select\") {\r\n\t\t\t\tif (action.pre)\r\n\t\t\t\t\taction.pre.call($this);\r\n\t\t\t\tif (action.cancel)\r\n\t\t\t\t\taction.cancel.forEach(function (gid) {\r\n\t\t\t\t\t\tclickGadgets[gid] = true;\r\n\t\t\t\t\t\txdv.updateGadget(gid, {\r\n\t\t\t\t\t\t\tbase: {\r\n\t\t\t\t\t\t\t\tclick: function () {\r\n\t\t\t\t\t\t\t\t\tClick(action, \"cancel\");\r\n\t\t\t\t\t\t\t\t},\r\n\t\t\t\t\t\t\t},\r\n\t\t\t\t\t\t});\r\n\t\t\t\t\t});\r\n\t\t\t}\r\n\t\t\tif (action.click)\r\n\t\t\t\taction.click.forEach(function (gid) {\r\n\t\t\t\t\tclickGadgets[gid] = true;\r\n\t\t\t\t\txdv.updateGadget(gid, {\r\n\t\t\t\t\t\tbase: {\r\n\t\t\t\t\t\t\tclick: function () {\r\n\t\t\t\t\t\t\t\tClick(action, mode);\r\n\t\t\t\t\t\t\t},\r\n\t\t\t\t\t\t},\r\n\t\t\t\t\t});\r\n\t\t\t\t});\r\n\t\t\tif (typeof action.highlight == \"function\") {\r\n\t\t\t\tif (typeof action.unhighlight != \"function\")\r\n\t\t\t\t\tconsole.warn(\"No unhighlight function defined for\", action);\r\n\t\t\t\telse\r\n\t\t\t\t\thighlightGadgets.push(function () {\r\n\t\t\t\t\t\taction.unhighlight.call($this, mode);\r\n\t\t\t\t\t});\r\n\t\t\t\taction.highlight.call($this, mode);\r\n\t\t\t}\r\n\t\t\tif (action.view)\r\n\t\t\t\taction.view.forEach(function (gid) {\r\n\t\t\t\t\tviewGadgets[gid] = true;\r\n\t\t\t\t\txdv.updateGadget(gid, {\r\n\t\t\t\t\t\tbase: {\r\n\t\t\t\t\t\t\tvisible: true,\r\n\t\t\t\t\t\t},\r\n\t\t\t\t\t})\r\n\t\t\t\t});\r\n\t\t}\r\n\t\tfunction PrepareAction(args) {\r\n\t\t\tvar nextActions = inputSpec.getActions.call($this, movesStack[movesStack.length - 1], inputStack[inputStack.length - 1]);\r\n\t\t\tif (nextActions == null) {\r\n\t\t\t\thtsm.smQueueEvent(\"E_MOVE_DONE\", { move: movesStack[movesStack.length - 1][0] });\r\n\t\t\t\treturn;\r\n\t\t\t}\r\n\t\t\tvar actionsCount = 0;\r\n\t\t\tvar action0;\r\n\t\t\tfor (var action in nextActions) {\r\n\t\t\t\taction0 = nextActions[action];\r\n\t\t\t\tactionsCount++;\r\n\t\t\t}\r\n\t\t\tif (actionsCount > 1 || (inputStack.length == 1 && !inputSpec.allowForced) || (actionsCount == 1 && !aGame.mAutoComplete && !action0.skipable)) {\r\n\t\t\t\tfor (var actId in nextActions) {\r\n\t\t\t\t\tvar action = nextActions[actId];\r\n\t\t\t\t\taction.forced = false;\r\n\t\t\t\t\tSetAction(action, \"select\");\r\n\t\t\t\t}\r\n\t\t\t} else if (actionsCount == 0) {\r\n\t\t\t\thtsm.smQueueEvent(\"E_MOVE_DONE\", { move: actionStack[actionStack.length - 1].moves[0] });\r\n\t\t\t} else {\r\n\t\t\t\taction0.forced = true;\r\n\t\t\t\thtsm.smQueueEvent(\"E_ACTION\", { action: action0 });\r\n\t\t\t}\r\n\t\t}\r\n\t\tfunction SendMove(args) {\r\n\t\t\taGame.HumanMove(args.move);\r\n\t\t}\r\n\t\tfunction Clean(args) {\r\n\t\t\tfor (var gid in clickGadgets)\r\n\t\t\t\txdv.updateGadget(gid, {\r\n\t\t\t\t\tbase: {\r\n\t\t\t\t\t\tclick: null,\r\n\t\t\t\t\t},\r\n\t\t\t\t});\r\n\t\t\tclickGadgets = {};\r\n\t\t\tfor (var gid in viewGadgets)\r\n\t\t\t\txdv.updateGadget(gid, {\r\n\t\t\t\t\tbase: {\r\n\t\t\t\t\t\tvisible: false,\r\n\t\t\t\t\t},\r\n\t\t\t\t});\r\n\t\t\tviewGadgets = {};\r\n\t\t\tfor (var i = 0; i < highlightGadgets.length; i++)\r\n\t\t\t\thighlightGadgets[i].call($this);\r\n\t\t}\r\n\t\tfunction Execute(action, callback) {\r\n\t\t\tif (action.execute) {\r\n\t\t\t\tvar actions = action.execute;\r\n\t\t\t\tif (typeof actions == \"function\")\r\n\t\t\t\t\tactions = [actions];\r\n\t\t\t\tvar actionsCount = 0;\r\n\t\t\t\tfunction ActionDone(action) {\r\n\t\t\t\t\tif (--actionsCount == 0)\r\n\t\t\t\t\t\tcallback();\r\n\t\t\t\t}\r\n\t\t\t\tactions.forEach(function (action) {\r\n\t\t\t\t\tactionsCount++;\r\n\t\t\t\t\tsetTimeout(function () {\r\n\t\t\t\t\t\taction.call($this, ActionDone);\r\n\t\t\t\t\t}, 0);\r\n\t\t\t\t});\r\n\t\t\t} else\r\n\t\t\t\tcallback();\r\n\t\t}\r\n\t\tfunction Action(args) {\r\n\t\t\tmovesStack.push(args.action.moves);\r\n\t\t\tExecute(args.action, function () {\r\n\t\t\t\thtsm.smQueueEvent(\"E_DONE\", { action: args.action });\r\n\t\t\t});\r\n\t\t}\r\n\t\tfunction PostAction(args) {\r\n\t\t\tif (args.action.post)\r\n\t\t\t\targs.action.post.call($this);\r\n\t\t}\r\n\t\tfunction SetCancel(args) {\r\n\t\t\tif (actionStack.length > 0 && !actionStack[actionStack.length - 1].noAutoCancel)\r\n\t\t\t\tSetAction(actionStack[actionStack.length - 1], \"cancel\");\r\n\t\t}\r\n\t\tfunction Validate(args) {\r\n\t\t\tinputStack.push($.extend(true, {}, inputStack[inputStack.length - 1], args.action.validate));\r\n\t\t}\r\n\t\tfunction Cancel(args) {\r\n\t\t\twhile (actionStack.length > 0) {\r\n\t\t\t\tvar action = actionStack.pop();\r\n\t\t\t\tinputStack.pop();\r\n\t\t\t\tmovesStack.pop();\r\n\t\t\t\tif (action.unexecute)\r\n\t\t\t\t\taction.unexecute.call($this);\r\n\t\t\t\tif (action.post)\r\n\t\t\t\t\taction.post.call($this);\r\n\t\t\t\tif (action.forced == false)\r\n\t\t\t\t\tbreak;\r\n\t\t\t}\r\n\t\t}\r\n\t\tfunction PushAction(args) {\r\n\t\t\tactionStack.push(args.action);\r\n\t\t}\r\n\t\thtsm.smTransition(\"S_INIT\", \"E_INIT\", \"S_WAIT_ACTION\", [Init, ShowFurnitures]);\r\n\t\thtsm.smEntering(\"S_WAIT_ACTION\", [PrepareAction, SetCancel]);\r\n\t\thtsm.smLeaving(\"S_WAIT_ACTION\", [Clean]);\r\n\t\thtsm.smTransition(\"S_WAIT_ACTION\", \"E_ACTION\", \"S_ACTION\", [PushAction, Validate, Action]);\r\n\t\thtsm.smTransition(\"S_WAIT_ACTION\", \"E_CANCEL\", null, [Cancel, Clean, PrepareAction, SetCancel]);\r\n\t\thtsm.smTransition(\"S_WAIT_ACTION\", \"E_MOVE_DONE\", \"S_DONE\", [SendMove, HideFurnitures]);\r\n\t\thtsm.smTransition([\"S_WAIT_ACTION\", \"S_ACTION\"], \"E_END\", \"S_DONE\", []);\r\n\t\thtsm.smTransition(\"S_ACTION\", \"E_DONE\", \"S_WAIT_ACTION\", [PostAction]);\r\n\t\thtsm.smTransition(\"S_DONE\", \"E_END\", null, [HideFurnitures]);\r\n\t}\r\n\r\n\tView.Board.HumanTurn = function (aGame) {\r\n\t\t//Log(\"### View.Board.HumanTurn\");\r\n\t\tvar $this = this;\r\n\t\thtStateMachine = new HTStateMachine();\r\n\t\thtStateMachine.init();\r\n\t\tthis.xdBuildHTStateMachine(xdv, htStateMachine, aGame);\r\n\t\thtStateMachine.smSetInitialState(\"S_INIT\");\r\n\t\thtStateMachine.smQueueEvent(\"E_INIT\", {});\r\n\t\thtStateMachine.smPlay();\r\n\t}\r\n\r\n\tView.Board.HumanTurnEnd = function (aGame) {\r\n\t\t//Log(\"### View.Board.HumanTurnEnd\");\r\n\t\tif (htStateMachine) {\r\n\t\t\thtStateMachine.smQueueEvent(\"E_END\", {});\r\n\t\t\thtStateMachine = null;\r\n\t\t}\r\n\t}\r\n\r\n\tView.Board.PlayedMove = function (aGame, aMove) {\r\n\t\t//Log(\"### View.Board.PlayedMove\");\r\n\t\treturn this.xdPlayedMove(xdv, aGame, aMove);\r\n\t}\r\n\r\n\tView.Board.xdShowEnd = function (xdv, aGame) {\r\n\t\treturn true;\r\n\t}\r\n\r\n\tView.Board.ShowEnd = function (aGame) {\r\n\t\treturn this.xdShowEnd(xdv, aGame);\r\n\t}\r\n\r\n\t/* ======================================== */\r\n\r\n\tvar THREEx_boundContext = \"\" + Math.random();\r\n\r\n\tfunction BuildThree(aGame, areaWidth, areaHeight) {\r\n\r\n\t\tvar camera = new THREE.PerspectiveCamera(55, (area.width() / area.height()), 1, 4000);\r\n\r\n\t\tvar scene = new THREE.Scene();\r\n\r\n\t\tvar body = new THREE.Object3D();\r\n\t\tscene.add(body);\r\n\t\tbody.add(camera);\r\n\r\n\t\tvar harbor = new THREE.Object3D();\r\n\t\tscene.add(harbor);\r\n\r\n\t\tvar ambientLight = new THREE.AmbientLight(0xbbbbbb);\r\n\t\tharbor.add(ambientLight);\r\n\r\n\t\tvar light = new THREE.SpotLight(0xffffff, 1.75, 0, 1.05, 1, 2);  // test params here https://threejs.org/docs/?q=SpotLight#Reference/Lights/SpotLight\r\n\t\tlight.position.set(-12, 12, 12);\r\n\r\n\t\tlight.castShadow = true;\r\n\t\t//light.shadowDarkness = .75;\r\n\r\n\t\tlight.shadow.camera.near = 1;\r\n\t\tlight.shadow.camera.far = 27;\r\n\t\tlight.shadow.camera.fov = 90;\r\n\r\n\t\tlight.shadow.mapSize.width = 4096;\r\n\t\tlight.shadow.mapSize.height = 4096;\r\n\r\n\t\tlight.target = harbor;\r\n\r\n\t\tharbor.add(light);\r\n\r\n\t\tvar skylight = new THREE.PointLight(0xcccccc, 2, 150);//, Math.PI/5, 10);\r\n\t\tskylight.position.set(-45, 45, 45);\r\n\t\tharbor.add(skylight);\r\n\r\n\t\t//light.shadowCameraVisible = false;\r\n\t\t// skylight.shadowCameraVisible = true; nonsens! PointLight objects don't have shadow feature\r\n\r\n\t\tvar renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });\r\n\t\trenderer.setSize(area.width(), area.height());\r\n\t\t//renderer.setClearColor( scene.fog.color, 1 );\r\n\r\n\t\tvar projector = new THREE.Projector();\r\n\r\n\t\tarea.append($(renderer.domElement));\r\n\r\n\t\trenderer.gammaInput = true;\r\n\t\trenderer.gammaOutput = true;\r\n\t\t//renderer.shadowMapEnabled = true;\r\n\t\trenderer.shadowMap.enabled = true;\r\n\t\trenderer.shadowMapSoft = true;\r\n\t\t//renderer.physicallyBasedShading = true; // gives high level of shininess specular\r\n\t\t//renderer.shadowMapCascade = true;\r\n\r\n\t\tvar stereo = false;\r\n\t\tvar stereoEffect = new THREE.StereoEffect(renderer);\r\n\t\tstereoEffect.setSize(area.width(), area.height());\r\n\r\n\t\tvar anaglyphEffect = new THREE.AnaglyphEffect(renderer);\r\n\t\tanaglyphEffect.setSize(area.width(), area.height());\r\n\r\n\t\tvar gamepads = new VRGamepads({\r\n\t\t\tcamera: camera,\r\n\t\t\tscene: scene,\r\n\t\t\tresBase: aGame.config.baseURL + \"res/vr/\",\r\n\t\t\tdrag: function (position, direction, pointerObject, pointerRescale) {\r\n\t\t\t\tvar intersectPoint = null;\r\n\t\t\t\tvar pointedObject = null;\r\n\t\t\t\tVRGetIntersect(position, direction, function (object, point) {\r\n\t\t\t\t\tintersectPoint = point;\r\n\t\t\t\t\tpointedObject = object;\r\n\t\t\t\t});\r\n\t\t\t\treturn intersectPoint ? {\r\n\t\t\t\t\tpoint: intersectPoint,\r\n\t\t\t\t\tobject: pointedObject\r\n\t\t\t\t} : null;\r\n\t\t\t},\r\n\t\t\tclick: function (position, direction) {\r\n\t\t\t\tVRGetIntersect(position, direction, function (object, point) {\r\n\t\t\t\t\tif (object)\r\n\t\t\t\t\t\tTHREE.Object3D._threexDomEvent._notify(\"mouseup\", object, null, point);\r\n\t\t\t\t});\r\n\t\t\t},\r\n\t\t\tmove: function (step) {\r\n\t\t\t\tbody.position.add(step);\r\n\t\t\t}\r\n\t\t});\r\n\r\n\t\tvar vrRay = new THREE.Raycaster();\r\n\r\n\t\tvar camAnim = !!aGame.mViewOptions.camAnim;\r\n\r\n\t\tvar animateCallbacks = {};\r\n\r\n\t\tvar frameBacklog = 0;\r\n\r\n\t\tfunction AnimControl() {\r\n\t\t\tthis.animating = false;\r\n\t\t\tthis.animateTimer = null;\r\n\t\t\tthis.nextStop = 0;\r\n\t\t}\r\n\t\tAnimControl.prototype = {\r\n\t\t\tstart: function () {\r\n\t\t\t\tbody.updateMatrixWorld();\r\n\t\t\t\tif (this.animateTimer != null) {\r\n\t\t\t\t\tclearTimeout(this.animateTimer);\r\n\t\t\t\t\tthis.animateTimer = null;\r\n\t\t\t\t}\r\n\t\t\t\tif (this.animating == false) {\r\n\t\t\t\t\tthis.animating = true;\r\n\t\t\t\t\tthis.animate();\r\n\t\t\t\t}\r\n\t\t\t},\r\n\t\t\tstop: function (delay) {\r\n\t\t\t\tif (threeCtx && vr.vrEffect && vr.vrEffect.isPresenting) {\r\n\t\t\t\t\tif (this.animateTimer != null) {\r\n\t\t\t\t\t\tclearTimeout(this.animateTimer);\r\n\t\t\t\t\t\tthis.animateTimer = null;\r\n\t\t\t\t\t}\r\n\t\t\t\t\treturn;\r\n\t\t\t\t}\r\n\t\t\t\tif (delay === undefined)\r\n\t\t\t\t\tdelay = 200;\r\n\t\t\t\tvar now = Date.now();\r\n\t\t\t\tvar $this = this;\r\n\t\t\t\tif (this.animating) {\r\n\t\t\t\t\tif (this.animateTimer != null) {\r\n\t\t\t\t\t\tif (this.nextStop < now + delay)\r\n\t\t\t\t\t\t\tclearTimeout(this.animateTimer);\r\n\t\t\t\t\t\telse\r\n\t\t\t\t\t\t\treturn;\r\n\t\t\t\t\t}\r\n\t\t\t\t\tthis.nextStop = Math.max(this.nextStop, now + delay);\r\n\t\t\t\t\tthis.animateTimer = setTimeout(function () {\r\n\t\t\t\t\t\t$this.animateTimer = null;\r\n\t\t\t\t\t\t$this.animating = false;\r\n\t\t\t\t\t}, this.nextStop - now);\r\n\t\t\t\t}\r\n\t\t\t},\r\n\t\t\ttrigger: function () {\r\n\t\t\t\tif (!this.animating || this.animateTimer != null) {\r\n\t\t\t\t\tthis.start();\r\n\t\t\t\t\tthis.stop.apply(this, arguments);\r\n\t\t\t\t}\r\n\t\t\t},\r\n\t\t\tanimate: function () {\r\n\t\t\t\tvar $this = this;\r\n\t\t\t\tvar statsCurrentSec = 0;\r\n\t\t\t\tvar statsTic = 0;\r\n\t\t\t\tvar renderSum = 0;\r\n\t\t\t\tvar renderCount = 0;\r\n\r\n\t\t\t\tfunction Animate(timestamp) {\r\n\t\t\t\t\tframeBacklog--;\r\n\t\t\t\t\tvar t0, t1;\r\n\t\t\t\t\tvar showStats = false;\r\n\t\t\t\t\tif (showStats) {\r\n\t\t\t\t\t\tvar sec = Math.floor(Date.now() / 1000);\r\n\t\t\t\t\t\tif (sec == statsCurrentSec)\r\n\t\t\t\t\t\t\tstatsTic++;\r\n\t\t\t\t\t\telse {\r\n\t\t\t\t\t\t\tif (statsTic > 0) {\r\n\t\t\t\t\t\t\t\tvar rate = Math.round(1000 * renderSum / renderCount) / 1000;\r\n\t\t\t\t\t\t\t\tvar lag = Math.round(1000 * (window.performance.now() - timestamp)) / 1000;\r\n\t\t\t\t\t\t\t\t/*\r\n\t\t\t\t\t\t\t\tconsole.log(\"fps\",statsTic,\"render\",rate,\"ms\",\"\",\r\n\t\t\t\t\t\t\t\t\t\t\"lag\",lag,\"ms\",\"\",\r\n\t\t\t\t\t\t\t\t\t\t\"frame backlog\",frameBacklog);\r\n\t\t\t\t\t\t\t\t*/\r\n\t\t\t\t\t\t\t\t$(statsPanel).text(\"fps \" + statsTic);\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\tstatsTic = 1;\r\n\t\t\t\t\t\t\tstatsCurrentSec = sec;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t\tif ($this.animating) {\r\n\t\t\t\t\t\tframeBacklog++;\r\n\t\t\t\t\t\trequestAnimationFrame(Animate);\r\n\t\t\t\t\t}\r\n\t\t\t\t\tTWEEN.update();\r\n\t\t\t\t\tif (showStats)\r\n\t\t\t\t\t\tt0 = Date.now();\r\n\t\t\t\t\tif (vr.vrEffect && vr.vrEffect.isPresenting) {\r\n\t\t\t\t\t\tgamepads.update();\r\n\t\t\t\t\t\tvar harborpad = gamepads.getHarborPad();\r\n\t\t\t\t\t\tif (harborpad) {\r\n\t\t\t\t\t\t\tharborpad.visible = false;\r\n\t\t\t\t\t\t\tharborpad.getWorldPosition(ctx.harbor.position);\r\n\t\t\t\t\t\t\tvar scale = (harborpad.getAxes()[1] + 1.1) * .03;\r\n\t\t\t\t\t\t\tctx.harbor.scale.set(scale, scale, scale);\r\n\t\t\t\t\t\t\tharborpad.getWorldQuaternion(ctx.harbor.quaternion);\r\n\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\tctx.harbor.position.set(0, 0, 0);\r\n\t\t\t\t\t\t\tctx.harbor.scale.set(1, 1, 1);\r\n\t\t\t\t\t\t\tctx.harbor.quaternion.copy(ctx.defaultHarborQuaternion);\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\tvr.vrControls.update();\r\n\t\t\t\t\t\tvr.vrEffect.render(scene, camera);\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\tif (!arStream) {\r\n\t\t\t\t\t\t\tctx.harbor.position.set(0, 0, 0);\r\n\t\t\t\t\t\t\tctx.harbor.scale.set(1, 1, 1);\r\n\t\t\t\t\t\t\tctx.harbor.quaternion.copy(ctx.defaultHarborQuaternion);\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\t/*\r\n\t\t\t\t\t\tif(gamepads)\r\n\t\t\t\t\t\t\tgamepads.clearAll();\r\n\t\t\t\t\t\t*/\r\n\t\t\t\t\t\tif (!arStream) {\r\n\t\t\t\t\t\t\tcameraControls.update();\r\n\t\t\t\t\t\t\tcameraOrientationControls.update();\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\tif (stereo) {\r\n\t\t\t\t\t\t\tgamepads.update();\r\n\t\t\t\t\t\t\tstereoEffect.render(scene, camera);\r\n\t\t\t\t\t\t} else if (ctx.anaglyph || aGame.mAnaglyph)\r\n\t\t\t\t\t\t\tanaglyphEffect.render(scene, camera);\r\n\t\t\t\t\t\telse\r\n\t\t\t\t\t\t\trenderer.render(scene, camera);\r\n\t\t\t\t\t}\r\n\t\t\t\t\tif (showStats) {\r\n\t\t\t\t\t\tt1 = Date.now();\r\n\t\t\t\t\t\trenderSum += t1 - t0;\r\n\t\t\t\t\t\trenderCount++;\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tfor (var cbi in animateCallbacks) {\r\n\t\t\t\t\t\tvar cb = animateCallbacks[cbi];\r\n\t\t\t\t\t\tcb.callback.call(cb._this);\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\tframeBacklog++;\r\n\t\t\t\tAnimate(window.performance.now());\r\n\t\t\t},\r\n\t\t}\r\n\t\tvar animControl = new AnimControl();\r\n\r\n\t\tvar statsPanel = null;\r\n\r\n\t\tvar cameraControls = new THREE.OrbitControls(camera, body, renderer.domElement);\r\n\r\n\t\t$.extend(cameraControls, {\r\n\t\t\tautoRotate: camAnim,\r\n\t\t\tanimControl: animControl,\r\n\t\t});\r\n\t\tcameraControls.camTarget.set(0, 0.8, 0);\r\n\r\n\t\tvar canOrientation = false;\r\n\t\tvar cameraOrientationControls = new THREE.DeviceOrientationControls(body, function (controls) {\r\n\t\t\tif (typeof vr != \"undefined\")\r\n\t\t\t\tanimControl.trigger();\r\n\t\t\tif (!canOrientation && controls.enabled) {\r\n\t\t\t\tcanOrientation = true;\r\n\t\t\t\tarea.find(\".vr-button\").show();\r\n\t\t\t}\r\n\t\t});\r\n\r\n\r\n\t\tif (typeof cameraControls.addEventListener == \"function\")\r\n\t\t\tcameraControls.addEventListener('change', function () {\r\n\t\t\t\tanimControl.trigger();\r\n\t\t\t});\r\n\r\n\t\tvar ctx = {\r\n\t\t\tscene: scene,\r\n\t\t\trenderer: renderer,\r\n\t\t\tlight: light,\r\n\t\t\tskyLight: skylight,\r\n\t\t\tambientLight: ambientLight,\r\n\t\t\tloader: new THREE.JSONLoader(),\r\n\t\t\tcamera: camera,\r\n\t\t\tcameraControls: cameraControls,\r\n\t\t\tanimateCallbacks: animateCallbacks,\r\n\t\t\tcamTarget: cameraControls.camTarget,\r\n\t\t\tanimControl: animControl,\r\n\t\t\tbody: body,\r\n\t\t\tharbor: harbor,\r\n\t\t\tdefaultHarborQuaternion: harbor.quaternion.clone(),\r\n\t\t\tanaglyphEffect: anaglyphEffect,\r\n\t\t\tanaglyph: false\r\n\t\t};\r\n\r\n\t\tfunction VRGetIntersect(position, direction, callback) {\r\n\t\t\tvar threexDomEvent = THREE.Object3D._threexDomEvent;\r\n\t\t\tvrRay.set(position, direction);\r\n\t\t\ttry {\r\n\t\t\t\tvar intersects = vrRay.intersectObjects(threexDomEvent._boundObjs[threexDomEvent._boundContext]);\r\n\t\t\t} catch (e) {\r\n\t\t\t\treturn callback(null, null);\r\n\t\t\t}\r\n\t\t\tif (intersects.length == 0)\r\n\t\t\t\treturn callback(null, null);\r\n\t\t\tvar intersect = intersects[0];\r\n\t\t\tvar object3d = threexDomEvent.getRootObject(intersect.object);\r\n\t\t\tvar objectCtx = threexDomEvent._objectCtxGet(object3d);\r\n\t\t\tif (!objectCtx)\r\n\t\t\t\tcallback(null, null);\r\n\t\t\telse\r\n\t\t\t\tcallback(object3d, intersect.point);\r\n\t\t}\r\n\r\n\t\tfunction VRSetup(ctx) {\r\n\r\n\t\t\tfunction LookAtHarbor() {\r\n\t\t\t\tvr.vrControls.resetPose();\r\n\t\t\t}\r\n\r\n\t\t\tfunction MakeButton() {\r\n\t\t\t\tctx.vrButton = document.getElementById(\"vr-button\");\r\n\t\t\t\tif(ctx.vrButton) return;\r\n\r\n\t\t\t\tctx.vrButton = document.createElement(\"img\");\r\n\t\t\t\tctx.vrButton.className = \"vr-button\";\r\n\t\t\t\tctx.vrButton.setAttribute(\"data-vr-enter-src\", aGame.config.baseURL + \"res/vr/vr-enter.png\");\r\n\t\t\t\tctx.vrButton.setAttribute(\"data-vr-exit-src\", aGame.config.baseURL + \"res/vr/vr-exit.png\");\r\n\t\t\t\tctx.vrButton.setAttribute(\"src\", ctx.vrButton.getAttribute(\"data-vr-enter-src\"));\r\n\t\t\t\tObject.assign(ctx.vrButton.style, {\r\n\t\t\t\t\tposition: \"absolute\",\r\n\t\t\t\t\tbottom: \"8px\",\r\n\t\t\t\t\tright: \"8px\",\r\n\t\t\t\t\tcursor: \"pointer\",\r\n\t\t\t\t\t\"z-index\": 2147483647\r\n\t\t\t\t});\r\n\t\t\t\tarea[0].appendChild(ctx.vrButton);\r\n\t\t\t}\r\n\r\n\t\t\tfunction CardboardVR() {\r\n\t\t\t\tMakeButton();\r\n\t\t\t\tctx.vrButton.style.display = \"none\";\r\n\t\t\t\tctx.vrButton.addEventListener(\"click\", function () {\r\n\t\t\t\t\tif (stereo) {\r\n\t\t\t\t\t\tstereo = false;\r\n\t\t\t\t\t\tctx.vrButton.setAttribute(\"src\", ctx.vrButton.getAttribute(\"data-vr-enter-src\"));\r\n\t\t\t\t\t\tvar size = renderer.getSize();\r\n\t\t\t\t\t\trenderer.setViewport(0, 0, size.width, size.height);\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\tstereo = true;\r\n\t\t\t\t\t\tctx.vrButton.setAttribute(\"src\", ctx.vrButton.getAttribute(\"data-vr-exit-src\"));\r\n\t\t\t\t\t}\r\n\t\t\t\t\tanimControl.trigger();\r\n\t\t\t\t});\r\n\t\t\t}\r\n\r\n\t\t\tfunction PureVR() {\r\n\t\t\t\tMakeButton();\r\n\t\t\t\tvar vrControls = new THREE.VRControls(ctx.camera);\r\n\t\t\t\tvr.vrControls = vrControls;\r\n\t\t\t\tif (window.lastVrEffect) {\r\n\t\t\t\t\tif (window.lastVrEffect.isPresenting)\r\n\t\t\t\t\t\twindow.lastVrEffect.exitPresent();\r\n\t\t\t\t}\r\n\t\t\t\tvar vrEffect = new THREE.VREffect(ctx.renderer);\r\n\t\t\t\tvr.vrEffect = vrEffect;\r\n\t\t\t\twindow.lastVrEffect = vrEffect;\r\n\r\n\t\t\t\twindow.addEventListener('vrdisplaypresentchange', function (event) {\r\n\t\t\t\t\tctx.animControl.trigger()\r\n\t\t\t\t}, false);\r\n\r\n\t\t\t\tctx.vrButton.addEventListener(\"click\", function () {\r\n\t\t\t\t\tif (vrEffect.isPresenting) {\r\n\t\t\t\t\t\tvrEffect.exitPresent();\r\n\t\t\t\t\t\tctx.vrButton.setAttribute(\"src\", ctx.vrButton.getAttribute(\"data-vr-enter-src\"));\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\tvrEffect.requestPresent();\r\n\t\t\t\t\t\tctx.vrButton.setAttribute(\"src\", ctx.vrButton.getAttribute(\"data-vr-exit-src\"));\r\n\t\t\t\t\t\tLookAtHarbor();\r\n\t\t\t\t\t}\r\n\t\t\t\t\tanimControl.trigger();\r\n\t\t\t\t});\r\n\r\n\t\t\t}\r\n\r\n\t\t\tvr = {};\r\n\r\n\t\t\tif (typeof navigator.getVRDisplays != \"undefined\") {\r\n\t\t\t\tnavigator.getVRDisplays()\r\n\t\t\t\t\t.then(function (displays) {\r\n\t\t\t\t\t\tif (displays.length == 0)\r\n\t\t\t\t\t\t\tCardboardVR();\r\n\t\t\t\t\t\telse\r\n\t\t\t\t\t\t\tPureVR();\r\n\t\t\t\t\t}).catch(function () {\r\n\t\t\t\t\t\tCardboardVR();\r\n\t\t\t\t\t});\r\n\t\t\t} else\r\n\t\t\t\tCardboardVR();\r\n\r\n\t\t\treturn vr;\r\n\t\t}\r\n\r\n\t\tvar vr = VRSetup(ctx);\r\n\r\n\t\treturn $.extend(ctx, vr);\r\n\t}\r\n\r\n\r\n\tfunction GetEventPosition(event) {\r\n\t\tif (event.originalEvent)\r\n\t\t\treturn GetEventPosition(event.originalEvent);\r\n\t\tif (event.changedTouches && event.changedTouches.length > 0)\r\n\t\t\treturn [event.changedTouches[0].pageX, event.changedTouches[0].pageY];\r\n\t\tif (event.touches && event.touches.length > 0)\r\n\t\t\treturn [event.touches[0].pageX, event.touches[0].pageY];\r\n\t\treturn [event.pageX, event.pageY];\r\n\t}\r\n\r\n\tfunction AR(stream) {\r\n\t\tif (!!arStream == !!stream) {\r\n\t\t\tconsole.warn(\"AR is already\", !!stream);\r\n\t\t\treturn;\r\n\t\t}\r\n\t\tarStream = stream;\r\n\t\tif (arStream) {\r\n\t\t\tvar video = $(\"<video/>\").addClass(\"ar-video\").attr(\"autoplay\", \"autoplay\").css({\r\n\t\t\t\tposition: \"absolute\",\r\n\t\t\t\ttop: 0,\r\n\t\t\t\twidth: \"100%\",\r\n\t\t\t\theight: \"100%\",\r\n\t\t\t\tleft: 0,\r\n\t\t\t\t\"z-index\": -1,\r\n\t\t\t\tbackgroundColor: \"#0f0\",\r\n\t\t\t\tobjectFit: \"cover\"\r\n\t\t\t}).appendTo(area.parent());\r\n\t\t\tJoclyAR.attach({\r\n\t\t\t\telement: video[0],\r\n\t\t\t\tstream: arStream,\r\n\t\t\t\tthreeCtx: threeCtx\r\n\t\t\t});\r\n\t\t\txdv.redisplayGadgets();\r\n\t\t\tthreeCtx.renderer.setClearColor(new THREE.Color(threeCtx.world.color), 0);\r\n\t\t\tthreeCtx.animControl.trigger();\r\n\t\t} else {\r\n\t\t\tvar video = area.parent().find(\".ar-video\");\r\n\t\t\tif (video.length) {\r\n\t\t\t\tJoclyAR.detach({\r\n\t\t\t\t\telement: video[0]\r\n\t\t\t\t});\r\n\t\t\t\tvideo.remove();\r\n\t\t\t}\r\n\t\t\txdv.redisplayGadgets();\r\n\t\t\tthreeCtx.renderer.setClearColor(new THREE.Color(threeCtx.world.color), 1);\r\n\t\t\tthreeCtx.animControl.trigger();\r\n\t\t}\r\n\t}\r\n\r\n})();\r\n"]}